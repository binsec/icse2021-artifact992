unsigned int __builtin_bswap32 (unsigned int);

# 212 "/usr/lib/gcc/i586-linux-gnu/4.9/include/stddef.h"
typedef unsigned int size_t;

# 121 "/usr/include/i386-linux-gnu/gpg-error.h"
typedef enum
  {
    GPG_ERR_NO_ERROR = 0,
    GPG_ERR_GENERAL = 1,
    GPG_ERR_UNKNOWN_PACKET = 2,
    GPG_ERR_UNKNOWN_VERSION = 3,
    GPG_ERR_PUBKEY_ALGO = 4,
    GPG_ERR_DIGEST_ALGO = 5,
    GPG_ERR_BAD_PUBKEY = 6,
    GPG_ERR_BAD_SECKEY = 7,
    GPG_ERR_BAD_SIGNATURE = 8,
    GPG_ERR_NO_PUBKEY = 9,
    GPG_ERR_CHECKSUM = 10,
    GPG_ERR_BAD_PASSPHRASE = 11,
    GPG_ERR_CIPHER_ALGO = 12,
    GPG_ERR_KEYRING_OPEN = 13,
    GPG_ERR_INV_PACKET = 14,
    GPG_ERR_INV_ARMOR = 15,
    GPG_ERR_NO_USER_ID = 16,
    GPG_ERR_NO_SECKEY = 17,
    GPG_ERR_WRONG_SECKEY = 18,
    GPG_ERR_BAD_KEY = 19,
    GPG_ERR_COMPR_ALGO = 20,
    GPG_ERR_NO_PRIME = 21,
    GPG_ERR_NO_ENCODING_METHOD = 22,
    GPG_ERR_NO_ENCRYPTION_SCHEME = 23,
    GPG_ERR_NO_SIGNATURE_SCHEME = 24,
    GPG_ERR_INV_ATTR = 25,
    GPG_ERR_NO_VALUE = 26,
    GPG_ERR_NOT_FOUND = 27,
    GPG_ERR_VALUE_NOT_FOUND = 28,
    GPG_ERR_SYNTAX = 29,
    GPG_ERR_BAD_MPI = 30,
    GPG_ERR_INV_PASSPHRASE = 31,
    GPG_ERR_SIG_CLASS = 32,
    GPG_ERR_RESOURCE_LIMIT = 33,
    GPG_ERR_INV_KEYRING = 34,
    GPG_ERR_TRUSTDB = 35,
    GPG_ERR_BAD_CERT = 36,
    GPG_ERR_INV_USER_ID = 37,
    GPG_ERR_UNEXPECTED = 38,
    GPG_ERR_TIME_CONFLICT = 39,
    GPG_ERR_KEYSERVER = 40,
    GPG_ERR_WRONG_PUBKEY_ALGO = 41,
    GPG_ERR_TRIBUTE_TO_D_A = 42,
    GPG_ERR_WEAK_KEY = 43,
    GPG_ERR_INV_KEYLEN = 44,
    GPG_ERR_INV_ARG = 45,
    GPG_ERR_BAD_URI = 46,
    GPG_ERR_INV_URI = 47,
    GPG_ERR_NETWORK = 48,
    GPG_ERR_UNKNOWN_HOST = 49,
    GPG_ERR_SELFTEST_FAILED = 50,
    GPG_ERR_NOT_ENCRYPTED = 51,
    GPG_ERR_NOT_PROCESSED = 52,
    GPG_ERR_UNUSABLE_PUBKEY = 53,
    GPG_ERR_UNUSABLE_SECKEY = 54,
    GPG_ERR_INV_VALUE = 55,
    GPG_ERR_BAD_CERT_CHAIN = 56,
    GPG_ERR_MISSING_CERT = 57,
    GPG_ERR_NO_DATA = 58,
    GPG_ERR_BUG = 59,
    GPG_ERR_NOT_SUPPORTED = 60,
    GPG_ERR_INV_OP = 61,
    GPG_ERR_TIMEOUT = 62,
    GPG_ERR_INTERNAL = 63,
    GPG_ERR_EOF_GCRYPT = 64,
    GPG_ERR_INV_OBJ = 65,
    GPG_ERR_TOO_SHORT = 66,
    GPG_ERR_TOO_LARGE = 67,
    GPG_ERR_NO_OBJ = 68,
    GPG_ERR_NOT_IMPLEMENTED = 69,
    GPG_ERR_CONFLICT = 70,
    GPG_ERR_INV_CIPHER_MODE = 71,
    GPG_ERR_INV_FLAG = 72,
    GPG_ERR_INV_HANDLE = 73,
    GPG_ERR_TRUNCATED = 74,
    GPG_ERR_INCOMPLETE_LINE = 75,
    GPG_ERR_INV_RESPONSE = 76,
    GPG_ERR_NO_AGENT = 77,
    GPG_ERR_AGENT = 78,
    GPG_ERR_INV_DATA = 79,
    GPG_ERR_ASSUAN_SERVER_FAULT = 80,
    GPG_ERR_ASSUAN = 81,
    GPG_ERR_INV_SESSION_KEY = 82,
    GPG_ERR_INV_SEXP = 83,
    GPG_ERR_UNSUPPORTED_ALGORITHM = 84,
    GPG_ERR_NO_PIN_ENTRY = 85,
    GPG_ERR_PIN_ENTRY = 86,
    GPG_ERR_BAD_PIN = 87,
    GPG_ERR_INV_NAME = 88,
    GPG_ERR_BAD_DATA = 89,
    GPG_ERR_INV_PARAMETER = 90,
    GPG_ERR_WRONG_CARD = 91,
    GPG_ERR_NO_DIRMNGR = 92,
    GPG_ERR_DIRMNGR = 93,
    GPG_ERR_CERT_REVOKED = 94,
    GPG_ERR_NO_CRL_KNOWN = 95,
    GPG_ERR_CRL_TOO_OLD = 96,
    GPG_ERR_LINE_TOO_LONG = 97,
    GPG_ERR_NOT_TRUSTED = 98,
    GPG_ERR_CANCELED = 99,
    GPG_ERR_BAD_CA_CERT = 100,
    GPG_ERR_CERT_EXPIRED = 101,
    GPG_ERR_CERT_TOO_YOUNG = 102,
    GPG_ERR_UNSUPPORTED_CERT = 103,
    GPG_ERR_UNKNOWN_SEXP = 104,
    GPG_ERR_UNSUPPORTED_PROTECTION = 105,
    GPG_ERR_CORRUPTED_PROTECTION = 106,
    GPG_ERR_AMBIGUOUS_NAME = 107,
    GPG_ERR_CARD = 108,
    GPG_ERR_CARD_RESET = 109,
    GPG_ERR_CARD_REMOVED = 110,
    GPG_ERR_INV_CARD = 111,
    GPG_ERR_CARD_NOT_PRESENT = 112,
    GPG_ERR_NO_PKCS15_APP = 113,
    GPG_ERR_NOT_CONFIRMED = 114,
    GPG_ERR_CONFIGURATION = 115,
    GPG_ERR_NO_POLICY_MATCH = 116,
    GPG_ERR_INV_INDEX = 117,
    GPG_ERR_INV_ID = 118,
    GPG_ERR_NO_SCDAEMON = 119,
    GPG_ERR_SCDAEMON = 120,
    GPG_ERR_UNSUPPORTED_PROTOCOL = 121,
    GPG_ERR_BAD_PIN_METHOD = 122,
    GPG_ERR_CARD_NOT_INITIALIZED = 123,
    GPG_ERR_UNSUPPORTED_OPERATION = 124,
    GPG_ERR_WRONG_KEY_USAGE = 125,
    GPG_ERR_NOTHING_FOUND = 126,
    GPG_ERR_WRONG_BLOB_TYPE = 127,
    GPG_ERR_MISSING_VALUE = 128,
    GPG_ERR_HARDWARE = 129,
    GPG_ERR_PIN_BLOCKED = 130,
    GPG_ERR_USE_CONDITIONS = 131,
    GPG_ERR_PIN_NOT_SYNCED = 132,
    GPG_ERR_INV_CRL = 133,
    GPG_ERR_BAD_BER = 134,
    GPG_ERR_INV_BER = 135,
    GPG_ERR_ELEMENT_NOT_FOUND = 136,
    GPG_ERR_IDENTIFIER_NOT_FOUND = 137,
    GPG_ERR_INV_TAG = 138,
    GPG_ERR_INV_LENGTH = 139,
    GPG_ERR_INV_KEYINFO = 140,
    GPG_ERR_UNEXPECTED_TAG = 141,
    GPG_ERR_NOT_DER_ENCODED = 142,
    GPG_ERR_NO_CMS_OBJ = 143,
    GPG_ERR_INV_CMS_OBJ = 144,
    GPG_ERR_UNKNOWN_CMS_OBJ = 145,
    GPG_ERR_UNSUPPORTED_CMS_OBJ = 146,
    GPG_ERR_UNSUPPORTED_ENCODING = 147,
    GPG_ERR_UNSUPPORTED_CMS_VERSION = 148,
    GPG_ERR_UNKNOWN_ALGORITHM = 149,
    GPG_ERR_INV_ENGINE = 150,
    GPG_ERR_PUBKEY_NOT_TRUSTED = 151,
    GPG_ERR_DECRYPT_FAILED = 152,
    GPG_ERR_KEY_EXPIRED = 153,
    GPG_ERR_SIG_EXPIRED = 154,
    GPG_ERR_ENCODING_PROBLEM = 155,
    GPG_ERR_INV_STATE = 156,
    GPG_ERR_DUP_VALUE = 157,
    GPG_ERR_MISSING_ACTION = 158,
    GPG_ERR_MODULE_NOT_FOUND = 159,
    GPG_ERR_INV_OID_STRING = 160,
    GPG_ERR_INV_TIME = 161,
    GPG_ERR_INV_CRL_OBJ = 162,
    GPG_ERR_UNSUPPORTED_CRL_VERSION = 163,
    GPG_ERR_INV_CERT_OBJ = 164,
    GPG_ERR_UNKNOWN_NAME = 165,
    GPG_ERR_LOCALE_PROBLEM = 166,
    GPG_ERR_NOT_LOCKED = 167,
    GPG_ERR_PROTOCOL_VIOLATION = 168,
    GPG_ERR_INV_MAC = 169,
    GPG_ERR_INV_REQUEST = 170,
    GPG_ERR_UNKNOWN_EXTN = 171,
    GPG_ERR_UNKNOWN_CRIT_EXTN = 172,
    GPG_ERR_LOCKED = 173,
    GPG_ERR_UNKNOWN_OPTION = 174,
    GPG_ERR_UNKNOWN_COMMAND = 175,
    GPG_ERR_NOT_OPERATIONAL = 176,
    GPG_ERR_NO_PASSPHRASE = 177,
    GPG_ERR_NO_PIN = 178,
    GPG_ERR_NOT_ENABLED = 179,
    GPG_ERR_NO_ENGINE = 180,
    GPG_ERR_MISSING_KEY = 181,
    GPG_ERR_TOO_MANY = 182,
    GPG_ERR_LIMIT_REACHED = 183,
    GPG_ERR_NOT_INITIALIZED = 184,
    GPG_ERR_MISSING_ISSUER_CERT = 185,
    GPG_ERR_NO_KEYSERVER = 186,
    GPG_ERR_INV_CURVE = 187,
    GPG_ERR_UNKNOWN_CURVE = 188,
    GPG_ERR_DUP_KEY = 189,
    GPG_ERR_AMBIGUOUS = 190,
    GPG_ERR_NO_CRYPT_CTX = 191,
    GPG_ERR_WRONG_CRYPT_CTX = 192,
    GPG_ERR_BAD_CRYPT_CTX = 193,
    GPG_ERR_CRYPT_CTX_CONFLICT = 194,
    GPG_ERR_BROKEN_PUBKEY = 195,
    GPG_ERR_BROKEN_SECKEY = 196,
    GPG_ERR_MAC_ALGO = 197,
    GPG_ERR_FULLY_CANCELED = 198,
    GPG_ERR_UNFINISHED = 199,
    GPG_ERR_BUFFER_TOO_SHORT = 200,
    GPG_ERR_SEXP_INV_LEN_SPEC = 201,
    GPG_ERR_SEXP_STRING_TOO_LONG = 202,
    GPG_ERR_SEXP_UNMATCHED_PAREN = 203,
    GPG_ERR_SEXP_NOT_CANONICAL = 204,
    GPG_ERR_SEXP_BAD_CHARACTER = 205,
    GPG_ERR_SEXP_BAD_QUOTATION = 206,
    GPG_ERR_SEXP_ZERO_PREFIX = 207,
    GPG_ERR_SEXP_NESTED_DH = 208,
    GPG_ERR_SEXP_UNMATCHED_DH = 209,
    GPG_ERR_SEXP_UNEXPECTED_PUNC = 210,
    GPG_ERR_SEXP_BAD_HEX_CHAR = 211,
    GPG_ERR_SEXP_ODD_HEX_NUMBERS = 212,
    GPG_ERR_SEXP_BAD_OCT_CHAR = 213,
    GPG_ERR_NO_CERT_CHAIN = 226,
    GPG_ERR_CERT_TOO_LARGE = 227,
    GPG_ERR_INV_RECORD = 228,
    GPG_ERR_BAD_MAC = 229,
    GPG_ERR_UNEXPECTED_MSG = 230,
    GPG_ERR_COMPR_FAILED = 231,
    GPG_ERR_WOULD_WRAP = 232,
    GPG_ERR_FATAL_ALERT = 233,
    GPG_ERR_NO_CIPHER = 234,
    GPG_ERR_MISSING_CLIENT_CERT = 235,
    GPG_ERR_CLOSE_NOTIFY = 236,
    GPG_ERR_TICKET_EXPIRED = 237,
    GPG_ERR_BAD_TICKET = 238,
    GPG_ERR_UNKNOWN_IDENTITY = 239,
    GPG_ERR_BAD_HS_CERT = 240,
    GPG_ERR_BAD_HS_CERT_REQ = 241,
    GPG_ERR_BAD_HS_CERT_VER = 242,
    GPG_ERR_BAD_HS_CHANGE_CIPHER = 243,
    GPG_ERR_BAD_HS_CLIENT_HELLO = 244,
    GPG_ERR_BAD_HS_SERVER_HELLO = 245,
    GPG_ERR_BAD_HS_SERVER_HELLO_DONE = 246,
    GPG_ERR_BAD_HS_FINISHED = 247,
    GPG_ERR_BAD_HS_SERVER_KEX = 248,
    GPG_ERR_BAD_HS_CLIENT_KEX = 249,
    GPG_ERR_BOGUS_STRING = 250,
    GPG_ERR_KEY_DISABLED = 252,
    GPG_ERR_KEY_ON_CARD = 253,
    GPG_ERR_INV_LOCK_OBJ = 254,
    GPG_ERR_ASS_GENERAL = 257,
    GPG_ERR_ASS_ACCEPT_FAILED = 258,
    GPG_ERR_ASS_CONNECT_FAILED = 259,
    GPG_ERR_ASS_INV_RESPONSE = 260,
    GPG_ERR_ASS_INV_VALUE = 261,
    GPG_ERR_ASS_INCOMPLETE_LINE = 262,
    GPG_ERR_ASS_LINE_TOO_LONG = 263,
    GPG_ERR_ASS_NESTED_COMMANDS = 264,
    GPG_ERR_ASS_NO_DATA_CB = 265,
    GPG_ERR_ASS_NO_INQUIRE_CB = 266,
    GPG_ERR_ASS_NOT_A_SERVER = 267,
    GPG_ERR_ASS_NOT_A_CLIENT = 268,
    GPG_ERR_ASS_SERVER_START = 269,
    GPG_ERR_ASS_READ_ERROR = 270,
    GPG_ERR_ASS_WRITE_ERROR = 271,
    GPG_ERR_ASS_TOO_MUCH_DATA = 273,
    GPG_ERR_ASS_UNEXPECTED_CMD = 274,
    GPG_ERR_ASS_UNKNOWN_CMD = 275,
    GPG_ERR_ASS_SYNTAX = 276,
    GPG_ERR_ASS_CANCELED = 277,
    GPG_ERR_ASS_NO_INPUT = 278,
    GPG_ERR_ASS_NO_OUTPUT = 279,
    GPG_ERR_ASS_PARAMETER = 280,
    GPG_ERR_ASS_UNKNOWN_INQUIRE = 281,
    GPG_ERR_USER_1 = 1024,
    GPG_ERR_USER_2 = 1025,
    GPG_ERR_USER_3 = 1026,
    GPG_ERR_USER_4 = 1027,
    GPG_ERR_USER_5 = 1028,
    GPG_ERR_USER_6 = 1029,
    GPG_ERR_USER_7 = 1030,
    GPG_ERR_USER_8 = 1031,
    GPG_ERR_USER_9 = 1032,
    GPG_ERR_USER_10 = 1033,
    GPG_ERR_USER_11 = 1034,
    GPG_ERR_USER_12 = 1035,
    GPG_ERR_USER_13 = 1036,
    GPG_ERR_USER_14 = 1037,
    GPG_ERR_USER_15 = 1038,
    GPG_ERR_USER_16 = 1039,
    GPG_ERR_MISSING_ERRNO = 16381,
    GPG_ERR_UNKNOWN_ERRNO = 16382,
    GPG_ERR_EOF = 16383,

    /* The following error codes are used to map system errors.  */

    GPG_ERR_E2BIG = (1 << 15) | 0,
    GPG_ERR_EACCES = (1 << 15) | 1,
    GPG_ERR_EADDRINUSE = (1 << 15) | 2,
    GPG_ERR_EADDRNOTAVAIL = (1 << 15) | 3,
    GPG_ERR_EADV = (1 << 15) | 4,
    GPG_ERR_EAFNOSUPPORT = (1 << 15) | 5,
    GPG_ERR_EAGAIN = (1 << 15) | 6,
    GPG_ERR_EALREADY = (1 << 15) | 7,
    GPG_ERR_EAUTH = (1 << 15) | 8,
    GPG_ERR_EBACKGROUND = (1 << 15) | 9,
    GPG_ERR_EBADE = (1 << 15) | 10,
    GPG_ERR_EBADF = (1 << 15) | 11,
    GPG_ERR_EBADFD = (1 << 15) | 12,
    GPG_ERR_EBADMSG = (1 << 15) | 13,
    GPG_ERR_EBADR = (1 << 15) | 14,
    GPG_ERR_EBADRPC = (1 << 15) | 15,
    GPG_ERR_EBADRQC = (1 << 15) | 16,
    GPG_ERR_EBADSLT = (1 << 15) | 17,
    GPG_ERR_EBFONT = (1 << 15) | 18,
    GPG_ERR_EBUSY = (1 << 15) | 19,
    GPG_ERR_ECANCELED = (1 << 15) | 20,
    GPG_ERR_ECHILD = (1 << 15) | 21,
    GPG_ERR_ECHRNG = (1 << 15) | 22,
    GPG_ERR_ECOMM = (1 << 15) | 23,
    GPG_ERR_ECONNABORTED = (1 << 15) | 24,
    GPG_ERR_ECONNREFUSED = (1 << 15) | 25,
    GPG_ERR_ECONNRESET = (1 << 15) | 26,
    GPG_ERR_ED = (1 << 15) | 27,
    GPG_ERR_EDEADLK = (1 << 15) | 28,
    GPG_ERR_EDEADLOCK = (1 << 15) | 29,
    GPG_ERR_EDESTADDRREQ = (1 << 15) | 30,
    GPG_ERR_EDIED = (1 << 15) | 31,
    GPG_ERR_EDOM = (1 << 15) | 32,
    GPG_ERR_EDOTDOT = (1 << 15) | 33,
    GPG_ERR_EDQUOT = (1 << 15) | 34,
    GPG_ERR_EEXIST = (1 << 15) | 35,
    GPG_ERR_EFAULT = (1 << 15) | 36,
    GPG_ERR_EFBIG = (1 << 15) | 37,
    GPG_ERR_EFTYPE = (1 << 15) | 38,
    GPG_ERR_EGRATUITOUS = (1 << 15) | 39,
    GPG_ERR_EGREGIOUS = (1 << 15) | 40,
    GPG_ERR_EHOSTDOWN = (1 << 15) | 41,
    GPG_ERR_EHOSTUNREACH = (1 << 15) | 42,
    GPG_ERR_EIDRM = (1 << 15) | 43,
    GPG_ERR_EIEIO = (1 << 15) | 44,
    GPG_ERR_EILSEQ = (1 << 15) | 45,
    GPG_ERR_EINPROGRESS = (1 << 15) | 46,
    GPG_ERR_EINTR = (1 << 15) | 47,
    GPG_ERR_EINVAL = (1 << 15) | 48,
    GPG_ERR_EIO = (1 << 15) | 49,
    GPG_ERR_EISCONN = (1 << 15) | 50,
    GPG_ERR_EISDIR = (1 << 15) | 51,
    GPG_ERR_EISNAM = (1 << 15) | 52,
    GPG_ERR_EL2HLT = (1 << 15) | 53,
    GPG_ERR_EL2NSYNC = (1 << 15) | 54,
    GPG_ERR_EL3HLT = (1 << 15) | 55,
    GPG_ERR_EL3RST = (1 << 15) | 56,
    GPG_ERR_ELIBACC = (1 << 15) | 57,
    GPG_ERR_ELIBBAD = (1 << 15) | 58,
    GPG_ERR_ELIBEXEC = (1 << 15) | 59,
    GPG_ERR_ELIBMAX = (1 << 15) | 60,
    GPG_ERR_ELIBSCN = (1 << 15) | 61,
    GPG_ERR_ELNRNG = (1 << 15) | 62,
    GPG_ERR_ELOOP = (1 << 15) | 63,
    GPG_ERR_EMEDIUMTYPE = (1 << 15) | 64,
    GPG_ERR_EMFILE = (1 << 15) | 65,
    GPG_ERR_EMLINK = (1 << 15) | 66,
    GPG_ERR_EMSGSIZE = (1 << 15) | 67,
    GPG_ERR_EMULTIHOP = (1 << 15) | 68,
    GPG_ERR_ENAMETOOLONG = (1 << 15) | 69,
    GPG_ERR_ENAVAIL = (1 << 15) | 70,
    GPG_ERR_ENEEDAUTH = (1 << 15) | 71,
    GPG_ERR_ENETDOWN = (1 << 15) | 72,
    GPG_ERR_ENETRESET = (1 << 15) | 73,
    GPG_ERR_ENETUNREACH = (1 << 15) | 74,
    GPG_ERR_ENFILE = (1 << 15) | 75,
    GPG_ERR_ENOANO = (1 << 15) | 76,
    GPG_ERR_ENOBUFS = (1 << 15) | 77,
    GPG_ERR_ENOCSI = (1 << 15) | 78,
    GPG_ERR_ENODATA = (1 << 15) | 79,
    GPG_ERR_ENODEV = (1 << 15) | 80,
    GPG_ERR_ENOENT = (1 << 15) | 81,
    GPG_ERR_ENOEXEC = (1 << 15) | 82,
    GPG_ERR_ENOLCK = (1 << 15) | 83,
    GPG_ERR_ENOLINK = (1 << 15) | 84,
    GPG_ERR_ENOMEDIUM = (1 << 15) | 85,
    GPG_ERR_ENOMEM = (1 << 15) | 86,
    GPG_ERR_ENOMSG = (1 << 15) | 87,
    GPG_ERR_ENONET = (1 << 15) | 88,
    GPG_ERR_ENOPKG = (1 << 15) | 89,
    GPG_ERR_ENOPROTOOPT = (1 << 15) | 90,
    GPG_ERR_ENOSPC = (1 << 15) | 91,
    GPG_ERR_ENOSR = (1 << 15) | 92,
    GPG_ERR_ENOSTR = (1 << 15) | 93,
    GPG_ERR_ENOSYS = (1 << 15) | 94,
    GPG_ERR_ENOTBLK = (1 << 15) | 95,
    GPG_ERR_ENOTCONN = (1 << 15) | 96,
    GPG_ERR_ENOTDIR = (1 << 15) | 97,
    GPG_ERR_ENOTEMPTY = (1 << 15) | 98,
    GPG_ERR_ENOTNAM = (1 << 15) | 99,
    GPG_ERR_ENOTSOCK = (1 << 15) | 100,
    GPG_ERR_ENOTSUP = (1 << 15) | 101,
    GPG_ERR_ENOTTY = (1 << 15) | 102,
    GPG_ERR_ENOTUNIQ = (1 << 15) | 103,
    GPG_ERR_ENXIO = (1 << 15) | 104,
    GPG_ERR_EOPNOTSUPP = (1 << 15) | 105,
    GPG_ERR_EOVERFLOW = (1 << 15) | 106,
    GPG_ERR_EPERM = (1 << 15) | 107,
    GPG_ERR_EPFNOSUPPORT = (1 << 15) | 108,
    GPG_ERR_EPIPE = (1 << 15) | 109,
    GPG_ERR_EPROCLIM = (1 << 15) | 110,
    GPG_ERR_EPROCUNAVAIL = (1 << 15) | 111,
    GPG_ERR_EPROGMISMATCH = (1 << 15) | 112,
    GPG_ERR_EPROGUNAVAIL = (1 << 15) | 113,
    GPG_ERR_EPROTO = (1 << 15) | 114,
    GPG_ERR_EPROTONOSUPPORT = (1 << 15) | 115,
    GPG_ERR_EPROTOTYPE = (1 << 15) | 116,
    GPG_ERR_ERANGE = (1 << 15) | 117,
    GPG_ERR_EREMCHG = (1 << 15) | 118,
    GPG_ERR_EREMOTE = (1 << 15) | 119,
    GPG_ERR_EREMOTEIO = (1 << 15) | 120,
    GPG_ERR_ERESTART = (1 << 15) | 121,
    GPG_ERR_EROFS = (1 << 15) | 122,
    GPG_ERR_ERPCMISMATCH = (1 << 15) | 123,
    GPG_ERR_ESHUTDOWN = (1 << 15) | 124,
    GPG_ERR_ESOCKTNOSUPPORT = (1 << 15) | 125,
    GPG_ERR_ESPIPE = (1 << 15) | 126,
    GPG_ERR_ESRCH = (1 << 15) | 127,
    GPG_ERR_ESRMNT = (1 << 15) | 128,
    GPG_ERR_ESTALE = (1 << 15) | 129,
    GPG_ERR_ESTRPIPE = (1 << 15) | 130,
    GPG_ERR_ETIME = (1 << 15) | 131,
    GPG_ERR_ETIMEDOUT = (1 << 15) | 132,
    GPG_ERR_ETOOMANYREFS = (1 << 15) | 133,
    GPG_ERR_ETXTBSY = (1 << 15) | 134,
    GPG_ERR_EUCLEAN = (1 << 15) | 135,
    GPG_ERR_EUNATCH = (1 << 15) | 136,
    GPG_ERR_EUSERS = (1 << 15) | 137,
    GPG_ERR_EWOULDBLOCK = (1 << 15) | 138,
    GPG_ERR_EXDEV = (1 << 15) | 139,
    GPG_ERR_EXFULL = (1 << 15) | 140,

    /* This is one more than the largest allowed entry.  */
    GPG_ERR_CODE_DIM = 65536
  } gpg_err_code_t;

# 128 "/usr/include/stdint.h"
typedef unsigned int uintptr_t;

# 136 "../src/gcrypt.h"
typedef gpg_err_code_t gcry_err_code_t;

# 843 "../src/gcrypt.h"
typedef struct gcry_cipher_handle *gcry_cipher_hd_t;

# 49 "../src/types.h"
typedef unsigned char byte;

# 71 "../src/types.h"
typedef unsigned short u16;

# 81 "../src/types.h"
typedef unsigned int u32;

# 106 "../src/types.h"
typedef unsigned long long u64;

# 116 "../src/types.h"
typedef union
{
  int a;
  short b;
  char c[1];
  long d;

  u64 e;

  float f;
  double g;
} PROPERLY_ALIGNED_TYPE;

# 36 "../src/cipher-proto.h"
typedef void (*selftest_report_func_t)(const char *domain,
                                       int algo,
                                       const char *what,
                                       const char *errdesc);

# 42 "../src/cipher-proto.h"
typedef gpg_err_code_t (*selftest_func_t)
     (int algo, int extended, selftest_report_func_t report);

# 133 "../src/cipher-proto.h"
typedef gcry_err_code_t (*gcry_cipher_setkey_t) (void *c,
       const unsigned char *key,
       unsigned keylen);

# 138 "../src/cipher-proto.h"
typedef unsigned int (*gcry_cipher_encrypt_t) (void *c,
            unsigned char *outbuf,
            const unsigned char *inbuf);

# 143 "../src/cipher-proto.h"
typedef unsigned int (*gcry_cipher_decrypt_t) (void *c,
            unsigned char *outbuf,
            const unsigned char *inbuf);

# 148 "../src/cipher-proto.h"
typedef void (*gcry_cipher_stencrypt_t) (void *c,
      unsigned char *outbuf,
      const unsigned char *inbuf,
      size_t n);

# 154 "../src/cipher-proto.h"
typedef void (*gcry_cipher_stdecrypt_t) (void *c,
      unsigned char *outbuf,
      const unsigned char *inbuf,
      size_t n);

# 160 "../src/cipher-proto.h"
typedef gpg_err_code_t (*cipher_set_extra_info_t)
     (void *c, int what, const void *buffer, size_t buflen);

# 164 "../src/cipher-proto.h"
typedef void (*cipher_setiv_func_t)(void *c, const byte *iv, size_t ivlen);

# 167 "../src/cipher-proto.h"
typedef struct gcry_cipher_oid_spec
{
  const char *oid;
  int mode;
} gcry_cipher_oid_spec_t;

# 175 "../src/cipher-proto.h"
typedef struct gcry_cipher_spec
{
  int algo;
  struct {
    unsigned int disabled:1;
    unsigned int fips:1;
  } flags;
  const char *name;
  const char **aliases;
  gcry_cipher_oid_spec_t *oids;
  size_t blocksize;
  size_t keylen;
  size_t contextsize;
  gcry_cipher_setkey_t setkey;
  gcry_cipher_encrypt_t encrypt;
  gcry_cipher_decrypt_t decrypt;
  gcry_cipher_stencrypt_t stencrypt;
  gcry_cipher_stdecrypt_t stdecrypt;
  selftest_func_t selftest;
  cipher_set_extra_info_t set_extra_info;
  cipher_setiv_func_t setiv;
} gcry_cipher_spec_t;

# 87 "bufhelp.h"
static inline void
buf_xor(void *_dst, const void *_src1, const void *_src2, size_t len)
{
  byte *dst = _dst;
  const byte *src1 = _src1;
  const byte *src2 = _src2;
  uintptr_t *ldst;
  const uintptr_t *lsrc1, *lsrc2;
# 103 "bufhelp.h"
  ldst = (uintptr_t *)(void *)dst;
  lsrc1 = (const uintptr_t *)(const void *)src1;
  lsrc2 = (const uintptr_t *)(const void *)src2;

  for (; len >= sizeof(uintptr_t); len -= sizeof(uintptr_t))
    *ldst++ = *lsrc1++ ^ *lsrc2++;

  dst = (byte *)ldst;
  src1 = (const byte *)lsrc1;
  src2 = (const byte *)lsrc2;




  /* Handle tail.  */
  for (; len; len--)
    *dst++ = *src1++ ^ *src2++;
}

# 338 "bufhelp.h"
static inline void buf_put_be32(void *_buf, u32 val)
{
  u32 *out = _buf;
  *out = __builtin_bswap32(val);
}

# 62 "./cipher-internal.h"
typedef union
{
  PROPERLY_ALIGNED_TYPE foo;

  char bar[16] ;

  char c[1];
} cipher_context_alignment_t;

# 73 "./cipher-internal.h"
struct gcry_cipher_handle
{
  int magic;
  size_t actual_handle_size; /* Allocated size of this handle. */
  size_t handle_offset; /* Offset to the malloced block.  */
  gcry_cipher_spec_t *spec;

  /* The algorithm id.  This is a hack required because the module
     interface does not easily allow to retrieve this value. */
  int algo;

  /* A structure with function pointers for bulk operations.  Due to
     limitations of the module system (we don't want to change the
     API) we need to keep these function pointers here.  The cipher
     open function intializes them and the actual encryption routines
     use them if they are not NULL.  */
  struct {
    void (*cfb_enc)(void *context, unsigned char *iv,
                    void *outbuf_arg, const void *inbuf_arg,
                    size_t nblocks);
    void (*cfb_dec)(void *context, unsigned char *iv,
                    void *outbuf_arg, const void *inbuf_arg,
                    size_t nblocks);
    void (*cbc_enc)(void *context, unsigned char *iv,
                    void *outbuf_arg, const void *inbuf_arg,
                    size_t nblocks, int cbc_mac);
    void (*cbc_dec)(void *context, unsigned char *iv,
                    void *outbuf_arg, const void *inbuf_arg,
                    size_t nblocks);
    void (*ctr_enc)(void *context, unsigned char *iv,
                    void *outbuf_arg, const void *inbuf_arg,
                    size_t nblocks);
  } bulk;


  int mode;
  unsigned int flags;

  struct {
    unsigned int key:1; /* Set to 1 if a key has been set.  */
    unsigned int iv:1; /* Set to 1 if a IV has been set.  */
    unsigned int tag:1; /* Set to 1 if a tag is finalized. */
  } marks;

  /* The initialization vector.  For best performance we make sure
     that it is properly aligned.  In particular some implementations
     of bulk operations expect an 16 byte aligned IV.  IV is also used
     to store CBC-MAC in CCM mode; counter IV is stored in U_CTR.  */
  union {
    cipher_context_alignment_t iv_align;
    unsigned char iv[16];
  } u_iv;

  /* The counter for CTR mode.  This field is also used by AESWRAP and
     thus we can't use the U_IV union.  */
  union {
    cipher_context_alignment_t iv_align;
    unsigned char ctr[16];
  } u_ctr;

  /* Space to save an IV or CTR for chaining operations.  */
  unsigned char lastiv[16];
  int unused; /* Number of unused bytes in LASTIV. */

  union {

    /* Mode specific storage for CCM mode. */
    struct {
      u64 encryptlen;
      u64 aadlen;
      unsigned int authlen;

      /* Space to save partial input lengths for MAC. */
      unsigned char macbuf[(128 / 8)];
      int mac_unused; /* Number of unprocessed bytes in MACBUF. */

      unsigned char s0[(128 / 8)];

      unsigned int nonce:1;/* Set to 1 if nonce has been set.  */
      unsigned int lengths:1; /* Set to 1 if CCM length parameters has been
                                 processed.  */
    } ccm;


    /* Mode specific storage for CMAC mode. */
    struct {
      unsigned int tag:1; /* Set to 1 if tag has been finalized.  */

      /* Subkeys for tag creation, not cleared by gcry_cipher_reset. */
      unsigned char subkeys[2][16];
    } cmac;

    /* Mode specific storage for GCM mode. */
    struct {
      /* The interim tag for GCM mode.  */
      union {
        cipher_context_alignment_t iv_align;
        unsigned char tag[16];
      } u_tag;

      /* Space to save partial input lengths for MAC. */
      unsigned char macbuf[(128 / 8)];
      int mac_unused; /* Number of unprocessed bytes in MACBUF. */

      /* byte counters for GCM */
      u32 aadlen[2];
      u32 datalen[2];

      /* encrypted tag counter */
      unsigned char tagiv[16];

      unsigned int ghash_data_finalized:1;
      unsigned int ghash_aad_finalized:1;

      unsigned int datalen_over_limits:1;
      unsigned int disallow_encryption_because_of_setiv_in_fips_mode:1;

      /* --- Following members are not cleared in gcry_cipher_reset --- */

      /* GHASH multiplier from key.  */
      union {
        cipher_context_alignment_t iv_align;
        unsigned char key[16];
      } u_ghash_key;


      /* Use Intel PCLMUL instructions for accelerated GHASH. */
      unsigned int use_intel_pclmul:1;


      /* Pre-calculated table for GCM. */







      u32 gcm_table[4 * 16];


    } gcm;
  } u_mode;

  /* What follows are two contexts of the cipher in use.  The first
     one needs to be aligned well enough for the cipher operation
     whereas the second one is a copy created by cipher_setkey and
     used by cipher_reset.  That second copy has no need for proper
     aligment because it is only accessed by memcpy.  */
  cipher_context_alignment_t context;
};

# 34 "cipher-gcm.c"
static const u16 gcmR[256] = {
  0x0000, 0x01c2, 0x0384, 0x0246, 0x0708, 0x06ca, 0x048c, 0x054e,
  0x0e10, 0x0fd2, 0x0d94, 0x0c56, 0x0918, 0x08da, 0x0a9c, 0x0b5e,
  0x1c20, 0x1de2, 0x1fa4, 0x1e66, 0x1b28, 0x1aea, 0x18ac, 0x196e,
  0x1230, 0x13f2, 0x11b4, 0x1076, 0x1538, 0x14fa, 0x16bc, 0x177e,
  0x3840, 0x3982, 0x3bc4, 0x3a06, 0x3f48, 0x3e8a, 0x3ccc, 0x3d0e,
  0x3650, 0x3792, 0x35d4, 0x3416, 0x3158, 0x309a, 0x32dc, 0x331e,
  0x2460, 0x25a2, 0x27e4, 0x2626, 0x2368, 0x22aa, 0x20ec, 0x212e,
  0x2a70, 0x2bb2, 0x29f4, 0x2836, 0x2d78, 0x2cba, 0x2efc, 0x2f3e,
  0x7080, 0x7142, 0x7304, 0x72c6, 0x7788, 0x764a, 0x740c, 0x75ce,
  0x7e90, 0x7f52, 0x7d14, 0x7cd6, 0x7998, 0x785a, 0x7a1c, 0x7bde,
  0x6ca0, 0x6d62, 0x6f24, 0x6ee6, 0x6ba8, 0x6a6a, 0x682c, 0x69ee,
  0x62b0, 0x6372, 0x6134, 0x60f6, 0x65b8, 0x647a, 0x663c, 0x67fe,
  0x48c0, 0x4902, 0x4b44, 0x4a86, 0x4fc8, 0x4e0a, 0x4c4c, 0x4d8e,
  0x46d0, 0x4712, 0x4554, 0x4496, 0x41d8, 0x401a, 0x425c, 0x439e,
  0x54e0, 0x5522, 0x5764, 0x56a6, 0x53e8, 0x522a, 0x506c, 0x51ae,
  0x5af0, 0x5b32, 0x5974, 0x58b6, 0x5df8, 0x5c3a, 0x5e7c, 0x5fbe,
  0xe100, 0xe0c2, 0xe284, 0xe346, 0xe608, 0xe7ca, 0xe58c, 0xe44e,
  0xef10, 0xeed2, 0xec94, 0xed56, 0xe818, 0xe9da, 0xeb9c, 0xea5e,
  0xfd20, 0xfce2, 0xfea4, 0xff66, 0xfa28, 0xfbea, 0xf9ac, 0xf86e,
  0xf330, 0xf2f2, 0xf0b4, 0xf176, 0xf438, 0xf5fa, 0xf7bc, 0xf67e,
  0xd940, 0xd882, 0xdac4, 0xdb06, 0xde48, 0xdf8a, 0xddcc, 0xdc0e,
  0xd750, 0xd692, 0xd4d4, 0xd516, 0xd058, 0xd19a, 0xd3dc, 0xd21e,
  0xc560, 0xc4a2, 0xc6e4, 0xc726, 0xc268, 0xc3aa, 0xc1ec, 0xc02e,
  0xcb70, 0xcab2, 0xc8f4, 0xc936, 0xcc78, 0xcdba, 0xcffc, 0xce3e,
  0x9180, 0x9042, 0x9204, 0x93c6, 0x9688, 0x974a, 0x950c, 0x94ce,
  0x9f90, 0x9e52, 0x9c14, 0x9dd6, 0x9898, 0x995a, 0x9b1c, 0x9ade,
  0x8da0, 0x8c62, 0x8e24, 0x8fe6, 0x8aa8, 0x8b6a, 0x892c, 0x88ee,
  0x83b0, 0x8272, 0x8034, 0x81f6, 0x84b8, 0x857a, 0x873c, 0x86fe,
  0xa9c0, 0xa802, 0xaa44, 0xab86, 0xaec8, 0xaf0a, 0xad4c, 0xac8e,
  0xa7d0, 0xa612, 0xa454, 0xa596, 0xa0d8, 0xa11a, 0xa35c, 0xa29e,
  0xb5e0, 0xb422, 0xb664, 0xb7a6, 0xb2e8, 0xb32a, 0xb16c, 0xb0ae,
  0xbbf0, 0xba32, 0xb874, 0xb9b6, 0xbcf8, 0xbd3a, 0xbf7c, 0xbebe,
};

# 220 "cipher-gcm.c"
static inline unsigned int
do_ghash (unsigned char *result, const unsigned char *buf, const u32 *gcmM)
{
  byte V[16];
  u32 tmp[4];
  u32 v;
  const u32 *M, *m;
  u32 T[3];
  int i;

  buf_xor (V, result, buf, 16); /* V is big-endian */

  /* First round can be manually tweaked based on fact that 'tmp' is zero. */
  i = 15;

  v = V[i];
  M = &gcmM[(v & 0xf) * 4];
  v = (v & 0xf0) >> 4;
  m = &gcmM[v * 4];
  v = V[--i];

  tmp[0] = (M[0] >> 4) ^ ((u64) gcmR[(M[3] << 4) & 0xf0] << 16) ^ m[0];
  tmp[1] = (M[1] >> 4) ^ (M[0] << 28) ^ m[1];
  tmp[2] = (M[2] >> 4) ^ (M[1] << 28) ^ m[2];
  tmp[3] = (M[3] >> 4) ^ (M[2] << 28) ^ m[3];

  while (1)
    {
      M = &gcmM[(v & 0xf) * 4];
      v = (v & 0xf0) >> 4;
      m = &gcmM[v * 4];

      T[0] = tmp[0];
      T[1] = tmp[1];
      T[2] = tmp[2];
      tmp[0] = (T[0] >> 8) ^ ((u32) gcmR[tmp[3] & 0xff] << 16) ^ m[0];
      tmp[1] = (T[0] << 24) ^ (tmp[1] >> 8) ^ m[1];
      tmp[2] = (T[1] << 24) ^ (tmp[2] >> 8) ^ m[2];
      tmp[3] = (T[2] << 24) ^ (tmp[3] >> 8) ^ m[3];

      tmp[0] ^= (M[0] >> 4) ^ ((u64) gcmR[(M[3] << 4) & 0xf0] << 16);
      tmp[1] ^= (M[1] >> 4) ^ (M[0] << 28);
      tmp[2] ^= (M[2] >> 4) ^ (M[1] << 28);
      tmp[3] ^= (M[3] >> 4) ^ (M[2] << 28);

      if (i == 0)
        break;

      v = V[--i];
    }

  buf_put_be32 (result + 0, tmp[0]);
  buf_put_be32 (result + 4, tmp[1]);
  buf_put_be32 (result + 8, tmp[2]);
  buf_put_be32 (result + 12, tmp[3]);

  return (sizeof(V) + sizeof(T) + sizeof(tmp) +
          sizeof(int)*2 + sizeof(void*)*6);
}

# 358 "cipher-gcm.c"
static inline void gfmul_pclmul(void)
{
  /* Input: XMM0 and XMM1, Output: XMM1. Input XMM0 stays unmodified.
     Input must be converted to little-endian.
   */
  asm volatile (/* gfmul, xmm0 has operator a and xmm1 has operator b. */
                "pshufd $78, %%xmm0, %%xmm2\n\t"
                "pshufd $78, %%xmm1, %%xmm4\n\t"
                "pxor %%xmm0, %%xmm2\n\t" /* xmm2 holds a0+a1 */
                "pxor %%xmm1, %%xmm4\n\t" /* xmm4 holds b0+b1 */

                "movdqa %%xmm0, %%xmm3\n\t"
                "pclmulqdq $0, %%xmm1, %%xmm3\n\t" /* xmm3 holds a0*b0 */
                "movdqa %%xmm0, %%xmm6\n\t"
                "pclmulqdq $17, %%xmm1, %%xmm6\n\t" /* xmm6 holds a1*b1 */
                "movdqa %%xmm3, %%xmm5\n\t"
                "pclmulqdq $0, %%xmm2, %%xmm4\n\t" /* xmm4 holds (a0+a1)*(b0+b1) */

                "pxor %%xmm6, %%xmm5\n\t" /* xmm5 holds a0*b0+a1*b1 */
                "pxor %%xmm5, %%xmm4\n\t" /* xmm4 holds a0*b0+a1*b1+(a0+a1)*(b0+b1) */
                "movdqa %%xmm4, %%xmm5\n\t"
                "psrldq $8, %%xmm4\n\t"
                "pslldq $8, %%xmm5\n\t"
                "pxor %%xmm5, %%xmm3\n\t"
                "pxor %%xmm4, %%xmm6\n\t" /* <xmm6:xmm3> holds the result of the
                                             carry-less multiplication of xmm0
                                             by xmm1 */

                /* shift the result by one bit position to the left cope for
                   the fact that bits are reversed */
                "movdqa %%xmm3, %%xmm4\n\t"
                "movdqa %%xmm6, %%xmm5\n\t"
                "pslld $1, %%xmm3\n\t"
                "pslld $1, %%xmm6\n\t"
                "psrld $31, %%xmm4\n\t"
                "psrld $31, %%xmm5\n\t"
                "movdqa %%xmm4, %%xmm1\n\t"
                "pslldq $4, %%xmm5\n\t"
                "pslldq $4, %%xmm4\n\t"
                "psrldq $12, %%xmm1\n\t"
                "por %%xmm4, %%xmm3\n\t"
                "por %%xmm5, %%xmm6\n\t"
                "por %%xmm6, %%xmm1\n\t"

                /* first phase of the reduction */
                "movdqa %%xmm3, %%xmm6\n\t"
                "movdqa %%xmm3, %%xmm7\n\t"
                "pslld $31, %%xmm6\n\t" /* packed right shifting << 31 */
                "movdqa %%xmm3, %%xmm5\n\t"
                "pslld $30, %%xmm7\n\t" /* packed right shifting shift << 30 */
                "pslld $25, %%xmm5\n\t" /* packed right shifting shift << 25 */
                "pxor %%xmm7, %%xmm6\n\t" /* xor the shifted versions */
                "pxor %%xmm5, %%xmm6\n\t"
                "movdqa %%xmm6, %%xmm7\n\t"
                "pslldq $12, %%xmm6\n\t"
                "psrldq $4, %%xmm7\n\t"
                "pxor %%xmm6, %%xmm3\n\t" /* first phase of the reduction
                                             complete */

                /* second phase of the reduction */
                "movdqa %%xmm3, %%xmm2\n\t"
                "movdqa %%xmm3, %%xmm4\n\t"
                "psrld $1, %%xmm2\n\t" /* packed left shifting >> 1 */
                "movdqa %%xmm3, %%xmm5\n\t"
                "psrld $2, %%xmm4\n\t" /* packed left shifting >> 2 */
                "psrld $7, %%xmm5\n\t" /* packed left shifting >> 7 */
                "pxor %%xmm4, %%xmm2\n\t" /* xor the shifted versions */
                "pxor %%xmm5, %%xmm2\n\t"
                "pxor %%xmm7, %%xmm2\n\t"
                "pxor %%xmm2, %%xmm3\n\t"
                "pxor %%xmm3, %%xmm1\n\t" /* the result is in xmm1 */
                ::: "cc" );
}

# 560 "cipher-gcm.c"
static unsigned int
ghash (gcry_cipher_hd_t c, byte *result, const byte *buf,
       size_t nblocks)
{
  const unsigned int blocksize = (128 / 8);
  unsigned int burn;

  if (nblocks == 0)
    return 0;

  if (0)
    ;

  else if (c->u_mode.gcm.use_intel_pclmul)
    {
      static const unsigned char be_mask[16] =
        { 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };

      /* Preload hash and H1. */
      asm volatile ("movdqu %[hash], %%xmm1\n\t"
                    "movdqa %[hsub], %%xmm0\n\t"
                    "pshufb %[be_mask], %%xmm1\n\t" /* be => le */
                    :
                    : [hash] "m" (*result), [be_mask] "m" (*be_mask),
                      [hsub] "m" (*c->u_mode.gcm.u_ghash_key.key));
# 631 "cipher-gcm.c"
      while (nblocks--)
        {
          asm volatile ("movdqu %[buf], %%xmm2\n\t"
                        "pshufb %[be_mask], %%xmm2\n\t" /* be => le */
                        "pxor %%xmm2, %%xmm1\n\t"
                        :
                        : [buf] "m" (*buf), [be_mask] "m" (*be_mask));

          gfmul_pclmul ();

          buf += blocksize;
        }

      /* Store hash. */
      asm volatile ("pshufb %[be_mask], %%xmm1\n\t" /* be => le */
                    "movdqu %%xmm1, %[hash]\n\t"
                    : [hash] "=m" (*result)
                    : [be_mask] "m" (*be_mask));

      /* Clear used registers. */
      asm volatile( "pxor %%xmm0, %%xmm0\n\t"
                    "pxor %%xmm1, %%xmm1\n\t"
                    "pxor %%xmm2, %%xmm2\n\t"
                    "pxor %%xmm3, %%xmm3\n\t"
                    "pxor %%xmm4, %%xmm4\n\t"
                    "pxor %%xmm5, %%xmm5\n\t"
                    "pxor %%xmm6, %%xmm6\n\t"
                    "pxor %%xmm7, %%xmm7\n\t"
                    ::: "cc" );
      burn = 0;
    }

  else
    {
      while (nblocks)
        {
          burn = do_ghash (result, buf, c->u_mode.gcm.gcm_table);
          buf += blocksize;
          nblocks--;
        }
    }

  return burn + (burn ? 5*sizeof(void*) : 0);
}

# 300 "../src/g10lib.h"
void __gcry_burn_stack (unsigned int bytes);

# 102 "rijndael.c"
typedef struct u128_s { u32 a, b, c, d; } u128_t;

# 107 "rijndael.c"
typedef u32 u32_a_t;

# 142 "rijndael.c"
typedef struct
{
  /* The first fields are the keyschedule arrays.  This is so that
     they are aligned on a 16 byte boundary if using gcc.  This
     alignment is required for the AES-NI code and a good idea in any
     case.  The alignment is guaranteed due to the way cipher.c
     allocates the space for the context.  The PROPERLY_ALIGNED_TYPE
     hack is used to force a minimal alignment if not using gcc of if
     the alignment requirement is higher that 16 bytes.  */
  union
  {
    PROPERLY_ALIGNED_TYPE dummy;
    byte keyschedule[14 +1][4][4];

    /* The key as passed to the padlock engine.  It is only used if
       the padlock engine is used (USE_PADLOCK, below).  */
    unsigned char padlock_key[16] ;

  } u1;
  union
  {
    PROPERLY_ALIGNED_TYPE dummy;
    byte keyschedule[14 +1][4][4];
  } u2;
  int rounds; /* Key-length-dependent number of rounds.  */
  unsigned int decryption_prepared:1; /* The decryption key schedule is available.  */

  unsigned int use_padlock:1; /* Padlock shall be used.  */


  unsigned int use_aesni:1; /* AES-NI shall be used.  */

} RIJNDAEL_context;

# 61 "rijndael-tables.h"
static const unsigned char T1[256][4] =
  {
    { 0xc6,0x63,0x63,0xa5 }, { 0xf8,0x7c,0x7c,0x84 },
    { 0xee,0x77,0x77,0x99 }, { 0xf6,0x7b,0x7b,0x8d },
    { 0xff,0xf2,0xf2,0x0d }, { 0xd6,0x6b,0x6b,0xbd },
    { 0xde,0x6f,0x6f,0xb1 }, { 0x91,0xc5,0xc5,0x54 },
    { 0x60,0x30,0x30,0x50 }, { 0x02,0x01,0x01,0x03 },
    { 0xce,0x67,0x67,0xa9 }, { 0x56,0x2b,0x2b,0x7d },
    { 0xe7,0xfe,0xfe,0x19 }, { 0xb5,0xd7,0xd7,0x62 },
    { 0x4d,0xab,0xab,0xe6 }, { 0xec,0x76,0x76,0x9a },
    { 0x8f,0xca,0xca,0x45 }, { 0x1f,0x82,0x82,0x9d },
    { 0x89,0xc9,0xc9,0x40 }, { 0xfa,0x7d,0x7d,0x87 },
    { 0xef,0xfa,0xfa,0x15 }, { 0xb2,0x59,0x59,0xeb },
    { 0x8e,0x47,0x47,0xc9 }, { 0xfb,0xf0,0xf0,0x0b },
    { 0x41,0xad,0xad,0xec }, { 0xb3,0xd4,0xd4,0x67 },
    { 0x5f,0xa2,0xa2,0xfd }, { 0x45,0xaf,0xaf,0xea },
    { 0x23,0x9c,0x9c,0xbf }, { 0x53,0xa4,0xa4,0xf7 },
    { 0xe4,0x72,0x72,0x96 }, { 0x9b,0xc0,0xc0,0x5b },
    { 0x75,0xb7,0xb7,0xc2 }, { 0xe1,0xfd,0xfd,0x1c },
    { 0x3d,0x93,0x93,0xae }, { 0x4c,0x26,0x26,0x6a },
    { 0x6c,0x36,0x36,0x5a }, { 0x7e,0x3f,0x3f,0x41 },
    { 0xf5,0xf7,0xf7,0x02 }, { 0x83,0xcc,0xcc,0x4f },
    { 0x68,0x34,0x34,0x5c }, { 0x51,0xa5,0xa5,0xf4 },
    { 0xd1,0xe5,0xe5,0x34 }, { 0xf9,0xf1,0xf1,0x08 },
    { 0xe2,0x71,0x71,0x93 }, { 0xab,0xd8,0xd8,0x73 },
    { 0x62,0x31,0x31,0x53 }, { 0x2a,0x15,0x15,0x3f },
    { 0x08,0x04,0x04,0x0c }, { 0x95,0xc7,0xc7,0x52 },
    { 0x46,0x23,0x23,0x65 }, { 0x9d,0xc3,0xc3,0x5e },
    { 0x30,0x18,0x18,0x28 }, { 0x37,0x96,0x96,0xa1 },
    { 0x0a,0x05,0x05,0x0f }, { 0x2f,0x9a,0x9a,0xb5 },
    { 0x0e,0x07,0x07,0x09 }, { 0x24,0x12,0x12,0x36 },
    { 0x1b,0x80,0x80,0x9b }, { 0xdf,0xe2,0xe2,0x3d },
    { 0xcd,0xeb,0xeb,0x26 }, { 0x4e,0x27,0x27,0x69 },
    { 0x7f,0xb2,0xb2,0xcd }, { 0xea,0x75,0x75,0x9f },
    { 0x12,0x09,0x09,0x1b }, { 0x1d,0x83,0x83,0x9e },
    { 0x58,0x2c,0x2c,0x74 }, { 0x34,0x1a,0x1a,0x2e },
    { 0x36,0x1b,0x1b,0x2d }, { 0xdc,0x6e,0x6e,0xb2 },
    { 0xb4,0x5a,0x5a,0xee }, { 0x5b,0xa0,0xa0,0xfb },
    { 0xa4,0x52,0x52,0xf6 }, { 0x76,0x3b,0x3b,0x4d },
    { 0xb7,0xd6,0xd6,0x61 }, { 0x7d,0xb3,0xb3,0xce },
    { 0x52,0x29,0x29,0x7b }, { 0xdd,0xe3,0xe3,0x3e },
    { 0x5e,0x2f,0x2f,0x71 }, { 0x13,0x84,0x84,0x97 },
    { 0xa6,0x53,0x53,0xf5 }, { 0xb9,0xd1,0xd1,0x68 },
    { 0x00,0x00,0x00,0x00 }, { 0xc1,0xed,0xed,0x2c },
    { 0x40,0x20,0x20,0x60 }, { 0xe3,0xfc,0xfc,0x1f },
    { 0x79,0xb1,0xb1,0xc8 }, { 0xb6,0x5b,0x5b,0xed },
    { 0xd4,0x6a,0x6a,0xbe }, { 0x8d,0xcb,0xcb,0x46 },
    { 0x67,0xbe,0xbe,0xd9 }, { 0x72,0x39,0x39,0x4b },
    { 0x94,0x4a,0x4a,0xde }, { 0x98,0x4c,0x4c,0xd4 },
    { 0xb0,0x58,0x58,0xe8 }, { 0x85,0xcf,0xcf,0x4a },
    { 0xbb,0xd0,0xd0,0x6b }, { 0xc5,0xef,0xef,0x2a },
    { 0x4f,0xaa,0xaa,0xe5 }, { 0xed,0xfb,0xfb,0x16 },
    { 0x86,0x43,0x43,0xc5 }, { 0x9a,0x4d,0x4d,0xd7 },
    { 0x66,0x33,0x33,0x55 }, { 0x11,0x85,0x85,0x94 },
    { 0x8a,0x45,0x45,0xcf }, { 0xe9,0xf9,0xf9,0x10 },
    { 0x04,0x02,0x02,0x06 }, { 0xfe,0x7f,0x7f,0x81 },
    { 0xa0,0x50,0x50,0xf0 }, { 0x78,0x3c,0x3c,0x44 },
    { 0x25,0x9f,0x9f,0xba }, { 0x4b,0xa8,0xa8,0xe3 },
    { 0xa2,0x51,0x51,0xf3 }, { 0x5d,0xa3,0xa3,0xfe },
    { 0x80,0x40,0x40,0xc0 }, { 0x05,0x8f,0x8f,0x8a },
    { 0x3f,0x92,0x92,0xad }, { 0x21,0x9d,0x9d,0xbc },
    { 0x70,0x38,0x38,0x48 }, { 0xf1,0xf5,0xf5,0x04 },
    { 0x63,0xbc,0xbc,0xdf }, { 0x77,0xb6,0xb6,0xc1 },
    { 0xaf,0xda,0xda,0x75 }, { 0x42,0x21,0x21,0x63 },
    { 0x20,0x10,0x10,0x30 }, { 0xe5,0xff,0xff,0x1a },
    { 0xfd,0xf3,0xf3,0x0e }, { 0xbf,0xd2,0xd2,0x6d },
    { 0x81,0xcd,0xcd,0x4c }, { 0x18,0x0c,0x0c,0x14 },
    { 0x26,0x13,0x13,0x35 }, { 0xc3,0xec,0xec,0x2f },
    { 0xbe,0x5f,0x5f,0xe1 }, { 0x35,0x97,0x97,0xa2 },
    { 0x88,0x44,0x44,0xcc }, { 0x2e,0x17,0x17,0x39 },
    { 0x93,0xc4,0xc4,0x57 }, { 0x55,0xa7,0xa7,0xf2 },
    { 0xfc,0x7e,0x7e,0x82 }, { 0x7a,0x3d,0x3d,0x47 },
    { 0xc8,0x64,0x64,0xac }, { 0xba,0x5d,0x5d,0xe7 },
    { 0x32,0x19,0x19,0x2b }, { 0xe6,0x73,0x73,0x95 },
    { 0xc0,0x60,0x60,0xa0 }, { 0x19,0x81,0x81,0x98 },
    { 0x9e,0x4f,0x4f,0xd1 }, { 0xa3,0xdc,0xdc,0x7f },
    { 0x44,0x22,0x22,0x66 }, { 0x54,0x2a,0x2a,0x7e },
    { 0x3b,0x90,0x90,0xab }, { 0x0b,0x88,0x88,0x83 },
    { 0x8c,0x46,0x46,0xca }, { 0xc7,0xee,0xee,0x29 },
    { 0x6b,0xb8,0xb8,0xd3 }, { 0x28,0x14,0x14,0x3c },
    { 0xa7,0xde,0xde,0x79 }, { 0xbc,0x5e,0x5e,0xe2 },
    { 0x16,0x0b,0x0b,0x1d }, { 0xad,0xdb,0xdb,0x76 },
    { 0xdb,0xe0,0xe0,0x3b }, { 0x64,0x32,0x32,0x56 },
    { 0x74,0x3a,0x3a,0x4e }, { 0x14,0x0a,0x0a,0x1e },
    { 0x92,0x49,0x49,0xdb }, { 0x0c,0x06,0x06,0x0a },
    { 0x48,0x24,0x24,0x6c }, { 0xb8,0x5c,0x5c,0xe4 },
    { 0x9f,0xc2,0xc2,0x5d }, { 0xbd,0xd3,0xd3,0x6e },
    { 0x43,0xac,0xac,0xef }, { 0xc4,0x62,0x62,0xa6 },
    { 0x39,0x91,0x91,0xa8 }, { 0x31,0x95,0x95,0xa4 },
    { 0xd3,0xe4,0xe4,0x37 }, { 0xf2,0x79,0x79,0x8b },
    { 0xd5,0xe7,0xe7,0x32 }, { 0x8b,0xc8,0xc8,0x43 },
    { 0x6e,0x37,0x37,0x59 }, { 0xda,0x6d,0x6d,0xb7 },
    { 0x01,0x8d,0x8d,0x8c }, { 0xb1,0xd5,0xd5,0x64 },
    { 0x9c,0x4e,0x4e,0xd2 }, { 0x49,0xa9,0xa9,0xe0 },
    { 0xd8,0x6c,0x6c,0xb4 }, { 0xac,0x56,0x56,0xfa },
    { 0xf3,0xf4,0xf4,0x07 }, { 0xcf,0xea,0xea,0x25 },
    { 0xca,0x65,0x65,0xaf }, { 0xf4,0x7a,0x7a,0x8e },
    { 0x47,0xae,0xae,0xe9 }, { 0x10,0x08,0x08,0x18 },
    { 0x6f,0xba,0xba,0xd5 }, { 0xf0,0x78,0x78,0x88 },
    { 0x4a,0x25,0x25,0x6f }, { 0x5c,0x2e,0x2e,0x72 },
    { 0x38,0x1c,0x1c,0x24 }, { 0x57,0xa6,0xa6,0xf1 },
    { 0x73,0xb4,0xb4,0xc7 }, { 0x97,0xc6,0xc6,0x51 },
    { 0xcb,0xe8,0xe8,0x23 }, { 0xa1,0xdd,0xdd,0x7c },
    { 0xe8,0x74,0x74,0x9c }, { 0x3e,0x1f,0x1f,0x21 },
    { 0x96,0x4b,0x4b,0xdd }, { 0x61,0xbd,0xbd,0xdc },
    { 0x0d,0x8b,0x8b,0x86 }, { 0x0f,0x8a,0x8a,0x85 },
    { 0xe0,0x70,0x70,0x90 }, { 0x7c,0x3e,0x3e,0x42 },
    { 0x71,0xb5,0xb5,0xc4 }, { 0xcc,0x66,0x66,0xaa },
    { 0x90,0x48,0x48,0xd8 }, { 0x06,0x03,0x03,0x05 },
    { 0xf7,0xf6,0xf6,0x01 }, { 0x1c,0x0e,0x0e,0x12 },
    { 0xc2,0x61,0x61,0xa3 }, { 0x6a,0x35,0x35,0x5f },
    { 0xae,0x57,0x57,0xf9 }, { 0x69,0xb9,0xb9,0xd0 },
    { 0x17,0x86,0x86,0x91 }, { 0x99,0xc1,0xc1,0x58 },
    { 0x3a,0x1d,0x1d,0x27 }, { 0x27,0x9e,0x9e,0xb9 },
    { 0xd9,0xe1,0xe1,0x38 }, { 0xeb,0xf8,0xf8,0x13 },
    { 0x2b,0x98,0x98,0xb3 }, { 0x22,0x11,0x11,0x33 },
    { 0xd2,0x69,0x69,0xbb }, { 0xa9,0xd9,0xd9,0x70 },
    { 0x07,0x8e,0x8e,0x89 }, { 0x33,0x94,0x94,0xa7 },
    { 0x2d,0x9b,0x9b,0xb6 }, { 0x3c,0x1e,0x1e,0x22 },
    { 0x15,0x87,0x87,0x92 }, { 0xc9,0xe9,0xe9,0x20 },
    { 0x87,0xce,0xce,0x49 }, { 0xaa,0x55,0x55,0xff },
    { 0x50,0x28,0x28,0x78 }, { 0xa5,0xdf,0xdf,0x7a },
    { 0x03,0x8c,0x8c,0x8f }, { 0x59,0xa1,0xa1,0xf8 },
    { 0x09,0x89,0x89,0x80 }, { 0x1a,0x0d,0x0d,0x17 },
    { 0x65,0xbf,0xbf,0xda }, { 0xd7,0xe6,0xe6,0x31 },
    { 0x84,0x42,0x42,0xc6 }, { 0xd0,0x68,0x68,0xb8 },
    { 0x82,0x41,0x41,0xc3 }, { 0x29,0x99,0x99,0xb0 },
    { 0x5a,0x2d,0x2d,0x77 }, { 0x1e,0x0f,0x0f,0x11 },
    { 0x7b,0xb0,0xb0,0xcb }, { 0xa8,0x54,0x54,0xfc },
    { 0x6d,0xbb,0xbb,0xd6 }, { 0x2c,0x16,0x16,0x3a }
  };

# 193 "rijndael-tables.h"
static const unsigned char T2[256][4] =
  {
    { 0xa5,0xc6,0x63,0x63 }, { 0x84,0xf8,0x7c,0x7c },
    { 0x99,0xee,0x77,0x77 }, { 0x8d,0xf6,0x7b,0x7b },
    { 0x0d,0xff,0xf2,0xf2 }, { 0xbd,0xd6,0x6b,0x6b },
    { 0xb1,0xde,0x6f,0x6f }, { 0x54,0x91,0xc5,0xc5 },
    { 0x50,0x60,0x30,0x30 }, { 0x03,0x02,0x01,0x01 },
    { 0xa9,0xce,0x67,0x67 }, { 0x7d,0x56,0x2b,0x2b },
    { 0x19,0xe7,0xfe,0xfe }, { 0x62,0xb5,0xd7,0xd7 },
    { 0xe6,0x4d,0xab,0xab }, { 0x9a,0xec,0x76,0x76 },
    { 0x45,0x8f,0xca,0xca }, { 0x9d,0x1f,0x82,0x82 },
    { 0x40,0x89,0xc9,0xc9 }, { 0x87,0xfa,0x7d,0x7d },
    { 0x15,0xef,0xfa,0xfa }, { 0xeb,0xb2,0x59,0x59 },
    { 0xc9,0x8e,0x47,0x47 }, { 0x0b,0xfb,0xf0,0xf0 },
    { 0xec,0x41,0xad,0xad }, { 0x67,0xb3,0xd4,0xd4 },
    { 0xfd,0x5f,0xa2,0xa2 }, { 0xea,0x45,0xaf,0xaf },
    { 0xbf,0x23,0x9c,0x9c }, { 0xf7,0x53,0xa4,0xa4 },
    { 0x96,0xe4,0x72,0x72 }, { 0x5b,0x9b,0xc0,0xc0 },
    { 0xc2,0x75,0xb7,0xb7 }, { 0x1c,0xe1,0xfd,0xfd },
    { 0xae,0x3d,0x93,0x93 }, { 0x6a,0x4c,0x26,0x26 },
    { 0x5a,0x6c,0x36,0x36 }, { 0x41,0x7e,0x3f,0x3f },
    { 0x02,0xf5,0xf7,0xf7 }, { 0x4f,0x83,0xcc,0xcc },
    { 0x5c,0x68,0x34,0x34 }, { 0xf4,0x51,0xa5,0xa5 },
    { 0x34,0xd1,0xe5,0xe5 }, { 0x08,0xf9,0xf1,0xf1 },
    { 0x93,0xe2,0x71,0x71 }, { 0x73,0xab,0xd8,0xd8 },
    { 0x53,0x62,0x31,0x31 }, { 0x3f,0x2a,0x15,0x15 },
    { 0x0c,0x08,0x04,0x04 }, { 0x52,0x95,0xc7,0xc7 },
    { 0x65,0x46,0x23,0x23 }, { 0x5e,0x9d,0xc3,0xc3 },
    { 0x28,0x30,0x18,0x18 }, { 0xa1,0x37,0x96,0x96 },
    { 0x0f,0x0a,0x05,0x05 }, { 0xb5,0x2f,0x9a,0x9a },
    { 0x09,0x0e,0x07,0x07 }, { 0x36,0x24,0x12,0x12 },
    { 0x9b,0x1b,0x80,0x80 }, { 0x3d,0xdf,0xe2,0xe2 },
    { 0x26,0xcd,0xeb,0xeb }, { 0x69,0x4e,0x27,0x27 },
    { 0xcd,0x7f,0xb2,0xb2 }, { 0x9f,0xea,0x75,0x75 },
    { 0x1b,0x12,0x09,0x09 }, { 0x9e,0x1d,0x83,0x83 },
    { 0x74,0x58,0x2c,0x2c }, { 0x2e,0x34,0x1a,0x1a },
    { 0x2d,0x36,0x1b,0x1b }, { 0xb2,0xdc,0x6e,0x6e },
    { 0xee,0xb4,0x5a,0x5a }, { 0xfb,0x5b,0xa0,0xa0 },
    { 0xf6,0xa4,0x52,0x52 }, { 0x4d,0x76,0x3b,0x3b },
    { 0x61,0xb7,0xd6,0xd6 }, { 0xce,0x7d,0xb3,0xb3 },
    { 0x7b,0x52,0x29,0x29 }, { 0x3e,0xdd,0xe3,0xe3 },
    { 0x71,0x5e,0x2f,0x2f }, { 0x97,0x13,0x84,0x84 },
    { 0xf5,0xa6,0x53,0x53 }, { 0x68,0xb9,0xd1,0xd1 },
    { 0x00,0x00,0x00,0x00 }, { 0x2c,0xc1,0xed,0xed },
    { 0x60,0x40,0x20,0x20 }, { 0x1f,0xe3,0xfc,0xfc },
    { 0xc8,0x79,0xb1,0xb1 }, { 0xed,0xb6,0x5b,0x5b },
    { 0xbe,0xd4,0x6a,0x6a }, { 0x46,0x8d,0xcb,0xcb },
    { 0xd9,0x67,0xbe,0xbe }, { 0x4b,0x72,0x39,0x39 },
    { 0xde,0x94,0x4a,0x4a }, { 0xd4,0x98,0x4c,0x4c },
    { 0xe8,0xb0,0x58,0x58 }, { 0x4a,0x85,0xcf,0xcf },
    { 0x6b,0xbb,0xd0,0xd0 }, { 0x2a,0xc5,0xef,0xef },
    { 0xe5,0x4f,0xaa,0xaa }, { 0x16,0xed,0xfb,0xfb },
    { 0xc5,0x86,0x43,0x43 }, { 0xd7,0x9a,0x4d,0x4d },
    { 0x55,0x66,0x33,0x33 }, { 0x94,0x11,0x85,0x85 },
    { 0xcf,0x8a,0x45,0x45 }, { 0x10,0xe9,0xf9,0xf9 },
    { 0x06,0x04,0x02,0x02 }, { 0x81,0xfe,0x7f,0x7f },
    { 0xf0,0xa0,0x50,0x50 }, { 0x44,0x78,0x3c,0x3c },
    { 0xba,0x25,0x9f,0x9f }, { 0xe3,0x4b,0xa8,0xa8 },
    { 0xf3,0xa2,0x51,0x51 }, { 0xfe,0x5d,0xa3,0xa3 },
    { 0xc0,0x80,0x40,0x40 }, { 0x8a,0x05,0x8f,0x8f },
    { 0xad,0x3f,0x92,0x92 }, { 0xbc,0x21,0x9d,0x9d },
    { 0x48,0x70,0x38,0x38 }, { 0x04,0xf1,0xf5,0xf5 },
    { 0xdf,0x63,0xbc,0xbc }, { 0xc1,0x77,0xb6,0xb6 },
    { 0x75,0xaf,0xda,0xda }, { 0x63,0x42,0x21,0x21 },
    { 0x30,0x20,0x10,0x10 }, { 0x1a,0xe5,0xff,0xff },
    { 0x0e,0xfd,0xf3,0xf3 }, { 0x6d,0xbf,0xd2,0xd2 },
    { 0x4c,0x81,0xcd,0xcd }, { 0x14,0x18,0x0c,0x0c },
    { 0x35,0x26,0x13,0x13 }, { 0x2f,0xc3,0xec,0xec },
    { 0xe1,0xbe,0x5f,0x5f }, { 0xa2,0x35,0x97,0x97 },
    { 0xcc,0x88,0x44,0x44 }, { 0x39,0x2e,0x17,0x17 },
    { 0x57,0x93,0xc4,0xc4 }, { 0xf2,0x55,0xa7,0xa7 },
    { 0x82,0xfc,0x7e,0x7e }, { 0x47,0x7a,0x3d,0x3d },
    { 0xac,0xc8,0x64,0x64 }, { 0xe7,0xba,0x5d,0x5d },
    { 0x2b,0x32,0x19,0x19 }, { 0x95,0xe6,0x73,0x73 },
    { 0xa0,0xc0,0x60,0x60 }, { 0x98,0x19,0x81,0x81 },
    { 0xd1,0x9e,0x4f,0x4f }, { 0x7f,0xa3,0xdc,0xdc },
    { 0x66,0x44,0x22,0x22 }, { 0x7e,0x54,0x2a,0x2a },
    { 0xab,0x3b,0x90,0x90 }, { 0x83,0x0b,0x88,0x88 },
    { 0xca,0x8c,0x46,0x46 }, { 0x29,0xc7,0xee,0xee },
    { 0xd3,0x6b,0xb8,0xb8 }, { 0x3c,0x28,0x14,0x14 },
    { 0x79,0xa7,0xde,0xde }, { 0xe2,0xbc,0x5e,0x5e },
    { 0x1d,0x16,0x0b,0x0b }, { 0x76,0xad,0xdb,0xdb },
    { 0x3b,0xdb,0xe0,0xe0 }, { 0x56,0x64,0x32,0x32 },
    { 0x4e,0x74,0x3a,0x3a }, { 0x1e,0x14,0x0a,0x0a },
    { 0xdb,0x92,0x49,0x49 }, { 0x0a,0x0c,0x06,0x06 },
    { 0x6c,0x48,0x24,0x24 }, { 0xe4,0xb8,0x5c,0x5c },
    { 0x5d,0x9f,0xc2,0xc2 }, { 0x6e,0xbd,0xd3,0xd3 },
    { 0xef,0x43,0xac,0xac }, { 0xa6,0xc4,0x62,0x62 },
    { 0xa8,0x39,0x91,0x91 }, { 0xa4,0x31,0x95,0x95 },
    { 0x37,0xd3,0xe4,0xe4 }, { 0x8b,0xf2,0x79,0x79 },
    { 0x32,0xd5,0xe7,0xe7 }, { 0x43,0x8b,0xc8,0xc8 },
    { 0x59,0x6e,0x37,0x37 }, { 0xb7,0xda,0x6d,0x6d },
    { 0x8c,0x01,0x8d,0x8d }, { 0x64,0xb1,0xd5,0xd5 },
    { 0xd2,0x9c,0x4e,0x4e }, { 0xe0,0x49,0xa9,0xa9 },
    { 0xb4,0xd8,0x6c,0x6c }, { 0xfa,0xac,0x56,0x56 },
    { 0x07,0xf3,0xf4,0xf4 }, { 0x25,0xcf,0xea,0xea },
    { 0xaf,0xca,0x65,0x65 }, { 0x8e,0xf4,0x7a,0x7a },
    { 0xe9,0x47,0xae,0xae }, { 0x18,0x10,0x08,0x08 },
    { 0xd5,0x6f,0xba,0xba }, { 0x88,0xf0,0x78,0x78 },
    { 0x6f,0x4a,0x25,0x25 }, { 0x72,0x5c,0x2e,0x2e },
    { 0x24,0x38,0x1c,0x1c }, { 0xf1,0x57,0xa6,0xa6 },
    { 0xc7,0x73,0xb4,0xb4 }, { 0x51,0x97,0xc6,0xc6 },
    { 0x23,0xcb,0xe8,0xe8 }, { 0x7c,0xa1,0xdd,0xdd },
    { 0x9c,0xe8,0x74,0x74 }, { 0x21,0x3e,0x1f,0x1f },
    { 0xdd,0x96,0x4b,0x4b }, { 0xdc,0x61,0xbd,0xbd },
    { 0x86,0x0d,0x8b,0x8b }, { 0x85,0x0f,0x8a,0x8a },
    { 0x90,0xe0,0x70,0x70 }, { 0x42,0x7c,0x3e,0x3e },
    { 0xc4,0x71,0xb5,0xb5 }, { 0xaa,0xcc,0x66,0x66 },
    { 0xd8,0x90,0x48,0x48 }, { 0x05,0x06,0x03,0x03 },
    { 0x01,0xf7,0xf6,0xf6 }, { 0x12,0x1c,0x0e,0x0e },
    { 0xa3,0xc2,0x61,0x61 }, { 0x5f,0x6a,0x35,0x35 },
    { 0xf9,0xae,0x57,0x57 }, { 0xd0,0x69,0xb9,0xb9 },
    { 0x91,0x17,0x86,0x86 }, { 0x58,0x99,0xc1,0xc1 },
    { 0x27,0x3a,0x1d,0x1d }, { 0xb9,0x27,0x9e,0x9e },
    { 0x38,0xd9,0xe1,0xe1 }, { 0x13,0xeb,0xf8,0xf8 },
    { 0xb3,0x2b,0x98,0x98 }, { 0x33,0x22,0x11,0x11 },
    { 0xbb,0xd2,0x69,0x69 }, { 0x70,0xa9,0xd9,0xd9 },
    { 0x89,0x07,0x8e,0x8e }, { 0xa7,0x33,0x94,0x94 },
    { 0xb6,0x2d,0x9b,0x9b }, { 0x22,0x3c,0x1e,0x1e },
    { 0x92,0x15,0x87,0x87 }, { 0x20,0xc9,0xe9,0xe9 },
    { 0x49,0x87,0xce,0xce }, { 0xff,0xaa,0x55,0x55 },
    { 0x78,0x50,0x28,0x28 }, { 0x7a,0xa5,0xdf,0xdf },
    { 0x8f,0x03,0x8c,0x8c }, { 0xf8,0x59,0xa1,0xa1 },
    { 0x80,0x09,0x89,0x89 }, { 0x17,0x1a,0x0d,0x0d },
    { 0xda,0x65,0xbf,0xbf }, { 0x31,0xd7,0xe6,0xe6 },
    { 0xc6,0x84,0x42,0x42 }, { 0xb8,0xd0,0x68,0x68 },
    { 0xc3,0x82,0x41,0x41 }, { 0xb0,0x29,0x99,0x99 },
    { 0x77,0x5a,0x2d,0x2d }, { 0x11,0x1e,0x0f,0x0f },
    { 0xcb,0x7b,0xb0,0xb0 }, { 0xfc,0xa8,0x54,0x54 },
    { 0xd6,0x6d,0xbb,0xbb }, { 0x3a,0x2c,0x16,0x16 }
  };

# 325 "rijndael-tables.h"
static const unsigned char T3[256][4] =
  {
    { 0x63,0xa5,0xc6,0x63 }, { 0x7c,0x84,0xf8,0x7c },
    { 0x77,0x99,0xee,0x77 }, { 0x7b,0x8d,0xf6,0x7b },
    { 0xf2,0x0d,0xff,0xf2 }, { 0x6b,0xbd,0xd6,0x6b },
    { 0x6f,0xb1,0xde,0x6f }, { 0xc5,0x54,0x91,0xc5 },
    { 0x30,0x50,0x60,0x30 }, { 0x01,0x03,0x02,0x01 },
    { 0x67,0xa9,0xce,0x67 }, { 0x2b,0x7d,0x56,0x2b },
    { 0xfe,0x19,0xe7,0xfe }, { 0xd7,0x62,0xb5,0xd7 },
    { 0xab,0xe6,0x4d,0xab }, { 0x76,0x9a,0xec,0x76 },
    { 0xca,0x45,0x8f,0xca }, { 0x82,0x9d,0x1f,0x82 },
    { 0xc9,0x40,0x89,0xc9 }, { 0x7d,0x87,0xfa,0x7d },
    { 0xfa,0x15,0xef,0xfa }, { 0x59,0xeb,0xb2,0x59 },
    { 0x47,0xc9,0x8e,0x47 }, { 0xf0,0x0b,0xfb,0xf0 },
    { 0xad,0xec,0x41,0xad }, { 0xd4,0x67,0xb3,0xd4 },
    { 0xa2,0xfd,0x5f,0xa2 }, { 0xaf,0xea,0x45,0xaf },
    { 0x9c,0xbf,0x23,0x9c }, { 0xa4,0xf7,0x53,0xa4 },
    { 0x72,0x96,0xe4,0x72 }, { 0xc0,0x5b,0x9b,0xc0 },
    { 0xb7,0xc2,0x75,0xb7 }, { 0xfd,0x1c,0xe1,0xfd },
    { 0x93,0xae,0x3d,0x93 }, { 0x26,0x6a,0x4c,0x26 },
    { 0x36,0x5a,0x6c,0x36 }, { 0x3f,0x41,0x7e,0x3f },
    { 0xf7,0x02,0xf5,0xf7 }, { 0xcc,0x4f,0x83,0xcc },
    { 0x34,0x5c,0x68,0x34 }, { 0xa5,0xf4,0x51,0xa5 },
    { 0xe5,0x34,0xd1,0xe5 }, { 0xf1,0x08,0xf9,0xf1 },
    { 0x71,0x93,0xe2,0x71 }, { 0xd8,0x73,0xab,0xd8 },
    { 0x31,0x53,0x62,0x31 }, { 0x15,0x3f,0x2a,0x15 },
    { 0x04,0x0c,0x08,0x04 }, { 0xc7,0x52,0x95,0xc7 },
    { 0x23,0x65,0x46,0x23 }, { 0xc3,0x5e,0x9d,0xc3 },
    { 0x18,0x28,0x30,0x18 }, { 0x96,0xa1,0x37,0x96 },
    { 0x05,0x0f,0x0a,0x05 }, { 0x9a,0xb5,0x2f,0x9a },
    { 0x07,0x09,0x0e,0x07 }, { 0x12,0x36,0x24,0x12 },
    { 0x80,0x9b,0x1b,0x80 }, { 0xe2,0x3d,0xdf,0xe2 },
    { 0xeb,0x26,0xcd,0xeb }, { 0x27,0x69,0x4e,0x27 },
    { 0xb2,0xcd,0x7f,0xb2 }, { 0x75,0x9f,0xea,0x75 },
    { 0x09,0x1b,0x12,0x09 }, { 0x83,0x9e,0x1d,0x83 },
    { 0x2c,0x74,0x58,0x2c }, { 0x1a,0x2e,0x34,0x1a },
    { 0x1b,0x2d,0x36,0x1b }, { 0x6e,0xb2,0xdc,0x6e },
    { 0x5a,0xee,0xb4,0x5a }, { 0xa0,0xfb,0x5b,0xa0 },
    { 0x52,0xf6,0xa4,0x52 }, { 0x3b,0x4d,0x76,0x3b },
    { 0xd6,0x61,0xb7,0xd6 }, { 0xb3,0xce,0x7d,0xb3 },
    { 0x29,0x7b,0x52,0x29 }, { 0xe3,0x3e,0xdd,0xe3 },
    { 0x2f,0x71,0x5e,0x2f }, { 0x84,0x97,0x13,0x84 },
    { 0x53,0xf5,0xa6,0x53 }, { 0xd1,0x68,0xb9,0xd1 },
    { 0x00,0x00,0x00,0x00 }, { 0xed,0x2c,0xc1,0xed },
    { 0x20,0x60,0x40,0x20 }, { 0xfc,0x1f,0xe3,0xfc },
    { 0xb1,0xc8,0x79,0xb1 }, { 0x5b,0xed,0xb6,0x5b },
    { 0x6a,0xbe,0xd4,0x6a }, { 0xcb,0x46,0x8d,0xcb },
    { 0xbe,0xd9,0x67,0xbe }, { 0x39,0x4b,0x72,0x39 },
    { 0x4a,0xde,0x94,0x4a }, { 0x4c,0xd4,0x98,0x4c },
    { 0x58,0xe8,0xb0,0x58 }, { 0xcf,0x4a,0x85,0xcf },
    { 0xd0,0x6b,0xbb,0xd0 }, { 0xef,0x2a,0xc5,0xef },
    { 0xaa,0xe5,0x4f,0xaa }, { 0xfb,0x16,0xed,0xfb },
    { 0x43,0xc5,0x86,0x43 }, { 0x4d,0xd7,0x9a,0x4d },
    { 0x33,0x55,0x66,0x33 }, { 0x85,0x94,0x11,0x85 },
    { 0x45,0xcf,0x8a,0x45 }, { 0xf9,0x10,0xe9,0xf9 },
    { 0x02,0x06,0x04,0x02 }, { 0x7f,0x81,0xfe,0x7f },
    { 0x50,0xf0,0xa0,0x50 }, { 0x3c,0x44,0x78,0x3c },
    { 0x9f,0xba,0x25,0x9f }, { 0xa8,0xe3,0x4b,0xa8 },
    { 0x51,0xf3,0xa2,0x51 }, { 0xa3,0xfe,0x5d,0xa3 },
    { 0x40,0xc0,0x80,0x40 }, { 0x8f,0x8a,0x05,0x8f },
    { 0x92,0xad,0x3f,0x92 }, { 0x9d,0xbc,0x21,0x9d },
    { 0x38,0x48,0x70,0x38 }, { 0xf5,0x04,0xf1,0xf5 },
    { 0xbc,0xdf,0x63,0xbc }, { 0xb6,0xc1,0x77,0xb6 },
    { 0xda,0x75,0xaf,0xda }, { 0x21,0x63,0x42,0x21 },
    { 0x10,0x30,0x20,0x10 }, { 0xff,0x1a,0xe5,0xff },
    { 0xf3,0x0e,0xfd,0xf3 }, { 0xd2,0x6d,0xbf,0xd2 },
    { 0xcd,0x4c,0x81,0xcd }, { 0x0c,0x14,0x18,0x0c },
    { 0x13,0x35,0x26,0x13 }, { 0xec,0x2f,0xc3,0xec },
    { 0x5f,0xe1,0xbe,0x5f }, { 0x97,0xa2,0x35,0x97 },
    { 0x44,0xcc,0x88,0x44 }, { 0x17,0x39,0x2e,0x17 },
    { 0xc4,0x57,0x93,0xc4 }, { 0xa7,0xf2,0x55,0xa7 },
    { 0x7e,0x82,0xfc,0x7e }, { 0x3d,0x47,0x7a,0x3d },
    { 0x64,0xac,0xc8,0x64 }, { 0x5d,0xe7,0xba,0x5d },
    { 0x19,0x2b,0x32,0x19 }, { 0x73,0x95,0xe6,0x73 },
    { 0x60,0xa0,0xc0,0x60 }, { 0x81,0x98,0x19,0x81 },
    { 0x4f,0xd1,0x9e,0x4f }, { 0xdc,0x7f,0xa3,0xdc },
    { 0x22,0x66,0x44,0x22 }, { 0x2a,0x7e,0x54,0x2a },
    { 0x90,0xab,0x3b,0x90 }, { 0x88,0x83,0x0b,0x88 },
    { 0x46,0xca,0x8c,0x46 }, { 0xee,0x29,0xc7,0xee },
    { 0xb8,0xd3,0x6b,0xb8 }, { 0x14,0x3c,0x28,0x14 },
    { 0xde,0x79,0xa7,0xde }, { 0x5e,0xe2,0xbc,0x5e },
    { 0x0b,0x1d,0x16,0x0b }, { 0xdb,0x76,0xad,0xdb },
    { 0xe0,0x3b,0xdb,0xe0 }, { 0x32,0x56,0x64,0x32 },
    { 0x3a,0x4e,0x74,0x3a }, { 0x0a,0x1e,0x14,0x0a },
    { 0x49,0xdb,0x92,0x49 }, { 0x06,0x0a,0x0c,0x06 },
    { 0x24,0x6c,0x48,0x24 }, { 0x5c,0xe4,0xb8,0x5c },
    { 0xc2,0x5d,0x9f,0xc2 }, { 0xd3,0x6e,0xbd,0xd3 },
    { 0xac,0xef,0x43,0xac }, { 0x62,0xa6,0xc4,0x62 },
    { 0x91,0xa8,0x39,0x91 }, { 0x95,0xa4,0x31,0x95 },
    { 0xe4,0x37,0xd3,0xe4 }, { 0x79,0x8b,0xf2,0x79 },
    { 0xe7,0x32,0xd5,0xe7 }, { 0xc8,0x43,0x8b,0xc8 },
    { 0x37,0x59,0x6e,0x37 }, { 0x6d,0xb7,0xda,0x6d },
    { 0x8d,0x8c,0x01,0x8d }, { 0xd5,0x64,0xb1,0xd5 },
    { 0x4e,0xd2,0x9c,0x4e }, { 0xa9,0xe0,0x49,0xa9 },
    { 0x6c,0xb4,0xd8,0x6c }, { 0x56,0xfa,0xac,0x56 },
    { 0xf4,0x07,0xf3,0xf4 }, { 0xea,0x25,0xcf,0xea },
    { 0x65,0xaf,0xca,0x65 }, { 0x7a,0x8e,0xf4,0x7a },
    { 0xae,0xe9,0x47,0xae }, { 0x08,0x18,0x10,0x08 },
    { 0xba,0xd5,0x6f,0xba }, { 0x78,0x88,0xf0,0x78 },
    { 0x25,0x6f,0x4a,0x25 }, { 0x2e,0x72,0x5c,0x2e },
    { 0x1c,0x24,0x38,0x1c }, { 0xa6,0xf1,0x57,0xa6 },
    { 0xb4,0xc7,0x73,0xb4 }, { 0xc6,0x51,0x97,0xc6 },
    { 0xe8,0x23,0xcb,0xe8 }, { 0xdd,0x7c,0xa1,0xdd },
    { 0x74,0x9c,0xe8,0x74 }, { 0x1f,0x21,0x3e,0x1f },
    { 0x4b,0xdd,0x96,0x4b }, { 0xbd,0xdc,0x61,0xbd },
    { 0x8b,0x86,0x0d,0x8b }, { 0x8a,0x85,0x0f,0x8a },
    { 0x70,0x90,0xe0,0x70 }, { 0x3e,0x42,0x7c,0x3e },
    { 0xb5,0xc4,0x71,0xb5 }, { 0x66,0xaa,0xcc,0x66 },
    { 0x48,0xd8,0x90,0x48 }, { 0x03,0x05,0x06,0x03 },
    { 0xf6,0x01,0xf7,0xf6 }, { 0x0e,0x12,0x1c,0x0e },
    { 0x61,0xa3,0xc2,0x61 }, { 0x35,0x5f,0x6a,0x35 },
    { 0x57,0xf9,0xae,0x57 }, { 0xb9,0xd0,0x69,0xb9 },
    { 0x86,0x91,0x17,0x86 }, { 0xc1,0x58,0x99,0xc1 },
    { 0x1d,0x27,0x3a,0x1d }, { 0x9e,0xb9,0x27,0x9e },
    { 0xe1,0x38,0xd9,0xe1 }, { 0xf8,0x13,0xeb,0xf8 },
    { 0x98,0xb3,0x2b,0x98 }, { 0x11,0x33,0x22,0x11 },
    { 0x69,0xbb,0xd2,0x69 }, { 0xd9,0x70,0xa9,0xd9 },
    { 0x8e,0x89,0x07,0x8e }, { 0x94,0xa7,0x33,0x94 },
    { 0x9b,0xb6,0x2d,0x9b }, { 0x1e,0x22,0x3c,0x1e },
    { 0x87,0x92,0x15,0x87 }, { 0xe9,0x20,0xc9,0xe9 },
    { 0xce,0x49,0x87,0xce }, { 0x55,0xff,0xaa,0x55 },
    { 0x28,0x78,0x50,0x28 }, { 0xdf,0x7a,0xa5,0xdf },
    { 0x8c,0x8f,0x03,0x8c }, { 0xa1,0xf8,0x59,0xa1 },
    { 0x89,0x80,0x09,0x89 }, { 0x0d,0x17,0x1a,0x0d },
    { 0xbf,0xda,0x65,0xbf }, { 0xe6,0x31,0xd7,0xe6 },
    { 0x42,0xc6,0x84,0x42 }, { 0x68,0xb8,0xd0,0x68 },
    { 0x41,0xc3,0x82,0x41 }, { 0x99,0xb0,0x29,0x99 },
    { 0x2d,0x77,0x5a,0x2d }, { 0x0f,0x11,0x1e,0x0f },
    { 0xb0,0xcb,0x7b,0xb0 }, { 0x54,0xfc,0xa8,0x54 },
    { 0xbb,0xd6,0x6d,0xbb }, { 0x16,0x3a,0x2c,0x16 }
  };

# 457 "rijndael-tables.h"
static const unsigned char T4[256][4] =
  {
    { 0x63,0x63,0xa5,0xc6 }, { 0x7c,0x7c,0x84,0xf8 },
    { 0x77,0x77,0x99,0xee }, { 0x7b,0x7b,0x8d,0xf6 },
    { 0xf2,0xf2,0x0d,0xff }, { 0x6b,0x6b,0xbd,0xd6 },
    { 0x6f,0x6f,0xb1,0xde }, { 0xc5,0xc5,0x54,0x91 },
    { 0x30,0x30,0x50,0x60 }, { 0x01,0x01,0x03,0x02 },
    { 0x67,0x67,0xa9,0xce }, { 0x2b,0x2b,0x7d,0x56 },
    { 0xfe,0xfe,0x19,0xe7 }, { 0xd7,0xd7,0x62,0xb5 },
    { 0xab,0xab,0xe6,0x4d }, { 0x76,0x76,0x9a,0xec },
    { 0xca,0xca,0x45,0x8f }, { 0x82,0x82,0x9d,0x1f },
    { 0xc9,0xc9,0x40,0x89 }, { 0x7d,0x7d,0x87,0xfa },
    { 0xfa,0xfa,0x15,0xef }, { 0x59,0x59,0xeb,0xb2 },
    { 0x47,0x47,0xc9,0x8e }, { 0xf0,0xf0,0x0b,0xfb },
    { 0xad,0xad,0xec,0x41 }, { 0xd4,0xd4,0x67,0xb3 },
    { 0xa2,0xa2,0xfd,0x5f }, { 0xaf,0xaf,0xea,0x45 },
    { 0x9c,0x9c,0xbf,0x23 }, { 0xa4,0xa4,0xf7,0x53 },
    { 0x72,0x72,0x96,0xe4 }, { 0xc0,0xc0,0x5b,0x9b },
    { 0xb7,0xb7,0xc2,0x75 }, { 0xfd,0xfd,0x1c,0xe1 },
    { 0x93,0x93,0xae,0x3d }, { 0x26,0x26,0x6a,0x4c },
    { 0x36,0x36,0x5a,0x6c }, { 0x3f,0x3f,0x41,0x7e },
    { 0xf7,0xf7,0x02,0xf5 }, { 0xcc,0xcc,0x4f,0x83 },
    { 0x34,0x34,0x5c,0x68 }, { 0xa5,0xa5,0xf4,0x51 },
    { 0xe5,0xe5,0x34,0xd1 }, { 0xf1,0xf1,0x08,0xf9 },
    { 0x71,0x71,0x93,0xe2 }, { 0xd8,0xd8,0x73,0xab },
    { 0x31,0x31,0x53,0x62 }, { 0x15,0x15,0x3f,0x2a },
    { 0x04,0x04,0x0c,0x08 }, { 0xc7,0xc7,0x52,0x95 },
    { 0x23,0x23,0x65,0x46 }, { 0xc3,0xc3,0x5e,0x9d },
    { 0x18,0x18,0x28,0x30 }, { 0x96,0x96,0xa1,0x37 },
    { 0x05,0x05,0x0f,0x0a }, { 0x9a,0x9a,0xb5,0x2f },
    { 0x07,0x07,0x09,0x0e }, { 0x12,0x12,0x36,0x24 },
    { 0x80,0x80,0x9b,0x1b }, { 0xe2,0xe2,0x3d,0xdf },
    { 0xeb,0xeb,0x26,0xcd }, { 0x27,0x27,0x69,0x4e },
    { 0xb2,0xb2,0xcd,0x7f }, { 0x75,0x75,0x9f,0xea },
    { 0x09,0x09,0x1b,0x12 }, { 0x83,0x83,0x9e,0x1d },
    { 0x2c,0x2c,0x74,0x58 }, { 0x1a,0x1a,0x2e,0x34 },
    { 0x1b,0x1b,0x2d,0x36 }, { 0x6e,0x6e,0xb2,0xdc },
    { 0x5a,0x5a,0xee,0xb4 }, { 0xa0,0xa0,0xfb,0x5b },
    { 0x52,0x52,0xf6,0xa4 }, { 0x3b,0x3b,0x4d,0x76 },
    { 0xd6,0xd6,0x61,0xb7 }, { 0xb3,0xb3,0xce,0x7d },
    { 0x29,0x29,0x7b,0x52 }, { 0xe3,0xe3,0x3e,0xdd },
    { 0x2f,0x2f,0x71,0x5e }, { 0x84,0x84,0x97,0x13 },
    { 0x53,0x53,0xf5,0xa6 }, { 0xd1,0xd1,0x68,0xb9 },
    { 0x00,0x00,0x00,0x00 }, { 0xed,0xed,0x2c,0xc1 },
    { 0x20,0x20,0x60,0x40 }, { 0xfc,0xfc,0x1f,0xe3 },
    { 0xb1,0xb1,0xc8,0x79 }, { 0x5b,0x5b,0xed,0xb6 },
    { 0x6a,0x6a,0xbe,0xd4 }, { 0xcb,0xcb,0x46,0x8d },
    { 0xbe,0xbe,0xd9,0x67 }, { 0x39,0x39,0x4b,0x72 },
    { 0x4a,0x4a,0xde,0x94 }, { 0x4c,0x4c,0xd4,0x98 },
    { 0x58,0x58,0xe8,0xb0 }, { 0xcf,0xcf,0x4a,0x85 },
    { 0xd0,0xd0,0x6b,0xbb }, { 0xef,0xef,0x2a,0xc5 },
    { 0xaa,0xaa,0xe5,0x4f }, { 0xfb,0xfb,0x16,0xed },
    { 0x43,0x43,0xc5,0x86 }, { 0x4d,0x4d,0xd7,0x9a },
    { 0x33,0x33,0x55,0x66 }, { 0x85,0x85,0x94,0x11 },
    { 0x45,0x45,0xcf,0x8a }, { 0xf9,0xf9,0x10,0xe9 },
    { 0x02,0x02,0x06,0x04 }, { 0x7f,0x7f,0x81,0xfe },
    { 0x50,0x50,0xf0,0xa0 }, { 0x3c,0x3c,0x44,0x78 },
    { 0x9f,0x9f,0xba,0x25 }, { 0xa8,0xa8,0xe3,0x4b },
    { 0x51,0x51,0xf3,0xa2 }, { 0xa3,0xa3,0xfe,0x5d },
    { 0x40,0x40,0xc0,0x80 }, { 0x8f,0x8f,0x8a,0x05 },
    { 0x92,0x92,0xad,0x3f }, { 0x9d,0x9d,0xbc,0x21 },
    { 0x38,0x38,0x48,0x70 }, { 0xf5,0xf5,0x04,0xf1 },
    { 0xbc,0xbc,0xdf,0x63 }, { 0xb6,0xb6,0xc1,0x77 },
    { 0xda,0xda,0x75,0xaf }, { 0x21,0x21,0x63,0x42 },
    { 0x10,0x10,0x30,0x20 }, { 0xff,0xff,0x1a,0xe5 },
    { 0xf3,0xf3,0x0e,0xfd }, { 0xd2,0xd2,0x6d,0xbf },
    { 0xcd,0xcd,0x4c,0x81 }, { 0x0c,0x0c,0x14,0x18 },
    { 0x13,0x13,0x35,0x26 }, { 0xec,0xec,0x2f,0xc3 },
    { 0x5f,0x5f,0xe1,0xbe }, { 0x97,0x97,0xa2,0x35 },
    { 0x44,0x44,0xcc,0x88 }, { 0x17,0x17,0x39,0x2e },
    { 0xc4,0xc4,0x57,0x93 }, { 0xa7,0xa7,0xf2,0x55 },
    { 0x7e,0x7e,0x82,0xfc }, { 0x3d,0x3d,0x47,0x7a },
    { 0x64,0x64,0xac,0xc8 }, { 0x5d,0x5d,0xe7,0xba },
    { 0x19,0x19,0x2b,0x32 }, { 0x73,0x73,0x95,0xe6 },
    { 0x60,0x60,0xa0,0xc0 }, { 0x81,0x81,0x98,0x19 },
    { 0x4f,0x4f,0xd1,0x9e }, { 0xdc,0xdc,0x7f,0xa3 },
    { 0x22,0x22,0x66,0x44 }, { 0x2a,0x2a,0x7e,0x54 },
    { 0x90,0x90,0xab,0x3b }, { 0x88,0x88,0x83,0x0b },
    { 0x46,0x46,0xca,0x8c }, { 0xee,0xee,0x29,0xc7 },
    { 0xb8,0xb8,0xd3,0x6b }, { 0x14,0x14,0x3c,0x28 },
    { 0xde,0xde,0x79,0xa7 }, { 0x5e,0x5e,0xe2,0xbc },
    { 0x0b,0x0b,0x1d,0x16 }, { 0xdb,0xdb,0x76,0xad },
    { 0xe0,0xe0,0x3b,0xdb }, { 0x32,0x32,0x56,0x64 },
    { 0x3a,0x3a,0x4e,0x74 }, { 0x0a,0x0a,0x1e,0x14 },
    { 0x49,0x49,0xdb,0x92 }, { 0x06,0x06,0x0a,0x0c },
    { 0x24,0x24,0x6c,0x48 }, { 0x5c,0x5c,0xe4,0xb8 },
    { 0xc2,0xc2,0x5d,0x9f }, { 0xd3,0xd3,0x6e,0xbd },
    { 0xac,0xac,0xef,0x43 }, { 0x62,0x62,0xa6,0xc4 },
    { 0x91,0x91,0xa8,0x39 }, { 0x95,0x95,0xa4,0x31 },
    { 0xe4,0xe4,0x37,0xd3 }, { 0x79,0x79,0x8b,0xf2 },
    { 0xe7,0xe7,0x32,0xd5 }, { 0xc8,0xc8,0x43,0x8b },
    { 0x37,0x37,0x59,0x6e }, { 0x6d,0x6d,0xb7,0xda },
    { 0x8d,0x8d,0x8c,0x01 }, { 0xd5,0xd5,0x64,0xb1 },
    { 0x4e,0x4e,0xd2,0x9c }, { 0xa9,0xa9,0xe0,0x49 },
    { 0x6c,0x6c,0xb4,0xd8 }, { 0x56,0x56,0xfa,0xac },
    { 0xf4,0xf4,0x07,0xf3 }, { 0xea,0xea,0x25,0xcf },
    { 0x65,0x65,0xaf,0xca }, { 0x7a,0x7a,0x8e,0xf4 },
    { 0xae,0xae,0xe9,0x47 }, { 0x08,0x08,0x18,0x10 },
    { 0xba,0xba,0xd5,0x6f }, { 0x78,0x78,0x88,0xf0 },
    { 0x25,0x25,0x6f,0x4a }, { 0x2e,0x2e,0x72,0x5c },
    { 0x1c,0x1c,0x24,0x38 }, { 0xa6,0xa6,0xf1,0x57 },
    { 0xb4,0xb4,0xc7,0x73 }, { 0xc6,0xc6,0x51,0x97 },
    { 0xe8,0xe8,0x23,0xcb }, { 0xdd,0xdd,0x7c,0xa1 },
    { 0x74,0x74,0x9c,0xe8 }, { 0x1f,0x1f,0x21,0x3e },
    { 0x4b,0x4b,0xdd,0x96 }, { 0xbd,0xbd,0xdc,0x61 },
    { 0x8b,0x8b,0x86,0x0d }, { 0x8a,0x8a,0x85,0x0f },
    { 0x70,0x70,0x90,0xe0 }, { 0x3e,0x3e,0x42,0x7c },
    { 0xb5,0xb5,0xc4,0x71 }, { 0x66,0x66,0xaa,0xcc },
    { 0x48,0x48,0xd8,0x90 }, { 0x03,0x03,0x05,0x06 },
    { 0xf6,0xf6,0x01,0xf7 }, { 0x0e,0x0e,0x12,0x1c },
    { 0x61,0x61,0xa3,0xc2 }, { 0x35,0x35,0x5f,0x6a },
    { 0x57,0x57,0xf9,0xae }, { 0xb9,0xb9,0xd0,0x69 },
    { 0x86,0x86,0x91,0x17 }, { 0xc1,0xc1,0x58,0x99 },
    { 0x1d,0x1d,0x27,0x3a }, { 0x9e,0x9e,0xb9,0x27 },
    { 0xe1,0xe1,0x38,0xd9 }, { 0xf8,0xf8,0x13,0xeb },
    { 0x98,0x98,0xb3,0x2b }, { 0x11,0x11,0x33,0x22 },
    { 0x69,0x69,0xbb,0xd2 }, { 0xd9,0xd9,0x70,0xa9 },
    { 0x8e,0x8e,0x89,0x07 }, { 0x94,0x94,0xa7,0x33 },
    { 0x9b,0x9b,0xb6,0x2d }, { 0x1e,0x1e,0x22,0x3c },
    { 0x87,0x87,0x92,0x15 }, { 0xe9,0xe9,0x20,0xc9 },
    { 0xce,0xce,0x49,0x87 }, { 0x55,0x55,0xff,0xaa },
    { 0x28,0x28,0x78,0x50 }, { 0xdf,0xdf,0x7a,0xa5 },
    { 0x8c,0x8c,0x8f,0x03 }, { 0xa1,0xa1,0xf8,0x59 },
    { 0x89,0x89,0x80,0x09 }, { 0x0d,0x0d,0x17,0x1a },
    { 0xbf,0xbf,0xda,0x65 }, { 0xe6,0xe6,0x31,0xd7 },
    { 0x42,0x42,0xc6,0x84 }, { 0x68,0x68,0xb8,0xd0 },
    { 0x41,0x41,0xc3,0x82 }, { 0x99,0x99,0xb0,0x29 },
    { 0x2d,0x2d,0x77,0x5a }, { 0x0f,0x0f,0x11,0x1e },
    { 0xb0,0xb0,0xcb,0x7b }, { 0x54,0x54,0xfc,0xa8 },
    { 0xbb,0xbb,0xd6,0x6d }, { 0x16,0x16,0x3a,0x2c }
  };

# 589 "rijndael-tables.h"
static const unsigned char T5[256][4] =
  {
    { 0x51,0xf4,0xa7,0x50 }, { 0x7e,0x41,0x65,0x53 },
    { 0x1a,0x17,0xa4,0xc3 }, { 0x3a,0x27,0x5e,0x96 },
    { 0x3b,0xab,0x6b,0xcb }, { 0x1f,0x9d,0x45,0xf1 },
    { 0xac,0xfa,0x58,0xab }, { 0x4b,0xe3,0x03,0x93 },
    { 0x20,0x30,0xfa,0x55 }, { 0xad,0x76,0x6d,0xf6 },
    { 0x88,0xcc,0x76,0x91 }, { 0xf5,0x02,0x4c,0x25 },
    { 0x4f,0xe5,0xd7,0xfc }, { 0xc5,0x2a,0xcb,0xd7 },
    { 0x26,0x35,0x44,0x80 }, { 0xb5,0x62,0xa3,0x8f },
    { 0xde,0xb1,0x5a,0x49 }, { 0x25,0xba,0x1b,0x67 },
    { 0x45,0xea,0x0e,0x98 }, { 0x5d,0xfe,0xc0,0xe1 },
    { 0xc3,0x2f,0x75,0x02 }, { 0x81,0x4c,0xf0,0x12 },
    { 0x8d,0x46,0x97,0xa3 }, { 0x6b,0xd3,0xf9,0xc6 },
    { 0x03,0x8f,0x5f,0xe7 }, { 0x15,0x92,0x9c,0x95 },
    { 0xbf,0x6d,0x7a,0xeb }, { 0x95,0x52,0x59,0xda },
    { 0xd4,0xbe,0x83,0x2d }, { 0x58,0x74,0x21,0xd3 },
    { 0x49,0xe0,0x69,0x29 }, { 0x8e,0xc9,0xc8,0x44 },
    { 0x75,0xc2,0x89,0x6a }, { 0xf4,0x8e,0x79,0x78 },
    { 0x99,0x58,0x3e,0x6b }, { 0x27,0xb9,0x71,0xdd },
    { 0xbe,0xe1,0x4f,0xb6 }, { 0xf0,0x88,0xad,0x17 },
    { 0xc9,0x20,0xac,0x66 }, { 0x7d,0xce,0x3a,0xb4 },
    { 0x63,0xdf,0x4a,0x18 }, { 0xe5,0x1a,0x31,0x82 },
    { 0x97,0x51,0x33,0x60 }, { 0x62,0x53,0x7f,0x45 },
    { 0xb1,0x64,0x77,0xe0 }, { 0xbb,0x6b,0xae,0x84 },
    { 0xfe,0x81,0xa0,0x1c }, { 0xf9,0x08,0x2b,0x94 },
    { 0x70,0x48,0x68,0x58 }, { 0x8f,0x45,0xfd,0x19 },
    { 0x94,0xde,0x6c,0x87 }, { 0x52,0x7b,0xf8,0xb7 },
    { 0xab,0x73,0xd3,0x23 }, { 0x72,0x4b,0x02,0xe2 },
    { 0xe3,0x1f,0x8f,0x57 }, { 0x66,0x55,0xab,0x2a },
    { 0xb2,0xeb,0x28,0x07 }, { 0x2f,0xb5,0xc2,0x03 },
    { 0x86,0xc5,0x7b,0x9a }, { 0xd3,0x37,0x08,0xa5 },
    { 0x30,0x28,0x87,0xf2 }, { 0x23,0xbf,0xa5,0xb2 },
    { 0x02,0x03,0x6a,0xba }, { 0xed,0x16,0x82,0x5c },
    { 0x8a,0xcf,0x1c,0x2b }, { 0xa7,0x79,0xb4,0x92 },
    { 0xf3,0x07,0xf2,0xf0 }, { 0x4e,0x69,0xe2,0xa1 },
    { 0x65,0xda,0xf4,0xcd }, { 0x06,0x05,0xbe,0xd5 },
    { 0xd1,0x34,0x62,0x1f }, { 0xc4,0xa6,0xfe,0x8a },
    { 0x34,0x2e,0x53,0x9d }, { 0xa2,0xf3,0x55,0xa0 },
    { 0x05,0x8a,0xe1,0x32 }, { 0xa4,0xf6,0xeb,0x75 },
    { 0x0b,0x83,0xec,0x39 }, { 0x40,0x60,0xef,0xaa },
    { 0x5e,0x71,0x9f,0x06 }, { 0xbd,0x6e,0x10,0x51 },
    { 0x3e,0x21,0x8a,0xf9 }, { 0x96,0xdd,0x06,0x3d },
    { 0xdd,0x3e,0x05,0xae }, { 0x4d,0xe6,0xbd,0x46 },
    { 0x91,0x54,0x8d,0xb5 }, { 0x71,0xc4,0x5d,0x05 },
    { 0x04,0x06,0xd4,0x6f }, { 0x60,0x50,0x15,0xff },
    { 0x19,0x98,0xfb,0x24 }, { 0xd6,0xbd,0xe9,0x97 },
    { 0x89,0x40,0x43,0xcc }, { 0x67,0xd9,0x9e,0x77 },
    { 0xb0,0xe8,0x42,0xbd }, { 0x07,0x89,0x8b,0x88 },
    { 0xe7,0x19,0x5b,0x38 }, { 0x79,0xc8,0xee,0xdb },
    { 0xa1,0x7c,0x0a,0x47 }, { 0x7c,0x42,0x0f,0xe9 },
    { 0xf8,0x84,0x1e,0xc9 }, { 0x00,0x00,0x00,0x00 },
    { 0x09,0x80,0x86,0x83 }, { 0x32,0x2b,0xed,0x48 },
    { 0x1e,0x11,0x70,0xac }, { 0x6c,0x5a,0x72,0x4e },
    { 0xfd,0x0e,0xff,0xfb }, { 0x0f,0x85,0x38,0x56 },
    { 0x3d,0xae,0xd5,0x1e }, { 0x36,0x2d,0x39,0x27 },
    { 0x0a,0x0f,0xd9,0x64 }, { 0x68,0x5c,0xa6,0x21 },
    { 0x9b,0x5b,0x54,0xd1 }, { 0x24,0x36,0x2e,0x3a },
    { 0x0c,0x0a,0x67,0xb1 }, { 0x93,0x57,0xe7,0x0f },
    { 0xb4,0xee,0x96,0xd2 }, { 0x1b,0x9b,0x91,0x9e },
    { 0x80,0xc0,0xc5,0x4f }, { 0x61,0xdc,0x20,0xa2 },
    { 0x5a,0x77,0x4b,0x69 }, { 0x1c,0x12,0x1a,0x16 },
    { 0xe2,0x93,0xba,0x0a }, { 0xc0,0xa0,0x2a,0xe5 },
    { 0x3c,0x22,0xe0,0x43 }, { 0x12,0x1b,0x17,0x1d },
    { 0x0e,0x09,0x0d,0x0b }, { 0xf2,0x8b,0xc7,0xad },
    { 0x2d,0xb6,0xa8,0xb9 }, { 0x14,0x1e,0xa9,0xc8 },
    { 0x57,0xf1,0x19,0x85 }, { 0xaf,0x75,0x07,0x4c },
    { 0xee,0x99,0xdd,0xbb }, { 0xa3,0x7f,0x60,0xfd },
    { 0xf7,0x01,0x26,0x9f }, { 0x5c,0x72,0xf5,0xbc },
    { 0x44,0x66,0x3b,0xc5 }, { 0x5b,0xfb,0x7e,0x34 },
    { 0x8b,0x43,0x29,0x76 }, { 0xcb,0x23,0xc6,0xdc },
    { 0xb6,0xed,0xfc,0x68 }, { 0xb8,0xe4,0xf1,0x63 },
    { 0xd7,0x31,0xdc,0xca }, { 0x42,0x63,0x85,0x10 },
    { 0x13,0x97,0x22,0x40 }, { 0x84,0xc6,0x11,0x20 },
    { 0x85,0x4a,0x24,0x7d }, { 0xd2,0xbb,0x3d,0xf8 },
    { 0xae,0xf9,0x32,0x11 }, { 0xc7,0x29,0xa1,0x6d },
    { 0x1d,0x9e,0x2f,0x4b }, { 0xdc,0xb2,0x30,0xf3 },
    { 0x0d,0x86,0x52,0xec }, { 0x77,0xc1,0xe3,0xd0 },
    { 0x2b,0xb3,0x16,0x6c }, { 0xa9,0x70,0xb9,0x99 },
    { 0x11,0x94,0x48,0xfa }, { 0x47,0xe9,0x64,0x22 },
    { 0xa8,0xfc,0x8c,0xc4 }, { 0xa0,0xf0,0x3f,0x1a },
    { 0x56,0x7d,0x2c,0xd8 }, { 0x22,0x33,0x90,0xef },
    { 0x87,0x49,0x4e,0xc7 }, { 0xd9,0x38,0xd1,0xc1 },
    { 0x8c,0xca,0xa2,0xfe }, { 0x98,0xd4,0x0b,0x36 },
    { 0xa6,0xf5,0x81,0xcf }, { 0xa5,0x7a,0xde,0x28 },
    { 0xda,0xb7,0x8e,0x26 }, { 0x3f,0xad,0xbf,0xa4 },
    { 0x2c,0x3a,0x9d,0xe4 }, { 0x50,0x78,0x92,0x0d },
    { 0x6a,0x5f,0xcc,0x9b }, { 0x54,0x7e,0x46,0x62 },
    { 0xf6,0x8d,0x13,0xc2 }, { 0x90,0xd8,0xb8,0xe8 },
    { 0x2e,0x39,0xf7,0x5e }, { 0x82,0xc3,0xaf,0xf5 },
    { 0x9f,0x5d,0x80,0xbe }, { 0x69,0xd0,0x93,0x7c },
    { 0x6f,0xd5,0x2d,0xa9 }, { 0xcf,0x25,0x12,0xb3 },
    { 0xc8,0xac,0x99,0x3b }, { 0x10,0x18,0x7d,0xa7 },
    { 0xe8,0x9c,0x63,0x6e }, { 0xdb,0x3b,0xbb,0x7b },
    { 0xcd,0x26,0x78,0x09 }, { 0x6e,0x59,0x18,0xf4 },
    { 0xec,0x9a,0xb7,0x01 }, { 0x83,0x4f,0x9a,0xa8 },
    { 0xe6,0x95,0x6e,0x65 }, { 0xaa,0xff,0xe6,0x7e },
    { 0x21,0xbc,0xcf,0x08 }, { 0xef,0x15,0xe8,0xe6 },
    { 0xba,0xe7,0x9b,0xd9 }, { 0x4a,0x6f,0x36,0xce },
    { 0xea,0x9f,0x09,0xd4 }, { 0x29,0xb0,0x7c,0xd6 },
    { 0x31,0xa4,0xb2,0xaf }, { 0x2a,0x3f,0x23,0x31 },
    { 0xc6,0xa5,0x94,0x30 }, { 0x35,0xa2,0x66,0xc0 },
    { 0x74,0x4e,0xbc,0x37 }, { 0xfc,0x82,0xca,0xa6 },
    { 0xe0,0x90,0xd0,0xb0 }, { 0x33,0xa7,0xd8,0x15 },
    { 0xf1,0x04,0x98,0x4a }, { 0x41,0xec,0xda,0xf7 },
    { 0x7f,0xcd,0x50,0x0e }, { 0x17,0x91,0xf6,0x2f },
    { 0x76,0x4d,0xd6,0x8d }, { 0x43,0xef,0xb0,0x4d },
    { 0xcc,0xaa,0x4d,0x54 }, { 0xe4,0x96,0x04,0xdf },
    { 0x9e,0xd1,0xb5,0xe3 }, { 0x4c,0x6a,0x88,0x1b },
    { 0xc1,0x2c,0x1f,0xb8 }, { 0x46,0x65,0x51,0x7f },
    { 0x9d,0x5e,0xea,0x04 }, { 0x01,0x8c,0x35,0x5d },
    { 0xfa,0x87,0x74,0x73 }, { 0xfb,0x0b,0x41,0x2e },
    { 0xb3,0x67,0x1d,0x5a }, { 0x92,0xdb,0xd2,0x52 },
    { 0xe9,0x10,0x56,0x33 }, { 0x6d,0xd6,0x47,0x13 },
    { 0x9a,0xd7,0x61,0x8c }, { 0x37,0xa1,0x0c,0x7a },
    { 0x59,0xf8,0x14,0x8e }, { 0xeb,0x13,0x3c,0x89 },
    { 0xce,0xa9,0x27,0xee }, { 0xb7,0x61,0xc9,0x35 },
    { 0xe1,0x1c,0xe5,0xed }, { 0x7a,0x47,0xb1,0x3c },
    { 0x9c,0xd2,0xdf,0x59 }, { 0x55,0xf2,0x73,0x3f },
    { 0x18,0x14,0xce,0x79 }, { 0x73,0xc7,0x37,0xbf },
    { 0x53,0xf7,0xcd,0xea }, { 0x5f,0xfd,0xaa,0x5b },
    { 0xdf,0x3d,0x6f,0x14 }, { 0x78,0x44,0xdb,0x86 },
    { 0xca,0xaf,0xf3,0x81 }, { 0xb9,0x68,0xc4,0x3e },
    { 0x38,0x24,0x34,0x2c }, { 0xc2,0xa3,0x40,0x5f },
    { 0x16,0x1d,0xc3,0x72 }, { 0xbc,0xe2,0x25,0x0c },
    { 0x28,0x3c,0x49,0x8b }, { 0xff,0x0d,0x95,0x41 },
    { 0x39,0xa8,0x01,0x71 }, { 0x08,0x0c,0xb3,0xde },
    { 0xd8,0xb4,0xe4,0x9c }, { 0x64,0x56,0xc1,0x90 },
    { 0x7b,0xcb,0x84,0x61 }, { 0xd5,0x32,0xb6,0x70 },
    { 0x48,0x6c,0x5c,0x74 }, { 0xd0,0xb8,0x57,0x42 }
  };

# 721 "rijndael-tables.h"
static const unsigned char T6[256][4] =
  {
    { 0x50,0x51,0xf4,0xa7 }, { 0x53,0x7e,0x41,0x65 },
    { 0xc3,0x1a,0x17,0xa4 }, { 0x96,0x3a,0x27,0x5e },
    { 0xcb,0x3b,0xab,0x6b }, { 0xf1,0x1f,0x9d,0x45 },
    { 0xab,0xac,0xfa,0x58 }, { 0x93,0x4b,0xe3,0x03 },
    { 0x55,0x20,0x30,0xfa }, { 0xf6,0xad,0x76,0x6d },
    { 0x91,0x88,0xcc,0x76 }, { 0x25,0xf5,0x02,0x4c },
    { 0xfc,0x4f,0xe5,0xd7 }, { 0xd7,0xc5,0x2a,0xcb },
    { 0x80,0x26,0x35,0x44 }, { 0x8f,0xb5,0x62,0xa3 },
    { 0x49,0xde,0xb1,0x5a }, { 0x67,0x25,0xba,0x1b },
    { 0x98,0x45,0xea,0x0e }, { 0xe1,0x5d,0xfe,0xc0 },
    { 0x02,0xc3,0x2f,0x75 }, { 0x12,0x81,0x4c,0xf0 },
    { 0xa3,0x8d,0x46,0x97 }, { 0xc6,0x6b,0xd3,0xf9 },
    { 0xe7,0x03,0x8f,0x5f }, { 0x95,0x15,0x92,0x9c },
    { 0xeb,0xbf,0x6d,0x7a }, { 0xda,0x95,0x52,0x59 },
    { 0x2d,0xd4,0xbe,0x83 }, { 0xd3,0x58,0x74,0x21 },
    { 0x29,0x49,0xe0,0x69 }, { 0x44,0x8e,0xc9,0xc8 },
    { 0x6a,0x75,0xc2,0x89 }, { 0x78,0xf4,0x8e,0x79 },
    { 0x6b,0x99,0x58,0x3e }, { 0xdd,0x27,0xb9,0x71 },
    { 0xb6,0xbe,0xe1,0x4f }, { 0x17,0xf0,0x88,0xad },
    { 0x66,0xc9,0x20,0xac }, { 0xb4,0x7d,0xce,0x3a },
    { 0x18,0x63,0xdf,0x4a }, { 0x82,0xe5,0x1a,0x31 },
    { 0x60,0x97,0x51,0x33 }, { 0x45,0x62,0x53,0x7f },
    { 0xe0,0xb1,0x64,0x77 }, { 0x84,0xbb,0x6b,0xae },
    { 0x1c,0xfe,0x81,0xa0 }, { 0x94,0xf9,0x08,0x2b },
    { 0x58,0x70,0x48,0x68 }, { 0x19,0x8f,0x45,0xfd },
    { 0x87,0x94,0xde,0x6c }, { 0xb7,0x52,0x7b,0xf8 },
    { 0x23,0xab,0x73,0xd3 }, { 0xe2,0x72,0x4b,0x02 },
    { 0x57,0xe3,0x1f,0x8f }, { 0x2a,0x66,0x55,0xab },
    { 0x07,0xb2,0xeb,0x28 }, { 0x03,0x2f,0xb5,0xc2 },
    { 0x9a,0x86,0xc5,0x7b }, { 0xa5,0xd3,0x37,0x08 },
    { 0xf2,0x30,0x28,0x87 }, { 0xb2,0x23,0xbf,0xa5 },
    { 0xba,0x02,0x03,0x6a }, { 0x5c,0xed,0x16,0x82 },
    { 0x2b,0x8a,0xcf,0x1c }, { 0x92,0xa7,0x79,0xb4 },
    { 0xf0,0xf3,0x07,0xf2 }, { 0xa1,0x4e,0x69,0xe2 },
    { 0xcd,0x65,0xda,0xf4 }, { 0xd5,0x06,0x05,0xbe },
    { 0x1f,0xd1,0x34,0x62 }, { 0x8a,0xc4,0xa6,0xfe },
    { 0x9d,0x34,0x2e,0x53 }, { 0xa0,0xa2,0xf3,0x55 },
    { 0x32,0x05,0x8a,0xe1 }, { 0x75,0xa4,0xf6,0xeb },
    { 0x39,0x0b,0x83,0xec }, { 0xaa,0x40,0x60,0xef },
    { 0x06,0x5e,0x71,0x9f }, { 0x51,0xbd,0x6e,0x10 },
    { 0xf9,0x3e,0x21,0x8a }, { 0x3d,0x96,0xdd,0x06 },
    { 0xae,0xdd,0x3e,0x05 }, { 0x46,0x4d,0xe6,0xbd },
    { 0xb5,0x91,0x54,0x8d }, { 0x05,0x71,0xc4,0x5d },
    { 0x6f,0x04,0x06,0xd4 }, { 0xff,0x60,0x50,0x15 },
    { 0x24,0x19,0x98,0xfb }, { 0x97,0xd6,0xbd,0xe9 },
    { 0xcc,0x89,0x40,0x43 }, { 0x77,0x67,0xd9,0x9e },
    { 0xbd,0xb0,0xe8,0x42 }, { 0x88,0x07,0x89,0x8b },
    { 0x38,0xe7,0x19,0x5b }, { 0xdb,0x79,0xc8,0xee },
    { 0x47,0xa1,0x7c,0x0a }, { 0xe9,0x7c,0x42,0x0f },
    { 0xc9,0xf8,0x84,0x1e }, { 0x00,0x00,0x00,0x00 },
    { 0x83,0x09,0x80,0x86 }, { 0x48,0x32,0x2b,0xed },
    { 0xac,0x1e,0x11,0x70 }, { 0x4e,0x6c,0x5a,0x72 },
    { 0xfb,0xfd,0x0e,0xff }, { 0x56,0x0f,0x85,0x38 },
    { 0x1e,0x3d,0xae,0xd5 }, { 0x27,0x36,0x2d,0x39 },
    { 0x64,0x0a,0x0f,0xd9 }, { 0x21,0x68,0x5c,0xa6 },
    { 0xd1,0x9b,0x5b,0x54 }, { 0x3a,0x24,0x36,0x2e },
    { 0xb1,0x0c,0x0a,0x67 }, { 0x0f,0x93,0x57,0xe7 },
    { 0xd2,0xb4,0xee,0x96 }, { 0x9e,0x1b,0x9b,0x91 },
    { 0x4f,0x80,0xc0,0xc5 }, { 0xa2,0x61,0xdc,0x20 },
    { 0x69,0x5a,0x77,0x4b }, { 0x16,0x1c,0x12,0x1a },
    { 0x0a,0xe2,0x93,0xba }, { 0xe5,0xc0,0xa0,0x2a },
    { 0x43,0x3c,0x22,0xe0 }, { 0x1d,0x12,0x1b,0x17 },
    { 0x0b,0x0e,0x09,0x0d }, { 0xad,0xf2,0x8b,0xc7 },
    { 0xb9,0x2d,0xb6,0xa8 }, { 0xc8,0x14,0x1e,0xa9 },
    { 0x85,0x57,0xf1,0x19 }, { 0x4c,0xaf,0x75,0x07 },
    { 0xbb,0xee,0x99,0xdd }, { 0xfd,0xa3,0x7f,0x60 },
    { 0x9f,0xf7,0x01,0x26 }, { 0xbc,0x5c,0x72,0xf5 },
    { 0xc5,0x44,0x66,0x3b }, { 0x34,0x5b,0xfb,0x7e },
    { 0x76,0x8b,0x43,0x29 }, { 0xdc,0xcb,0x23,0xc6 },
    { 0x68,0xb6,0xed,0xfc }, { 0x63,0xb8,0xe4,0xf1 },
    { 0xca,0xd7,0x31,0xdc }, { 0x10,0x42,0x63,0x85 },
    { 0x40,0x13,0x97,0x22 }, { 0x20,0x84,0xc6,0x11 },
    { 0x7d,0x85,0x4a,0x24 }, { 0xf8,0xd2,0xbb,0x3d },
    { 0x11,0xae,0xf9,0x32 }, { 0x6d,0xc7,0x29,0xa1 },
    { 0x4b,0x1d,0x9e,0x2f }, { 0xf3,0xdc,0xb2,0x30 },
    { 0xec,0x0d,0x86,0x52 }, { 0xd0,0x77,0xc1,0xe3 },
    { 0x6c,0x2b,0xb3,0x16 }, { 0x99,0xa9,0x70,0xb9 },
    { 0xfa,0x11,0x94,0x48 }, { 0x22,0x47,0xe9,0x64 },
    { 0xc4,0xa8,0xfc,0x8c }, { 0x1a,0xa0,0xf0,0x3f },
    { 0xd8,0x56,0x7d,0x2c }, { 0xef,0x22,0x33,0x90 },
    { 0xc7,0x87,0x49,0x4e }, { 0xc1,0xd9,0x38,0xd1 },
    { 0xfe,0x8c,0xca,0xa2 }, { 0x36,0x98,0xd4,0x0b },
    { 0xcf,0xa6,0xf5,0x81 }, { 0x28,0xa5,0x7a,0xde },
    { 0x26,0xda,0xb7,0x8e }, { 0xa4,0x3f,0xad,0xbf },
    { 0xe4,0x2c,0x3a,0x9d }, { 0x0d,0x50,0x78,0x92 },
    { 0x9b,0x6a,0x5f,0xcc }, { 0x62,0x54,0x7e,0x46 },
    { 0xc2,0xf6,0x8d,0x13 }, { 0xe8,0x90,0xd8,0xb8 },
    { 0x5e,0x2e,0x39,0xf7 }, { 0xf5,0x82,0xc3,0xaf },
    { 0xbe,0x9f,0x5d,0x80 }, { 0x7c,0x69,0xd0,0x93 },
    { 0xa9,0x6f,0xd5,0x2d }, { 0xb3,0xcf,0x25,0x12 },
    { 0x3b,0xc8,0xac,0x99 }, { 0xa7,0x10,0x18,0x7d },
    { 0x6e,0xe8,0x9c,0x63 }, { 0x7b,0xdb,0x3b,0xbb },
    { 0x09,0xcd,0x26,0x78 }, { 0xf4,0x6e,0x59,0x18 },
    { 0x01,0xec,0x9a,0xb7 }, { 0xa8,0x83,0x4f,0x9a },
    { 0x65,0xe6,0x95,0x6e }, { 0x7e,0xaa,0xff,0xe6 },
    { 0x08,0x21,0xbc,0xcf }, { 0xe6,0xef,0x15,0xe8 },
    { 0xd9,0xba,0xe7,0x9b }, { 0xce,0x4a,0x6f,0x36 },
    { 0xd4,0xea,0x9f,0x09 }, { 0xd6,0x29,0xb0,0x7c },
    { 0xaf,0x31,0xa4,0xb2 }, { 0x31,0x2a,0x3f,0x23 },
    { 0x30,0xc6,0xa5,0x94 }, { 0xc0,0x35,0xa2,0x66 },
    { 0x37,0x74,0x4e,0xbc }, { 0xa6,0xfc,0x82,0xca },
    { 0xb0,0xe0,0x90,0xd0 }, { 0x15,0x33,0xa7,0xd8 },
    { 0x4a,0xf1,0x04,0x98 }, { 0xf7,0x41,0xec,0xda },
    { 0x0e,0x7f,0xcd,0x50 }, { 0x2f,0x17,0x91,0xf6 },
    { 0x8d,0x76,0x4d,0xd6 }, { 0x4d,0x43,0xef,0xb0 },
    { 0x54,0xcc,0xaa,0x4d }, { 0xdf,0xe4,0x96,0x04 },
    { 0xe3,0x9e,0xd1,0xb5 }, { 0x1b,0x4c,0x6a,0x88 },
    { 0xb8,0xc1,0x2c,0x1f }, { 0x7f,0x46,0x65,0x51 },
    { 0x04,0x9d,0x5e,0xea }, { 0x5d,0x01,0x8c,0x35 },
    { 0x73,0xfa,0x87,0x74 }, { 0x2e,0xfb,0x0b,0x41 },
    { 0x5a,0xb3,0x67,0x1d }, { 0x52,0x92,0xdb,0xd2 },
    { 0x33,0xe9,0x10,0x56 }, { 0x13,0x6d,0xd6,0x47 },
    { 0x8c,0x9a,0xd7,0x61 }, { 0x7a,0x37,0xa1,0x0c },
    { 0x8e,0x59,0xf8,0x14 }, { 0x89,0xeb,0x13,0x3c },
    { 0xee,0xce,0xa9,0x27 }, { 0x35,0xb7,0x61,0xc9 },
    { 0xed,0xe1,0x1c,0xe5 }, { 0x3c,0x7a,0x47,0xb1 },
    { 0x59,0x9c,0xd2,0xdf }, { 0x3f,0x55,0xf2,0x73 },
    { 0x79,0x18,0x14,0xce }, { 0xbf,0x73,0xc7,0x37 },
    { 0xea,0x53,0xf7,0xcd }, { 0x5b,0x5f,0xfd,0xaa },
    { 0x14,0xdf,0x3d,0x6f }, { 0x86,0x78,0x44,0xdb },
    { 0x81,0xca,0xaf,0xf3 }, { 0x3e,0xb9,0x68,0xc4 },
    { 0x2c,0x38,0x24,0x34 }, { 0x5f,0xc2,0xa3,0x40 },
    { 0x72,0x16,0x1d,0xc3 }, { 0x0c,0xbc,0xe2,0x25 },
    { 0x8b,0x28,0x3c,0x49 }, { 0x41,0xff,0x0d,0x95 },
    { 0x71,0x39,0xa8,0x01 }, { 0xde,0x08,0x0c,0xb3 },
    { 0x9c,0xd8,0xb4,0xe4 }, { 0x90,0x64,0x56,0xc1 },
    { 0x61,0x7b,0xcb,0x84 }, { 0x70,0xd5,0x32,0xb6 },
    { 0x74,0x48,0x6c,0x5c }, { 0x42,0xd0,0xb8,0x57 }
  };

# 853 "rijndael-tables.h"
static const unsigned char T7[256][4] =
  {
    { 0xa7,0x50,0x51,0xf4 }, { 0x65,0x53,0x7e,0x41 },
    { 0xa4,0xc3,0x1a,0x17 }, { 0x5e,0x96,0x3a,0x27 },
    { 0x6b,0xcb,0x3b,0xab }, { 0x45,0xf1,0x1f,0x9d },
    { 0x58,0xab,0xac,0xfa }, { 0x03,0x93,0x4b,0xe3 },
    { 0xfa,0x55,0x20,0x30 }, { 0x6d,0xf6,0xad,0x76 },
    { 0x76,0x91,0x88,0xcc }, { 0x4c,0x25,0xf5,0x02 },
    { 0xd7,0xfc,0x4f,0xe5 }, { 0xcb,0xd7,0xc5,0x2a },
    { 0x44,0x80,0x26,0x35 }, { 0xa3,0x8f,0xb5,0x62 },
    { 0x5a,0x49,0xde,0xb1 }, { 0x1b,0x67,0x25,0xba },
    { 0x0e,0x98,0x45,0xea }, { 0xc0,0xe1,0x5d,0xfe },
    { 0x75,0x02,0xc3,0x2f }, { 0xf0,0x12,0x81,0x4c },
    { 0x97,0xa3,0x8d,0x46 }, { 0xf9,0xc6,0x6b,0xd3 },
    { 0x5f,0xe7,0x03,0x8f }, { 0x9c,0x95,0x15,0x92 },
    { 0x7a,0xeb,0xbf,0x6d }, { 0x59,0xda,0x95,0x52 },
    { 0x83,0x2d,0xd4,0xbe }, { 0x21,0xd3,0x58,0x74 },
    { 0x69,0x29,0x49,0xe0 }, { 0xc8,0x44,0x8e,0xc9 },
    { 0x89,0x6a,0x75,0xc2 }, { 0x79,0x78,0xf4,0x8e },
    { 0x3e,0x6b,0x99,0x58 }, { 0x71,0xdd,0x27,0xb9 },
    { 0x4f,0xb6,0xbe,0xe1 }, { 0xad,0x17,0xf0,0x88 },
    { 0xac,0x66,0xc9,0x20 }, { 0x3a,0xb4,0x7d,0xce },
    { 0x4a,0x18,0x63,0xdf }, { 0x31,0x82,0xe5,0x1a },
    { 0x33,0x60,0x97,0x51 }, { 0x7f,0x45,0x62,0x53 },
    { 0x77,0xe0,0xb1,0x64 }, { 0xae,0x84,0xbb,0x6b },
    { 0xa0,0x1c,0xfe,0x81 }, { 0x2b,0x94,0xf9,0x08 },
    { 0x68,0x58,0x70,0x48 }, { 0xfd,0x19,0x8f,0x45 },
    { 0x6c,0x87,0x94,0xde }, { 0xf8,0xb7,0x52,0x7b },
    { 0xd3,0x23,0xab,0x73 }, { 0x02,0xe2,0x72,0x4b },
    { 0x8f,0x57,0xe3,0x1f }, { 0xab,0x2a,0x66,0x55 },
    { 0x28,0x07,0xb2,0xeb }, { 0xc2,0x03,0x2f,0xb5 },
    { 0x7b,0x9a,0x86,0xc5 }, { 0x08,0xa5,0xd3,0x37 },
    { 0x87,0xf2,0x30,0x28 }, { 0xa5,0xb2,0x23,0xbf },
    { 0x6a,0xba,0x02,0x03 }, { 0x82,0x5c,0xed,0x16 },
    { 0x1c,0x2b,0x8a,0xcf }, { 0xb4,0x92,0xa7,0x79 },
    { 0xf2,0xf0,0xf3,0x07 }, { 0xe2,0xa1,0x4e,0x69 },
    { 0xf4,0xcd,0x65,0xda }, { 0xbe,0xd5,0x06,0x05 },
    { 0x62,0x1f,0xd1,0x34 }, { 0xfe,0x8a,0xc4,0xa6 },
    { 0x53,0x9d,0x34,0x2e }, { 0x55,0xa0,0xa2,0xf3 },
    { 0xe1,0x32,0x05,0x8a }, { 0xeb,0x75,0xa4,0xf6 },
    { 0xec,0x39,0x0b,0x83 }, { 0xef,0xaa,0x40,0x60 },
    { 0x9f,0x06,0x5e,0x71 }, { 0x10,0x51,0xbd,0x6e },
    { 0x8a,0xf9,0x3e,0x21 }, { 0x06,0x3d,0x96,0xdd },
    { 0x05,0xae,0xdd,0x3e }, { 0xbd,0x46,0x4d,0xe6 },
    { 0x8d,0xb5,0x91,0x54 }, { 0x5d,0x05,0x71,0xc4 },
    { 0xd4,0x6f,0x04,0x06 }, { 0x15,0xff,0x60,0x50 },
    { 0xfb,0x24,0x19,0x98 }, { 0xe9,0x97,0xd6,0xbd },
    { 0x43,0xcc,0x89,0x40 }, { 0x9e,0x77,0x67,0xd9 },
    { 0x42,0xbd,0xb0,0xe8 }, { 0x8b,0x88,0x07,0x89 },
    { 0x5b,0x38,0xe7,0x19 }, { 0xee,0xdb,0x79,0xc8 },
    { 0x0a,0x47,0xa1,0x7c }, { 0x0f,0xe9,0x7c,0x42 },
    { 0x1e,0xc9,0xf8,0x84 }, { 0x00,0x00,0x00,0x00 },
    { 0x86,0x83,0x09,0x80 }, { 0xed,0x48,0x32,0x2b },
    { 0x70,0xac,0x1e,0x11 }, { 0x72,0x4e,0x6c,0x5a },
    { 0xff,0xfb,0xfd,0x0e }, { 0x38,0x56,0x0f,0x85 },
    { 0xd5,0x1e,0x3d,0xae }, { 0x39,0x27,0x36,0x2d },
    { 0xd9,0x64,0x0a,0x0f }, { 0xa6,0x21,0x68,0x5c },
    { 0x54,0xd1,0x9b,0x5b }, { 0x2e,0x3a,0x24,0x36 },
    { 0x67,0xb1,0x0c,0x0a }, { 0xe7,0x0f,0x93,0x57 },
    { 0x96,0xd2,0xb4,0xee }, { 0x91,0x9e,0x1b,0x9b },
    { 0xc5,0x4f,0x80,0xc0 }, { 0x20,0xa2,0x61,0xdc },
    { 0x4b,0x69,0x5a,0x77 }, { 0x1a,0x16,0x1c,0x12 },
    { 0xba,0x0a,0xe2,0x93 }, { 0x2a,0xe5,0xc0,0xa0 },
    { 0xe0,0x43,0x3c,0x22 }, { 0x17,0x1d,0x12,0x1b },
    { 0x0d,0x0b,0x0e,0x09 }, { 0xc7,0xad,0xf2,0x8b },
    { 0xa8,0xb9,0x2d,0xb6 }, { 0xa9,0xc8,0x14,0x1e },
    { 0x19,0x85,0x57,0xf1 }, { 0x07,0x4c,0xaf,0x75 },
    { 0xdd,0xbb,0xee,0x99 }, { 0x60,0xfd,0xa3,0x7f },
    { 0x26,0x9f,0xf7,0x01 }, { 0xf5,0xbc,0x5c,0x72 },
    { 0x3b,0xc5,0x44,0x66 }, { 0x7e,0x34,0x5b,0xfb },
    { 0x29,0x76,0x8b,0x43 }, { 0xc6,0xdc,0xcb,0x23 },
    { 0xfc,0x68,0xb6,0xed }, { 0xf1,0x63,0xb8,0xe4 },
    { 0xdc,0xca,0xd7,0x31 }, { 0x85,0x10,0x42,0x63 },
    { 0x22,0x40,0x13,0x97 }, { 0x11,0x20,0x84,0xc6 },
    { 0x24,0x7d,0x85,0x4a }, { 0x3d,0xf8,0xd2,0xbb },
    { 0x32,0x11,0xae,0xf9 }, { 0xa1,0x6d,0xc7,0x29 },
    { 0x2f,0x4b,0x1d,0x9e }, { 0x30,0xf3,0xdc,0xb2 },
    { 0x52,0xec,0x0d,0x86 }, { 0xe3,0xd0,0x77,0xc1 },
    { 0x16,0x6c,0x2b,0xb3 }, { 0xb9,0x99,0xa9,0x70 },
    { 0x48,0xfa,0x11,0x94 }, { 0x64,0x22,0x47,0xe9 },
    { 0x8c,0xc4,0xa8,0xfc }, { 0x3f,0x1a,0xa0,0xf0 },
    { 0x2c,0xd8,0x56,0x7d }, { 0x90,0xef,0x22,0x33 },
    { 0x4e,0xc7,0x87,0x49 }, { 0xd1,0xc1,0xd9,0x38 },
    { 0xa2,0xfe,0x8c,0xca }, { 0x0b,0x36,0x98,0xd4 },
    { 0x81,0xcf,0xa6,0xf5 }, { 0xde,0x28,0xa5,0x7a },
    { 0x8e,0x26,0xda,0xb7 }, { 0xbf,0xa4,0x3f,0xad },
    { 0x9d,0xe4,0x2c,0x3a }, { 0x92,0x0d,0x50,0x78 },
    { 0xcc,0x9b,0x6a,0x5f }, { 0x46,0x62,0x54,0x7e },
    { 0x13,0xc2,0xf6,0x8d }, { 0xb8,0xe8,0x90,0xd8 },
    { 0xf7,0x5e,0x2e,0x39 }, { 0xaf,0xf5,0x82,0xc3 },
    { 0x80,0xbe,0x9f,0x5d }, { 0x93,0x7c,0x69,0xd0 },
    { 0x2d,0xa9,0x6f,0xd5 }, { 0x12,0xb3,0xcf,0x25 },
    { 0x99,0x3b,0xc8,0xac }, { 0x7d,0xa7,0x10,0x18 },
    { 0x63,0x6e,0xe8,0x9c }, { 0xbb,0x7b,0xdb,0x3b },
    { 0x78,0x09,0xcd,0x26 }, { 0x18,0xf4,0x6e,0x59 },
    { 0xb7,0x01,0xec,0x9a }, { 0x9a,0xa8,0x83,0x4f },
    { 0x6e,0x65,0xe6,0x95 }, { 0xe6,0x7e,0xaa,0xff },
    { 0xcf,0x08,0x21,0xbc }, { 0xe8,0xe6,0xef,0x15 },
    { 0x9b,0xd9,0xba,0xe7 }, { 0x36,0xce,0x4a,0x6f },
    { 0x09,0xd4,0xea,0x9f }, { 0x7c,0xd6,0x29,0xb0 },
    { 0xb2,0xaf,0x31,0xa4 }, { 0x23,0x31,0x2a,0x3f },
    { 0x94,0x30,0xc6,0xa5 }, { 0x66,0xc0,0x35,0xa2 },
    { 0xbc,0x37,0x74,0x4e }, { 0xca,0xa6,0xfc,0x82 },
    { 0xd0,0xb0,0xe0,0x90 }, { 0xd8,0x15,0x33,0xa7 },
    { 0x98,0x4a,0xf1,0x04 }, { 0xda,0xf7,0x41,0xec },
    { 0x50,0x0e,0x7f,0xcd }, { 0xf6,0x2f,0x17,0x91 },
    { 0xd6,0x8d,0x76,0x4d }, { 0xb0,0x4d,0x43,0xef },
    { 0x4d,0x54,0xcc,0xaa }, { 0x04,0xdf,0xe4,0x96 },
    { 0xb5,0xe3,0x9e,0xd1 }, { 0x88,0x1b,0x4c,0x6a },
    { 0x1f,0xb8,0xc1,0x2c }, { 0x51,0x7f,0x46,0x65 },
    { 0xea,0x04,0x9d,0x5e }, { 0x35,0x5d,0x01,0x8c },
    { 0x74,0x73,0xfa,0x87 }, { 0x41,0x2e,0xfb,0x0b },
    { 0x1d,0x5a,0xb3,0x67 }, { 0xd2,0x52,0x92,0xdb },
    { 0x56,0x33,0xe9,0x10 }, { 0x47,0x13,0x6d,0xd6 },
    { 0x61,0x8c,0x9a,0xd7 }, { 0x0c,0x7a,0x37,0xa1 },
    { 0x14,0x8e,0x59,0xf8 }, { 0x3c,0x89,0xeb,0x13 },
    { 0x27,0xee,0xce,0xa9 }, { 0xc9,0x35,0xb7,0x61 },
    { 0xe5,0xed,0xe1,0x1c }, { 0xb1,0x3c,0x7a,0x47 },
    { 0xdf,0x59,0x9c,0xd2 }, { 0x73,0x3f,0x55,0xf2 },
    { 0xce,0x79,0x18,0x14 }, { 0x37,0xbf,0x73,0xc7 },
    { 0xcd,0xea,0x53,0xf7 }, { 0xaa,0x5b,0x5f,0xfd },
    { 0x6f,0x14,0xdf,0x3d }, { 0xdb,0x86,0x78,0x44 },
    { 0xf3,0x81,0xca,0xaf }, { 0xc4,0x3e,0xb9,0x68 },
    { 0x34,0x2c,0x38,0x24 }, { 0x40,0x5f,0xc2,0xa3 },
    { 0xc3,0x72,0x16,0x1d }, { 0x25,0x0c,0xbc,0xe2 },
    { 0x49,0x8b,0x28,0x3c }, { 0x95,0x41,0xff,0x0d },
    { 0x01,0x71,0x39,0xa8 }, { 0xb3,0xde,0x08,0x0c },
    { 0xe4,0x9c,0xd8,0xb4 }, { 0xc1,0x90,0x64,0x56 },
    { 0x84,0x61,0x7b,0xcb }, { 0xb6,0x70,0xd5,0x32 },
    { 0x5c,0x74,0x48,0x6c }, { 0x57,0x42,0xd0,0xb8 }
  };

# 985 "rijndael-tables.h"
static const unsigned char T8[256][4] =
  {
    { 0xf4,0xa7,0x50,0x51 }, { 0x41,0x65,0x53,0x7e },
    { 0x17,0xa4,0xc3,0x1a }, { 0x27,0x5e,0x96,0x3a },
    { 0xab,0x6b,0xcb,0x3b }, { 0x9d,0x45,0xf1,0x1f },
    { 0xfa,0x58,0xab,0xac }, { 0xe3,0x03,0x93,0x4b },
    { 0x30,0xfa,0x55,0x20 }, { 0x76,0x6d,0xf6,0xad },
    { 0xcc,0x76,0x91,0x88 }, { 0x02,0x4c,0x25,0xf5 },
    { 0xe5,0xd7,0xfc,0x4f }, { 0x2a,0xcb,0xd7,0xc5 },
    { 0x35,0x44,0x80,0x26 }, { 0x62,0xa3,0x8f,0xb5 },
    { 0xb1,0x5a,0x49,0xde }, { 0xba,0x1b,0x67,0x25 },
    { 0xea,0x0e,0x98,0x45 }, { 0xfe,0xc0,0xe1,0x5d },
    { 0x2f,0x75,0x02,0xc3 }, { 0x4c,0xf0,0x12,0x81 },
    { 0x46,0x97,0xa3,0x8d }, { 0xd3,0xf9,0xc6,0x6b },
    { 0x8f,0x5f,0xe7,0x03 }, { 0x92,0x9c,0x95,0x15 },
    { 0x6d,0x7a,0xeb,0xbf }, { 0x52,0x59,0xda,0x95 },
    { 0xbe,0x83,0x2d,0xd4 }, { 0x74,0x21,0xd3,0x58 },
    { 0xe0,0x69,0x29,0x49 }, { 0xc9,0xc8,0x44,0x8e },
    { 0xc2,0x89,0x6a,0x75 }, { 0x8e,0x79,0x78,0xf4 },
    { 0x58,0x3e,0x6b,0x99 }, { 0xb9,0x71,0xdd,0x27 },
    { 0xe1,0x4f,0xb6,0xbe }, { 0x88,0xad,0x17,0xf0 },
    { 0x20,0xac,0x66,0xc9 }, { 0xce,0x3a,0xb4,0x7d },
    { 0xdf,0x4a,0x18,0x63 }, { 0x1a,0x31,0x82,0xe5 },
    { 0x51,0x33,0x60,0x97 }, { 0x53,0x7f,0x45,0x62 },
    { 0x64,0x77,0xe0,0xb1 }, { 0x6b,0xae,0x84,0xbb },
    { 0x81,0xa0,0x1c,0xfe }, { 0x08,0x2b,0x94,0xf9 },
    { 0x48,0x68,0x58,0x70 }, { 0x45,0xfd,0x19,0x8f },
    { 0xde,0x6c,0x87,0x94 }, { 0x7b,0xf8,0xb7,0x52 },
    { 0x73,0xd3,0x23,0xab }, { 0x4b,0x02,0xe2,0x72 },
    { 0x1f,0x8f,0x57,0xe3 }, { 0x55,0xab,0x2a,0x66 },
    { 0xeb,0x28,0x07,0xb2 }, { 0xb5,0xc2,0x03,0x2f },
    { 0xc5,0x7b,0x9a,0x86 }, { 0x37,0x08,0xa5,0xd3 },
    { 0x28,0x87,0xf2,0x30 }, { 0xbf,0xa5,0xb2,0x23 },
    { 0x03,0x6a,0xba,0x02 }, { 0x16,0x82,0x5c,0xed },
    { 0xcf,0x1c,0x2b,0x8a }, { 0x79,0xb4,0x92,0xa7 },
    { 0x07,0xf2,0xf0,0xf3 }, { 0x69,0xe2,0xa1,0x4e },
    { 0xda,0xf4,0xcd,0x65 }, { 0x05,0xbe,0xd5,0x06 },
    { 0x34,0x62,0x1f,0xd1 }, { 0xa6,0xfe,0x8a,0xc4 },
    { 0x2e,0x53,0x9d,0x34 }, { 0xf3,0x55,0xa0,0xa2 },
    { 0x8a,0xe1,0x32,0x05 }, { 0xf6,0xeb,0x75,0xa4 },
    { 0x83,0xec,0x39,0x0b }, { 0x60,0xef,0xaa,0x40 },
    { 0x71,0x9f,0x06,0x5e }, { 0x6e,0x10,0x51,0xbd },
    { 0x21,0x8a,0xf9,0x3e }, { 0xdd,0x06,0x3d,0x96 },
    { 0x3e,0x05,0xae,0xdd }, { 0xe6,0xbd,0x46,0x4d },
    { 0x54,0x8d,0xb5,0x91 }, { 0xc4,0x5d,0x05,0x71 },
    { 0x06,0xd4,0x6f,0x04 }, { 0x50,0x15,0xff,0x60 },
    { 0x98,0xfb,0x24,0x19 }, { 0xbd,0xe9,0x97,0xd6 },
    { 0x40,0x43,0xcc,0x89 }, { 0xd9,0x9e,0x77,0x67 },
    { 0xe8,0x42,0xbd,0xb0 }, { 0x89,0x8b,0x88,0x07 },
    { 0x19,0x5b,0x38,0xe7 }, { 0xc8,0xee,0xdb,0x79 },
    { 0x7c,0x0a,0x47,0xa1 }, { 0x42,0x0f,0xe9,0x7c },
    { 0x84,0x1e,0xc9,0xf8 }, { 0x00,0x00,0x00,0x00 },
    { 0x80,0x86,0x83,0x09 }, { 0x2b,0xed,0x48,0x32 },
    { 0x11,0x70,0xac,0x1e }, { 0x5a,0x72,0x4e,0x6c },
    { 0x0e,0xff,0xfb,0xfd }, { 0x85,0x38,0x56,0x0f },
    { 0xae,0xd5,0x1e,0x3d }, { 0x2d,0x39,0x27,0x36 },
    { 0x0f,0xd9,0x64,0x0a }, { 0x5c,0xa6,0x21,0x68 },
    { 0x5b,0x54,0xd1,0x9b }, { 0x36,0x2e,0x3a,0x24 },
    { 0x0a,0x67,0xb1,0x0c }, { 0x57,0xe7,0x0f,0x93 },
    { 0xee,0x96,0xd2,0xb4 }, { 0x9b,0x91,0x9e,0x1b },
    { 0xc0,0xc5,0x4f,0x80 }, { 0xdc,0x20,0xa2,0x61 },
    { 0x77,0x4b,0x69,0x5a }, { 0x12,0x1a,0x16,0x1c },
    { 0x93,0xba,0x0a,0xe2 }, { 0xa0,0x2a,0xe5,0xc0 },
    { 0x22,0xe0,0x43,0x3c }, { 0x1b,0x17,0x1d,0x12 },
    { 0x09,0x0d,0x0b,0x0e }, { 0x8b,0xc7,0xad,0xf2 },
    { 0xb6,0xa8,0xb9,0x2d }, { 0x1e,0xa9,0xc8,0x14 },
    { 0xf1,0x19,0x85,0x57 }, { 0x75,0x07,0x4c,0xaf },
    { 0x99,0xdd,0xbb,0xee }, { 0x7f,0x60,0xfd,0xa3 },
    { 0x01,0x26,0x9f,0xf7 }, { 0x72,0xf5,0xbc,0x5c },
    { 0x66,0x3b,0xc5,0x44 }, { 0xfb,0x7e,0x34,0x5b },
    { 0x43,0x29,0x76,0x8b }, { 0x23,0xc6,0xdc,0xcb },
    { 0xed,0xfc,0x68,0xb6 }, { 0xe4,0xf1,0x63,0xb8 },
    { 0x31,0xdc,0xca,0xd7 }, { 0x63,0x85,0x10,0x42 },
    { 0x97,0x22,0x40,0x13 }, { 0xc6,0x11,0x20,0x84 },
    { 0x4a,0x24,0x7d,0x85 }, { 0xbb,0x3d,0xf8,0xd2 },
    { 0xf9,0x32,0x11,0xae }, { 0x29,0xa1,0x6d,0xc7 },
    { 0x9e,0x2f,0x4b,0x1d }, { 0xb2,0x30,0xf3,0xdc },
    { 0x86,0x52,0xec,0x0d }, { 0xc1,0xe3,0xd0,0x77 },
    { 0xb3,0x16,0x6c,0x2b }, { 0x70,0xb9,0x99,0xa9 },
    { 0x94,0x48,0xfa,0x11 }, { 0xe9,0x64,0x22,0x47 },
    { 0xfc,0x8c,0xc4,0xa8 }, { 0xf0,0x3f,0x1a,0xa0 },
    { 0x7d,0x2c,0xd8,0x56 }, { 0x33,0x90,0xef,0x22 },
    { 0x49,0x4e,0xc7,0x87 }, { 0x38,0xd1,0xc1,0xd9 },
    { 0xca,0xa2,0xfe,0x8c }, { 0xd4,0x0b,0x36,0x98 },
    { 0xf5,0x81,0xcf,0xa6 }, { 0x7a,0xde,0x28,0xa5 },
    { 0xb7,0x8e,0x26,0xda }, { 0xad,0xbf,0xa4,0x3f },
    { 0x3a,0x9d,0xe4,0x2c }, { 0x78,0x92,0x0d,0x50 },
    { 0x5f,0xcc,0x9b,0x6a }, { 0x7e,0x46,0x62,0x54 },
    { 0x8d,0x13,0xc2,0xf6 }, { 0xd8,0xb8,0xe8,0x90 },
    { 0x39,0xf7,0x5e,0x2e }, { 0xc3,0xaf,0xf5,0x82 },
    { 0x5d,0x80,0xbe,0x9f }, { 0xd0,0x93,0x7c,0x69 },
    { 0xd5,0x2d,0xa9,0x6f }, { 0x25,0x12,0xb3,0xcf },
    { 0xac,0x99,0x3b,0xc8 }, { 0x18,0x7d,0xa7,0x10 },
    { 0x9c,0x63,0x6e,0xe8 }, { 0x3b,0xbb,0x7b,0xdb },
    { 0x26,0x78,0x09,0xcd }, { 0x59,0x18,0xf4,0x6e },
    { 0x9a,0xb7,0x01,0xec }, { 0x4f,0x9a,0xa8,0x83 },
    { 0x95,0x6e,0x65,0xe6 }, { 0xff,0xe6,0x7e,0xaa },
    { 0xbc,0xcf,0x08,0x21 }, { 0x15,0xe8,0xe6,0xef },
    { 0xe7,0x9b,0xd9,0xba }, { 0x6f,0x36,0xce,0x4a },
    { 0x9f,0x09,0xd4,0xea }, { 0xb0,0x7c,0xd6,0x29 },
    { 0xa4,0xb2,0xaf,0x31 }, { 0x3f,0x23,0x31,0x2a },
    { 0xa5,0x94,0x30,0xc6 }, { 0xa2,0x66,0xc0,0x35 },
    { 0x4e,0xbc,0x37,0x74 }, { 0x82,0xca,0xa6,0xfc },
    { 0x90,0xd0,0xb0,0xe0 }, { 0xa7,0xd8,0x15,0x33 },
    { 0x04,0x98,0x4a,0xf1 }, { 0xec,0xda,0xf7,0x41 },
    { 0xcd,0x50,0x0e,0x7f }, { 0x91,0xf6,0x2f,0x17 },
    { 0x4d,0xd6,0x8d,0x76 }, { 0xef,0xb0,0x4d,0x43 },
    { 0xaa,0x4d,0x54,0xcc }, { 0x96,0x04,0xdf,0xe4 },
    { 0xd1,0xb5,0xe3,0x9e }, { 0x6a,0x88,0x1b,0x4c },
    { 0x2c,0x1f,0xb8,0xc1 }, { 0x65,0x51,0x7f,0x46 },
    { 0x5e,0xea,0x04,0x9d }, { 0x8c,0x35,0x5d,0x01 },
    { 0x87,0x74,0x73,0xfa }, { 0x0b,0x41,0x2e,0xfb },
    { 0x67,0x1d,0x5a,0xb3 }, { 0xdb,0xd2,0x52,0x92 },
    { 0x10,0x56,0x33,0xe9 }, { 0xd6,0x47,0x13,0x6d },
    { 0xd7,0x61,0x8c,0x9a }, { 0xa1,0x0c,0x7a,0x37 },
    { 0xf8,0x14,0x8e,0x59 }, { 0x13,0x3c,0x89,0xeb },
    { 0xa9,0x27,0xee,0xce }, { 0x61,0xc9,0x35,0xb7 },
    { 0x1c,0xe5,0xed,0xe1 }, { 0x47,0xb1,0x3c,0x7a },
    { 0xd2,0xdf,0x59,0x9c }, { 0xf2,0x73,0x3f,0x55 },
    { 0x14,0xce,0x79,0x18 }, { 0xc7,0x37,0xbf,0x73 },
    { 0xf7,0xcd,0xea,0x53 }, { 0xfd,0xaa,0x5b,0x5f },
    { 0x3d,0x6f,0x14,0xdf }, { 0x44,0xdb,0x86,0x78 },
    { 0xaf,0xf3,0x81,0xca }, { 0x68,0xc4,0x3e,0xb9 },
    { 0x24,0x34,0x2c,0x38 }, { 0xa3,0x40,0x5f,0xc2 },
    { 0x1d,0xc3,0x72,0x16 }, { 0xe2,0x25,0x0c,0xbc },
    { 0x3c,0x49,0x8b,0x28 }, { 0x0d,0x95,0x41,0xff },
    { 0xa8,0x01,0x71,0x39 }, { 0x0c,0xb3,0xde,0x08 },
    { 0xb4,0xe4,0x9c,0xd8 }, { 0x56,0xc1,0x90,0x64 },
    { 0xcb,0x84,0x61,0x7b }, { 0x32,0xb6,0x70,0xd5 },
    { 0x6c,0x5c,0x74,0x48 }, { 0xb8,0x57,0x42,0xd0 }
  };

# 1117 "rijndael-tables.h"
static const unsigned char S5[256] =
  {
    0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,
    0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,
    0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,
    0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
    0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,
    0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,
    0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,
    0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
    0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,
    0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,
    0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,
    0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
    0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,
    0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,
    0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,
    0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
    0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,
    0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,
    0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,
    0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
    0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,
    0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,
    0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,
    0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
    0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,
    0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,
    0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,
    0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
    0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,
    0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,
    0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,
    0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d
  };

# 1153 "rijndael-tables.h"
static const unsigned char U1[256][4] =
  {
    { 0x00,0x00,0x00,0x00 }, { 0x0e,0x09,0x0d,0x0b },
    { 0x1c,0x12,0x1a,0x16 }, { 0x12,0x1b,0x17,0x1d },
    { 0x38,0x24,0x34,0x2c }, { 0x36,0x2d,0x39,0x27 },
    { 0x24,0x36,0x2e,0x3a }, { 0x2a,0x3f,0x23,0x31 },
    { 0x70,0x48,0x68,0x58 }, { 0x7e,0x41,0x65,0x53 },
    { 0x6c,0x5a,0x72,0x4e }, { 0x62,0x53,0x7f,0x45 },
    { 0x48,0x6c,0x5c,0x74 }, { 0x46,0x65,0x51,0x7f },
    { 0x54,0x7e,0x46,0x62 }, { 0x5a,0x77,0x4b,0x69 },
    { 0xe0,0x90,0xd0,0xb0 }, { 0xee,0x99,0xdd,0xbb },
    { 0xfc,0x82,0xca,0xa6 }, { 0xf2,0x8b,0xc7,0xad },
    { 0xd8,0xb4,0xe4,0x9c }, { 0xd6,0xbd,0xe9,0x97 },
    { 0xc4,0xa6,0xfe,0x8a }, { 0xca,0xaf,0xf3,0x81 },
    { 0x90,0xd8,0xb8,0xe8 }, { 0x9e,0xd1,0xb5,0xe3 },
    { 0x8c,0xca,0xa2,0xfe }, { 0x82,0xc3,0xaf,0xf5 },
    { 0xa8,0xfc,0x8c,0xc4 }, { 0xa6,0xf5,0x81,0xcf },
    { 0xb4,0xee,0x96,0xd2 }, { 0xba,0xe7,0x9b,0xd9 },
    { 0xdb,0x3b,0xbb,0x7b }, { 0xd5,0x32,0xb6,0x70 },
    { 0xc7,0x29,0xa1,0x6d }, { 0xc9,0x20,0xac,0x66 },
    { 0xe3,0x1f,0x8f,0x57 }, { 0xed,0x16,0x82,0x5c },
    { 0xff,0x0d,0x95,0x41 }, { 0xf1,0x04,0x98,0x4a },
    { 0xab,0x73,0xd3,0x23 }, { 0xa5,0x7a,0xde,0x28 },
    { 0xb7,0x61,0xc9,0x35 }, { 0xb9,0x68,0xc4,0x3e },
    { 0x93,0x57,0xe7,0x0f }, { 0x9d,0x5e,0xea,0x04 },
    { 0x8f,0x45,0xfd,0x19 }, { 0x81,0x4c,0xf0,0x12 },
    { 0x3b,0xab,0x6b,0xcb }, { 0x35,0xa2,0x66,0xc0 },
    { 0x27,0xb9,0x71,0xdd }, { 0x29,0xb0,0x7c,0xd6 },
    { 0x03,0x8f,0x5f,0xe7 }, { 0x0d,0x86,0x52,0xec },
    { 0x1f,0x9d,0x45,0xf1 }, { 0x11,0x94,0x48,0xfa },
    { 0x4b,0xe3,0x03,0x93 }, { 0x45,0xea,0x0e,0x98 },
    { 0x57,0xf1,0x19,0x85 }, { 0x59,0xf8,0x14,0x8e },
    { 0x73,0xc7,0x37,0xbf }, { 0x7d,0xce,0x3a,0xb4 },
    { 0x6f,0xd5,0x2d,0xa9 }, { 0x61,0xdc,0x20,0xa2 },
    { 0xad,0x76,0x6d,0xf6 }, { 0xa3,0x7f,0x60,0xfd },
    { 0xb1,0x64,0x77,0xe0 }, { 0xbf,0x6d,0x7a,0xeb },
    { 0x95,0x52,0x59,0xda }, { 0x9b,0x5b,0x54,0xd1 },
    { 0x89,0x40,0x43,0xcc }, { 0x87,0x49,0x4e,0xc7 },
    { 0xdd,0x3e,0x05,0xae }, { 0xd3,0x37,0x08,0xa5 },
    { 0xc1,0x2c,0x1f,0xb8 }, { 0xcf,0x25,0x12,0xb3 },
    { 0xe5,0x1a,0x31,0x82 }, { 0xeb,0x13,0x3c,0x89 },
    { 0xf9,0x08,0x2b,0x94 }, { 0xf7,0x01,0x26,0x9f },
    { 0x4d,0xe6,0xbd,0x46 }, { 0x43,0xef,0xb0,0x4d },
    { 0x51,0xf4,0xa7,0x50 }, { 0x5f,0xfd,0xaa,0x5b },
    { 0x75,0xc2,0x89,0x6a }, { 0x7b,0xcb,0x84,0x61 },
    { 0x69,0xd0,0x93,0x7c }, { 0x67,0xd9,0x9e,0x77 },
    { 0x3d,0xae,0xd5,0x1e }, { 0x33,0xa7,0xd8,0x15 },
    { 0x21,0xbc,0xcf,0x08 }, { 0x2f,0xb5,0xc2,0x03 },
    { 0x05,0x8a,0xe1,0x32 }, { 0x0b,0x83,0xec,0x39 },
    { 0x19,0x98,0xfb,0x24 }, { 0x17,0x91,0xf6,0x2f },
    { 0x76,0x4d,0xd6,0x8d }, { 0x78,0x44,0xdb,0x86 },
    { 0x6a,0x5f,0xcc,0x9b }, { 0x64,0x56,0xc1,0x90 },
    { 0x4e,0x69,0xe2,0xa1 }, { 0x40,0x60,0xef,0xaa },
    { 0x52,0x7b,0xf8,0xb7 }, { 0x5c,0x72,0xf5,0xbc },
    { 0x06,0x05,0xbe,0xd5 }, { 0x08,0x0c,0xb3,0xde },
    { 0x1a,0x17,0xa4,0xc3 }, { 0x14,0x1e,0xa9,0xc8 },
    { 0x3e,0x21,0x8a,0xf9 }, { 0x30,0x28,0x87,0xf2 },
    { 0x22,0x33,0x90,0xef }, { 0x2c,0x3a,0x9d,0xe4 },
    { 0x96,0xdd,0x06,0x3d }, { 0x98,0xd4,0x0b,0x36 },
    { 0x8a,0xcf,0x1c,0x2b }, { 0x84,0xc6,0x11,0x20 },
    { 0xae,0xf9,0x32,0x11 }, { 0xa0,0xf0,0x3f,0x1a },
    { 0xb2,0xeb,0x28,0x07 }, { 0xbc,0xe2,0x25,0x0c },
    { 0xe6,0x95,0x6e,0x65 }, { 0xe8,0x9c,0x63,0x6e },
    { 0xfa,0x87,0x74,0x73 }, { 0xf4,0x8e,0x79,0x78 },
    { 0xde,0xb1,0x5a,0x49 }, { 0xd0,0xb8,0x57,0x42 },
    { 0xc2,0xa3,0x40,0x5f }, { 0xcc,0xaa,0x4d,0x54 },
    { 0x41,0xec,0xda,0xf7 }, { 0x4f,0xe5,0xd7,0xfc },
    { 0x5d,0xfe,0xc0,0xe1 }, { 0x53,0xf7,0xcd,0xea },
    { 0x79,0xc8,0xee,0xdb }, { 0x77,0xc1,0xe3,0xd0 },
    { 0x65,0xda,0xf4,0xcd }, { 0x6b,0xd3,0xf9,0xc6 },
    { 0x31,0xa4,0xb2,0xaf }, { 0x3f,0xad,0xbf,0xa4 },
    { 0x2d,0xb6,0xa8,0xb9 }, { 0x23,0xbf,0xa5,0xb2 },
    { 0x09,0x80,0x86,0x83 }, { 0x07,0x89,0x8b,0x88 },
    { 0x15,0x92,0x9c,0x95 }, { 0x1b,0x9b,0x91,0x9e },
    { 0xa1,0x7c,0x0a,0x47 }, { 0xaf,0x75,0x07,0x4c },
    { 0xbd,0x6e,0x10,0x51 }, { 0xb3,0x67,0x1d,0x5a },
    { 0x99,0x58,0x3e,0x6b }, { 0x97,0x51,0x33,0x60 },
    { 0x85,0x4a,0x24,0x7d }, { 0x8b,0x43,0x29,0x76 },
    { 0xd1,0x34,0x62,0x1f }, { 0xdf,0x3d,0x6f,0x14 },
    { 0xcd,0x26,0x78,0x09 }, { 0xc3,0x2f,0x75,0x02 },
    { 0xe9,0x10,0x56,0x33 }, { 0xe7,0x19,0x5b,0x38 },
    { 0xf5,0x02,0x4c,0x25 }, { 0xfb,0x0b,0x41,0x2e },
    { 0x9a,0xd7,0x61,0x8c }, { 0x94,0xde,0x6c,0x87 },
    { 0x86,0xc5,0x7b,0x9a }, { 0x88,0xcc,0x76,0x91 },
    { 0xa2,0xf3,0x55,0xa0 }, { 0xac,0xfa,0x58,0xab },
    { 0xbe,0xe1,0x4f,0xb6 }, { 0xb0,0xe8,0x42,0xbd },
    { 0xea,0x9f,0x09,0xd4 }, { 0xe4,0x96,0x04,0xdf },
    { 0xf6,0x8d,0x13,0xc2 }, { 0xf8,0x84,0x1e,0xc9 },
    { 0xd2,0xbb,0x3d,0xf8 }, { 0xdc,0xb2,0x30,0xf3 },
    { 0xce,0xa9,0x27,0xee }, { 0xc0,0xa0,0x2a,0xe5 },
    { 0x7a,0x47,0xb1,0x3c }, { 0x74,0x4e,0xbc,0x37 },
    { 0x66,0x55,0xab,0x2a }, { 0x68,0x5c,0xa6,0x21 },
    { 0x42,0x63,0x85,0x10 }, { 0x4c,0x6a,0x88,0x1b },
    { 0x5e,0x71,0x9f,0x06 }, { 0x50,0x78,0x92,0x0d },
    { 0x0a,0x0f,0xd9,0x64 }, { 0x04,0x06,0xd4,0x6f },
    { 0x16,0x1d,0xc3,0x72 }, { 0x18,0x14,0xce,0x79 },
    { 0x32,0x2b,0xed,0x48 }, { 0x3c,0x22,0xe0,0x43 },
    { 0x2e,0x39,0xf7,0x5e }, { 0x20,0x30,0xfa,0x55 },
    { 0xec,0x9a,0xb7,0x01 }, { 0xe2,0x93,0xba,0x0a },
    { 0xf0,0x88,0xad,0x17 }, { 0xfe,0x81,0xa0,0x1c },
    { 0xd4,0xbe,0x83,0x2d }, { 0xda,0xb7,0x8e,0x26 },
    { 0xc8,0xac,0x99,0x3b }, { 0xc6,0xa5,0x94,0x30 },
    { 0x9c,0xd2,0xdf,0x59 }, { 0x92,0xdb,0xd2,0x52 },
    { 0x80,0xc0,0xc5,0x4f }, { 0x8e,0xc9,0xc8,0x44 },
    { 0xa4,0xf6,0xeb,0x75 }, { 0xaa,0xff,0xe6,0x7e },
    { 0xb8,0xe4,0xf1,0x63 }, { 0xb6,0xed,0xfc,0x68 },
    { 0x0c,0x0a,0x67,0xb1 }, { 0x02,0x03,0x6a,0xba },
    { 0x10,0x18,0x7d,0xa7 }, { 0x1e,0x11,0x70,0xac },
    { 0x34,0x2e,0x53,0x9d }, { 0x3a,0x27,0x5e,0x96 },
    { 0x28,0x3c,0x49,0x8b }, { 0x26,0x35,0x44,0x80 },
    { 0x7c,0x42,0x0f,0xe9 }, { 0x72,0x4b,0x02,0xe2 },
    { 0x60,0x50,0x15,0xff }, { 0x6e,0x59,0x18,0xf4 },
    { 0x44,0x66,0x3b,0xc5 }, { 0x4a,0x6f,0x36,0xce },
    { 0x58,0x74,0x21,0xd3 }, { 0x56,0x7d,0x2c,0xd8 },
    { 0x37,0xa1,0x0c,0x7a }, { 0x39,0xa8,0x01,0x71 },
    { 0x2b,0xb3,0x16,0x6c }, { 0x25,0xba,0x1b,0x67 },
    { 0x0f,0x85,0x38,0x56 }, { 0x01,0x8c,0x35,0x5d },
    { 0x13,0x97,0x22,0x40 }, { 0x1d,0x9e,0x2f,0x4b },
    { 0x47,0xe9,0x64,0x22 }, { 0x49,0xe0,0x69,0x29 },
    { 0x5b,0xfb,0x7e,0x34 }, { 0x55,0xf2,0x73,0x3f },
    { 0x7f,0xcd,0x50,0x0e }, { 0x71,0xc4,0x5d,0x05 },
    { 0x63,0xdf,0x4a,0x18 }, { 0x6d,0xd6,0x47,0x13 },
    { 0xd7,0x31,0xdc,0xca }, { 0xd9,0x38,0xd1,0xc1 },
    { 0xcb,0x23,0xc6,0xdc }, { 0xc5,0x2a,0xcb,0xd7 },
    { 0xef,0x15,0xe8,0xe6 }, { 0xe1,0x1c,0xe5,0xed },
    { 0xf3,0x07,0xf2,0xf0 }, { 0xfd,0x0e,0xff,0xfb },
    { 0xa7,0x79,0xb4,0x92 }, { 0xa9,0x70,0xb9,0x99 },
    { 0xbb,0x6b,0xae,0x84 }, { 0xb5,0x62,0xa3,0x8f },
    { 0x9f,0x5d,0x80,0xbe }, { 0x91,0x54,0x8d,0xb5 },
    { 0x83,0x4f,0x9a,0xa8 }, { 0x8d,0x46,0x97,0xa3 }
  };

# 1285 "rijndael-tables.h"
static const unsigned char U2[256][4] =
  {
    { 0x00,0x00,0x00,0x00 }, { 0x0b,0x0e,0x09,0x0d },
    { 0x16,0x1c,0x12,0x1a }, { 0x1d,0x12,0x1b,0x17 },
    { 0x2c,0x38,0x24,0x34 }, { 0x27,0x36,0x2d,0x39 },
    { 0x3a,0x24,0x36,0x2e }, { 0x31,0x2a,0x3f,0x23 },
    { 0x58,0x70,0x48,0x68 }, { 0x53,0x7e,0x41,0x65 },
    { 0x4e,0x6c,0x5a,0x72 }, { 0x45,0x62,0x53,0x7f },
    { 0x74,0x48,0x6c,0x5c }, { 0x7f,0x46,0x65,0x51 },
    { 0x62,0x54,0x7e,0x46 }, { 0x69,0x5a,0x77,0x4b },
    { 0xb0,0xe0,0x90,0xd0 }, { 0xbb,0xee,0x99,0xdd },
    { 0xa6,0xfc,0x82,0xca }, { 0xad,0xf2,0x8b,0xc7 },
    { 0x9c,0xd8,0xb4,0xe4 }, { 0x97,0xd6,0xbd,0xe9 },
    { 0x8a,0xc4,0xa6,0xfe }, { 0x81,0xca,0xaf,0xf3 },
    { 0xe8,0x90,0xd8,0xb8 }, { 0xe3,0x9e,0xd1,0xb5 },
    { 0xfe,0x8c,0xca,0xa2 }, { 0xf5,0x82,0xc3,0xaf },
    { 0xc4,0xa8,0xfc,0x8c }, { 0xcf,0xa6,0xf5,0x81 },
    { 0xd2,0xb4,0xee,0x96 }, { 0xd9,0xba,0xe7,0x9b },
    { 0x7b,0xdb,0x3b,0xbb }, { 0x70,0xd5,0x32,0xb6 },
    { 0x6d,0xc7,0x29,0xa1 }, { 0x66,0xc9,0x20,0xac },
    { 0x57,0xe3,0x1f,0x8f }, { 0x5c,0xed,0x16,0x82 },
    { 0x41,0xff,0x0d,0x95 }, { 0x4a,0xf1,0x04,0x98 },
    { 0x23,0xab,0x73,0xd3 }, { 0x28,0xa5,0x7a,0xde },
    { 0x35,0xb7,0x61,0xc9 }, { 0x3e,0xb9,0x68,0xc4 },
    { 0x0f,0x93,0x57,0xe7 }, { 0x04,0x9d,0x5e,0xea },
    { 0x19,0x8f,0x45,0xfd }, { 0x12,0x81,0x4c,0xf0 },
    { 0xcb,0x3b,0xab,0x6b }, { 0xc0,0x35,0xa2,0x66 },
    { 0xdd,0x27,0xb9,0x71 }, { 0xd6,0x29,0xb0,0x7c },
    { 0xe7,0x03,0x8f,0x5f }, { 0xec,0x0d,0x86,0x52 },
    { 0xf1,0x1f,0x9d,0x45 }, { 0xfa,0x11,0x94,0x48 },
    { 0x93,0x4b,0xe3,0x03 }, { 0x98,0x45,0xea,0x0e },
    { 0x85,0x57,0xf1,0x19 }, { 0x8e,0x59,0xf8,0x14 },
    { 0xbf,0x73,0xc7,0x37 }, { 0xb4,0x7d,0xce,0x3a },
    { 0xa9,0x6f,0xd5,0x2d }, { 0xa2,0x61,0xdc,0x20 },
    { 0xf6,0xad,0x76,0x6d }, { 0xfd,0xa3,0x7f,0x60 },
    { 0xe0,0xb1,0x64,0x77 }, { 0xeb,0xbf,0x6d,0x7a },
    { 0xda,0x95,0x52,0x59 }, { 0xd1,0x9b,0x5b,0x54 },
    { 0xcc,0x89,0x40,0x43 }, { 0xc7,0x87,0x49,0x4e },
    { 0xae,0xdd,0x3e,0x05 }, { 0xa5,0xd3,0x37,0x08 },
    { 0xb8,0xc1,0x2c,0x1f }, { 0xb3,0xcf,0x25,0x12 },
    { 0x82,0xe5,0x1a,0x31 }, { 0x89,0xeb,0x13,0x3c },
    { 0x94,0xf9,0x08,0x2b }, { 0x9f,0xf7,0x01,0x26 },
    { 0x46,0x4d,0xe6,0xbd }, { 0x4d,0x43,0xef,0xb0 },
    { 0x50,0x51,0xf4,0xa7 }, { 0x5b,0x5f,0xfd,0xaa },
    { 0x6a,0x75,0xc2,0x89 }, { 0x61,0x7b,0xcb,0x84 },
    { 0x7c,0x69,0xd0,0x93 }, { 0x77,0x67,0xd9,0x9e },
    { 0x1e,0x3d,0xae,0xd5 }, { 0x15,0x33,0xa7,0xd8 },
    { 0x08,0x21,0xbc,0xcf }, { 0x03,0x2f,0xb5,0xc2 },
    { 0x32,0x05,0x8a,0xe1 }, { 0x39,0x0b,0x83,0xec },
    { 0x24,0x19,0x98,0xfb }, { 0x2f,0x17,0x91,0xf6 },
    { 0x8d,0x76,0x4d,0xd6 }, { 0x86,0x78,0x44,0xdb },
    { 0x9b,0x6a,0x5f,0xcc }, { 0x90,0x64,0x56,0xc1 },
    { 0xa1,0x4e,0x69,0xe2 }, { 0xaa,0x40,0x60,0xef },
    { 0xb7,0x52,0x7b,0xf8 }, { 0xbc,0x5c,0x72,0xf5 },
    { 0xd5,0x06,0x05,0xbe }, { 0xde,0x08,0x0c,0xb3 },
    { 0xc3,0x1a,0x17,0xa4 }, { 0xc8,0x14,0x1e,0xa9 },
    { 0xf9,0x3e,0x21,0x8a }, { 0xf2,0x30,0x28,0x87 },
    { 0xef,0x22,0x33,0x90 }, { 0xe4,0x2c,0x3a,0x9d },
    { 0x3d,0x96,0xdd,0x06 }, { 0x36,0x98,0xd4,0x0b },
    { 0x2b,0x8a,0xcf,0x1c }, { 0x20,0x84,0xc6,0x11 },
    { 0x11,0xae,0xf9,0x32 }, { 0x1a,0xa0,0xf0,0x3f },
    { 0x07,0xb2,0xeb,0x28 }, { 0x0c,0xbc,0xe2,0x25 },
    { 0x65,0xe6,0x95,0x6e }, { 0x6e,0xe8,0x9c,0x63 },
    { 0x73,0xfa,0x87,0x74 }, { 0x78,0xf4,0x8e,0x79 },
    { 0x49,0xde,0xb1,0x5a }, { 0x42,0xd0,0xb8,0x57 },
    { 0x5f,0xc2,0xa3,0x40 }, { 0x54,0xcc,0xaa,0x4d },
    { 0xf7,0x41,0xec,0xda }, { 0xfc,0x4f,0xe5,0xd7 },
    { 0xe1,0x5d,0xfe,0xc0 }, { 0xea,0x53,0xf7,0xcd },
    { 0xdb,0x79,0xc8,0xee }, { 0xd0,0x77,0xc1,0xe3 },
    { 0xcd,0x65,0xda,0xf4 }, { 0xc6,0x6b,0xd3,0xf9 },
    { 0xaf,0x31,0xa4,0xb2 }, { 0xa4,0x3f,0xad,0xbf },
    { 0xb9,0x2d,0xb6,0xa8 }, { 0xb2,0x23,0xbf,0xa5 },
    { 0x83,0x09,0x80,0x86 }, { 0x88,0x07,0x89,0x8b },
    { 0x95,0x15,0x92,0x9c }, { 0x9e,0x1b,0x9b,0x91 },
    { 0x47,0xa1,0x7c,0x0a }, { 0x4c,0xaf,0x75,0x07 },
    { 0x51,0xbd,0x6e,0x10 }, { 0x5a,0xb3,0x67,0x1d },
    { 0x6b,0x99,0x58,0x3e }, { 0x60,0x97,0x51,0x33 },
    { 0x7d,0x85,0x4a,0x24 }, { 0x76,0x8b,0x43,0x29 },
    { 0x1f,0xd1,0x34,0x62 }, { 0x14,0xdf,0x3d,0x6f },
    { 0x09,0xcd,0x26,0x78 }, { 0x02,0xc3,0x2f,0x75 },
    { 0x33,0xe9,0x10,0x56 }, { 0x38,0xe7,0x19,0x5b },
    { 0x25,0xf5,0x02,0x4c }, { 0x2e,0xfb,0x0b,0x41 },
    { 0x8c,0x9a,0xd7,0x61 }, { 0x87,0x94,0xde,0x6c },
    { 0x9a,0x86,0xc5,0x7b }, { 0x91,0x88,0xcc,0x76 },
    { 0xa0,0xa2,0xf3,0x55 }, { 0xab,0xac,0xfa,0x58 },
    { 0xb6,0xbe,0xe1,0x4f }, { 0xbd,0xb0,0xe8,0x42 },
    { 0xd4,0xea,0x9f,0x09 }, { 0xdf,0xe4,0x96,0x04 },
    { 0xc2,0xf6,0x8d,0x13 }, { 0xc9,0xf8,0x84,0x1e },
    { 0xf8,0xd2,0xbb,0x3d }, { 0xf3,0xdc,0xb2,0x30 },
    { 0xee,0xce,0xa9,0x27 }, { 0xe5,0xc0,0xa0,0x2a },
    { 0x3c,0x7a,0x47,0xb1 }, { 0x37,0x74,0x4e,0xbc },
    { 0x2a,0x66,0x55,0xab }, { 0x21,0x68,0x5c,0xa6 },
    { 0x10,0x42,0x63,0x85 }, { 0x1b,0x4c,0x6a,0x88 },
    { 0x06,0x5e,0x71,0x9f }, { 0x0d,0x50,0x78,0x92 },
    { 0x64,0x0a,0x0f,0xd9 }, { 0x6f,0x04,0x06,0xd4 },
    { 0x72,0x16,0x1d,0xc3 }, { 0x79,0x18,0x14,0xce },
    { 0x48,0x32,0x2b,0xed }, { 0x43,0x3c,0x22,0xe0 },
    { 0x5e,0x2e,0x39,0xf7 }, { 0x55,0x20,0x30,0xfa },
    { 0x01,0xec,0x9a,0xb7 }, { 0x0a,0xe2,0x93,0xba },
    { 0x17,0xf0,0x88,0xad }, { 0x1c,0xfe,0x81,0xa0 },
    { 0x2d,0xd4,0xbe,0x83 }, { 0x26,0xda,0xb7,0x8e },
    { 0x3b,0xc8,0xac,0x99 }, { 0x30,0xc6,0xa5,0x94 },
    { 0x59,0x9c,0xd2,0xdf }, { 0x52,0x92,0xdb,0xd2 },
    { 0x4f,0x80,0xc0,0xc5 }, { 0x44,0x8e,0xc9,0xc8 },
    { 0x75,0xa4,0xf6,0xeb }, { 0x7e,0xaa,0xff,0xe6 },
    { 0x63,0xb8,0xe4,0xf1 }, { 0x68,0xb6,0xed,0xfc },
    { 0xb1,0x0c,0x0a,0x67 }, { 0xba,0x02,0x03,0x6a },
    { 0xa7,0x10,0x18,0x7d }, { 0xac,0x1e,0x11,0x70 },
    { 0x9d,0x34,0x2e,0x53 }, { 0x96,0x3a,0x27,0x5e },
    { 0x8b,0x28,0x3c,0x49 }, { 0x80,0x26,0x35,0x44 },
    { 0xe9,0x7c,0x42,0x0f }, { 0xe2,0x72,0x4b,0x02 },
    { 0xff,0x60,0x50,0x15 }, { 0xf4,0x6e,0x59,0x18 },
    { 0xc5,0x44,0x66,0x3b }, { 0xce,0x4a,0x6f,0x36 },
    { 0xd3,0x58,0x74,0x21 }, { 0xd8,0x56,0x7d,0x2c },
    { 0x7a,0x37,0xa1,0x0c }, { 0x71,0x39,0xa8,0x01 },
    { 0x6c,0x2b,0xb3,0x16 }, { 0x67,0x25,0xba,0x1b },
    { 0x56,0x0f,0x85,0x38 }, { 0x5d,0x01,0x8c,0x35 },
    { 0x40,0x13,0x97,0x22 }, { 0x4b,0x1d,0x9e,0x2f },
    { 0x22,0x47,0xe9,0x64 }, { 0x29,0x49,0xe0,0x69 },
    { 0x34,0x5b,0xfb,0x7e }, { 0x3f,0x55,0xf2,0x73 },
    { 0x0e,0x7f,0xcd,0x50 }, { 0x05,0x71,0xc4,0x5d },
    { 0x18,0x63,0xdf,0x4a }, { 0x13,0x6d,0xd6,0x47 },
    { 0xca,0xd7,0x31,0xdc }, { 0xc1,0xd9,0x38,0xd1 },
    { 0xdc,0xcb,0x23,0xc6 }, { 0xd7,0xc5,0x2a,0xcb },
    { 0xe6,0xef,0x15,0xe8 }, { 0xed,0xe1,0x1c,0xe5 },
    { 0xf0,0xf3,0x07,0xf2 }, { 0xfb,0xfd,0x0e,0xff },
    { 0x92,0xa7,0x79,0xb4 }, { 0x99,0xa9,0x70,0xb9 },
    { 0x84,0xbb,0x6b,0xae }, { 0x8f,0xb5,0x62,0xa3 },
    { 0xbe,0x9f,0x5d,0x80 }, { 0xb5,0x91,0x54,0x8d },
    { 0xa8,0x83,0x4f,0x9a }, { 0xa3,0x8d,0x46,0x97 }
  };

# 1417 "rijndael-tables.h"
static const unsigned char U3[256][4] =
  {
    { 0x00,0x00,0x00,0x00 }, { 0x0d,0x0b,0x0e,0x09 },
    { 0x1a,0x16,0x1c,0x12 }, { 0x17,0x1d,0x12,0x1b },
    { 0x34,0x2c,0x38,0x24 }, { 0x39,0x27,0x36,0x2d },
    { 0x2e,0x3a,0x24,0x36 }, { 0x23,0x31,0x2a,0x3f },
    { 0x68,0x58,0x70,0x48 }, { 0x65,0x53,0x7e,0x41 },
    { 0x72,0x4e,0x6c,0x5a }, { 0x7f,0x45,0x62,0x53 },
    { 0x5c,0x74,0x48,0x6c }, { 0x51,0x7f,0x46,0x65 },
    { 0x46,0x62,0x54,0x7e }, { 0x4b,0x69,0x5a,0x77 },
    { 0xd0,0xb0,0xe0,0x90 }, { 0xdd,0xbb,0xee,0x99 },
    { 0xca,0xa6,0xfc,0x82 }, { 0xc7,0xad,0xf2,0x8b },
    { 0xe4,0x9c,0xd8,0xb4 }, { 0xe9,0x97,0xd6,0xbd },
    { 0xfe,0x8a,0xc4,0xa6 }, { 0xf3,0x81,0xca,0xaf },
    { 0xb8,0xe8,0x90,0xd8 }, { 0xb5,0xe3,0x9e,0xd1 },
    { 0xa2,0xfe,0x8c,0xca }, { 0xaf,0xf5,0x82,0xc3 },
    { 0x8c,0xc4,0xa8,0xfc }, { 0x81,0xcf,0xa6,0xf5 },
    { 0x96,0xd2,0xb4,0xee }, { 0x9b,0xd9,0xba,0xe7 },
    { 0xbb,0x7b,0xdb,0x3b }, { 0xb6,0x70,0xd5,0x32 },
    { 0xa1,0x6d,0xc7,0x29 }, { 0xac,0x66,0xc9,0x20 },
    { 0x8f,0x57,0xe3,0x1f }, { 0x82,0x5c,0xed,0x16 },
    { 0x95,0x41,0xff,0x0d }, { 0x98,0x4a,0xf1,0x04 },
    { 0xd3,0x23,0xab,0x73 }, { 0xde,0x28,0xa5,0x7a },
    { 0xc9,0x35,0xb7,0x61 }, { 0xc4,0x3e,0xb9,0x68 },
    { 0xe7,0x0f,0x93,0x57 }, { 0xea,0x04,0x9d,0x5e },
    { 0xfd,0x19,0x8f,0x45 }, { 0xf0,0x12,0x81,0x4c },
    { 0x6b,0xcb,0x3b,0xab }, { 0x66,0xc0,0x35,0xa2 },
    { 0x71,0xdd,0x27,0xb9 }, { 0x7c,0xd6,0x29,0xb0 },
    { 0x5f,0xe7,0x03,0x8f }, { 0x52,0xec,0x0d,0x86 },
    { 0x45,0xf1,0x1f,0x9d }, { 0x48,0xfa,0x11,0x94 },
    { 0x03,0x93,0x4b,0xe3 }, { 0x0e,0x98,0x45,0xea },
    { 0x19,0x85,0x57,0xf1 }, { 0x14,0x8e,0x59,0xf8 },
    { 0x37,0xbf,0x73,0xc7 }, { 0x3a,0xb4,0x7d,0xce },
    { 0x2d,0xa9,0x6f,0xd5 }, { 0x20,0xa2,0x61,0xdc },
    { 0x6d,0xf6,0xad,0x76 }, { 0x60,0xfd,0xa3,0x7f },
    { 0x77,0xe0,0xb1,0x64 }, { 0x7a,0xeb,0xbf,0x6d },
    { 0x59,0xda,0x95,0x52 }, { 0x54,0xd1,0x9b,0x5b },
    { 0x43,0xcc,0x89,0x40 }, { 0x4e,0xc7,0x87,0x49 },
    { 0x05,0xae,0xdd,0x3e }, { 0x08,0xa5,0xd3,0x37 },
    { 0x1f,0xb8,0xc1,0x2c }, { 0x12,0xb3,0xcf,0x25 },
    { 0x31,0x82,0xe5,0x1a }, { 0x3c,0x89,0xeb,0x13 },
    { 0x2b,0x94,0xf9,0x08 }, { 0x26,0x9f,0xf7,0x01 },
    { 0xbd,0x46,0x4d,0xe6 }, { 0xb0,0x4d,0x43,0xef },
    { 0xa7,0x50,0x51,0xf4 }, { 0xaa,0x5b,0x5f,0xfd },
    { 0x89,0x6a,0x75,0xc2 }, { 0x84,0x61,0x7b,0xcb },
    { 0x93,0x7c,0x69,0xd0 }, { 0x9e,0x77,0x67,0xd9 },
    { 0xd5,0x1e,0x3d,0xae }, { 0xd8,0x15,0x33,0xa7 },
    { 0xcf,0x08,0x21,0xbc }, { 0xc2,0x03,0x2f,0xb5 },
    { 0xe1,0x32,0x05,0x8a }, { 0xec,0x39,0x0b,0x83 },
    { 0xfb,0x24,0x19,0x98 }, { 0xf6,0x2f,0x17,0x91 },
    { 0xd6,0x8d,0x76,0x4d }, { 0xdb,0x86,0x78,0x44 },
    { 0xcc,0x9b,0x6a,0x5f }, { 0xc1,0x90,0x64,0x56 },
    { 0xe2,0xa1,0x4e,0x69 }, { 0xef,0xaa,0x40,0x60 },
    { 0xf8,0xb7,0x52,0x7b }, { 0xf5,0xbc,0x5c,0x72 },
    { 0xbe,0xd5,0x06,0x05 }, { 0xb3,0xde,0x08,0x0c },
    { 0xa4,0xc3,0x1a,0x17 }, { 0xa9,0xc8,0x14,0x1e },
    { 0x8a,0xf9,0x3e,0x21 }, { 0x87,0xf2,0x30,0x28 },
    { 0x90,0xef,0x22,0x33 }, { 0x9d,0xe4,0x2c,0x3a },
    { 0x06,0x3d,0x96,0xdd }, { 0x0b,0x36,0x98,0xd4 },
    { 0x1c,0x2b,0x8a,0xcf }, { 0x11,0x20,0x84,0xc6 },
    { 0x32,0x11,0xae,0xf9 }, { 0x3f,0x1a,0xa0,0xf0 },
    { 0x28,0x07,0xb2,0xeb }, { 0x25,0x0c,0xbc,0xe2 },
    { 0x6e,0x65,0xe6,0x95 }, { 0x63,0x6e,0xe8,0x9c },
    { 0x74,0x73,0xfa,0x87 }, { 0x79,0x78,0xf4,0x8e },
    { 0x5a,0x49,0xde,0xb1 }, { 0x57,0x42,0xd0,0xb8 },
    { 0x40,0x5f,0xc2,0xa3 }, { 0x4d,0x54,0xcc,0xaa },
    { 0xda,0xf7,0x41,0xec }, { 0xd7,0xfc,0x4f,0xe5 },
    { 0xc0,0xe1,0x5d,0xfe }, { 0xcd,0xea,0x53,0xf7 },
    { 0xee,0xdb,0x79,0xc8 }, { 0xe3,0xd0,0x77,0xc1 },
    { 0xf4,0xcd,0x65,0xda }, { 0xf9,0xc6,0x6b,0xd3 },
    { 0xb2,0xaf,0x31,0xa4 }, { 0xbf,0xa4,0x3f,0xad },
    { 0xa8,0xb9,0x2d,0xb6 }, { 0xa5,0xb2,0x23,0xbf },
    { 0x86,0x83,0x09,0x80 }, { 0x8b,0x88,0x07,0x89 },
    { 0x9c,0x95,0x15,0x92 }, { 0x91,0x9e,0x1b,0x9b },
    { 0x0a,0x47,0xa1,0x7c }, { 0x07,0x4c,0xaf,0x75 },
    { 0x10,0x51,0xbd,0x6e }, { 0x1d,0x5a,0xb3,0x67 },
    { 0x3e,0x6b,0x99,0x58 }, { 0x33,0x60,0x97,0x51 },
    { 0x24,0x7d,0x85,0x4a }, { 0x29,0x76,0x8b,0x43 },
    { 0x62,0x1f,0xd1,0x34 }, { 0x6f,0x14,0xdf,0x3d },
    { 0x78,0x09,0xcd,0x26 }, { 0x75,0x02,0xc3,0x2f },
    { 0x56,0x33,0xe9,0x10 }, { 0x5b,0x38,0xe7,0x19 },
    { 0x4c,0x25,0xf5,0x02 }, { 0x41,0x2e,0xfb,0x0b },
    { 0x61,0x8c,0x9a,0xd7 }, { 0x6c,0x87,0x94,0xde },
    { 0x7b,0x9a,0x86,0xc5 }, { 0x76,0x91,0x88,0xcc },
    { 0x55,0xa0,0xa2,0xf3 }, { 0x58,0xab,0xac,0xfa },
    { 0x4f,0xb6,0xbe,0xe1 }, { 0x42,0xbd,0xb0,0xe8 },
    { 0x09,0xd4,0xea,0x9f }, { 0x04,0xdf,0xe4,0x96 },
    { 0x13,0xc2,0xf6,0x8d }, { 0x1e,0xc9,0xf8,0x84 },
    { 0x3d,0xf8,0xd2,0xbb }, { 0x30,0xf3,0xdc,0xb2 },
    { 0x27,0xee,0xce,0xa9 }, { 0x2a,0xe5,0xc0,0xa0 },
    { 0xb1,0x3c,0x7a,0x47 }, { 0xbc,0x37,0x74,0x4e },
    { 0xab,0x2a,0x66,0x55 }, { 0xa6,0x21,0x68,0x5c },
    { 0x85,0x10,0x42,0x63 }, { 0x88,0x1b,0x4c,0x6a },
    { 0x9f,0x06,0x5e,0x71 }, { 0x92,0x0d,0x50,0x78 },
    { 0xd9,0x64,0x0a,0x0f }, { 0xd4,0x6f,0x04,0x06 },
    { 0xc3,0x72,0x16,0x1d }, { 0xce,0x79,0x18,0x14 },
    { 0xed,0x48,0x32,0x2b }, { 0xe0,0x43,0x3c,0x22 },
    { 0xf7,0x5e,0x2e,0x39 }, { 0xfa,0x55,0x20,0x30 },
    { 0xb7,0x01,0xec,0x9a }, { 0xba,0x0a,0xe2,0x93 },
    { 0xad,0x17,0xf0,0x88 }, { 0xa0,0x1c,0xfe,0x81 },
    { 0x83,0x2d,0xd4,0xbe }, { 0x8e,0x26,0xda,0xb7 },
    { 0x99,0x3b,0xc8,0xac }, { 0x94,0x30,0xc6,0xa5 },
    { 0xdf,0x59,0x9c,0xd2 }, { 0xd2,0x52,0x92,0xdb },
    { 0xc5,0x4f,0x80,0xc0 }, { 0xc8,0x44,0x8e,0xc9 },
    { 0xeb,0x75,0xa4,0xf6 }, { 0xe6,0x7e,0xaa,0xff },
    { 0xf1,0x63,0xb8,0xe4 }, { 0xfc,0x68,0xb6,0xed },
    { 0x67,0xb1,0x0c,0x0a }, { 0x6a,0xba,0x02,0x03 },
    { 0x7d,0xa7,0x10,0x18 }, { 0x70,0xac,0x1e,0x11 },
    { 0x53,0x9d,0x34,0x2e }, { 0x5e,0x96,0x3a,0x27 },
    { 0x49,0x8b,0x28,0x3c }, { 0x44,0x80,0x26,0x35 },
    { 0x0f,0xe9,0x7c,0x42 }, { 0x02,0xe2,0x72,0x4b },
    { 0x15,0xff,0x60,0x50 }, { 0x18,0xf4,0x6e,0x59 },
    { 0x3b,0xc5,0x44,0x66 }, { 0x36,0xce,0x4a,0x6f },
    { 0x21,0xd3,0x58,0x74 }, { 0x2c,0xd8,0x56,0x7d },
    { 0x0c,0x7a,0x37,0xa1 }, { 0x01,0x71,0x39,0xa8 },
    { 0x16,0x6c,0x2b,0xb3 }, { 0x1b,0x67,0x25,0xba },
    { 0x38,0x56,0x0f,0x85 }, { 0x35,0x5d,0x01,0x8c },
    { 0x22,0x40,0x13,0x97 }, { 0x2f,0x4b,0x1d,0x9e },
    { 0x64,0x22,0x47,0xe9 }, { 0x69,0x29,0x49,0xe0 },
    { 0x7e,0x34,0x5b,0xfb }, { 0x73,0x3f,0x55,0xf2 },
    { 0x50,0x0e,0x7f,0xcd }, { 0x5d,0x05,0x71,0xc4 },
    { 0x4a,0x18,0x63,0xdf }, { 0x47,0x13,0x6d,0xd6 },
    { 0xdc,0xca,0xd7,0x31 }, { 0xd1,0xc1,0xd9,0x38 },
    { 0xc6,0xdc,0xcb,0x23 }, { 0xcb,0xd7,0xc5,0x2a },
    { 0xe8,0xe6,0xef,0x15 }, { 0xe5,0xed,0xe1,0x1c },
    { 0xf2,0xf0,0xf3,0x07 }, { 0xff,0xfb,0xfd,0x0e },
    { 0xb4,0x92,0xa7,0x79 }, { 0xb9,0x99,0xa9,0x70 },
    { 0xae,0x84,0xbb,0x6b }, { 0xa3,0x8f,0xb5,0x62 },
    { 0x80,0xbe,0x9f,0x5d }, { 0x8d,0xb5,0x91,0x54 },
    { 0x9a,0xa8,0x83,0x4f }, { 0x97,0xa3,0x8d,0x46 }
  };

# 1549 "rijndael-tables.h"
static const unsigned char U4[256][4] =
  {
    { 0x00,0x00,0x00,0x00 }, { 0x09,0x0d,0x0b,0x0e },
    { 0x12,0x1a,0x16,0x1c }, { 0x1b,0x17,0x1d,0x12 },
    { 0x24,0x34,0x2c,0x38 }, { 0x2d,0x39,0x27,0x36 },
    { 0x36,0x2e,0x3a,0x24 }, { 0x3f,0x23,0x31,0x2a },
    { 0x48,0x68,0x58,0x70 }, { 0x41,0x65,0x53,0x7e },
    { 0x5a,0x72,0x4e,0x6c }, { 0x53,0x7f,0x45,0x62 },
    { 0x6c,0x5c,0x74,0x48 }, { 0x65,0x51,0x7f,0x46 },
    { 0x7e,0x46,0x62,0x54 }, { 0x77,0x4b,0x69,0x5a },
    { 0x90,0xd0,0xb0,0xe0 }, { 0x99,0xdd,0xbb,0xee },
    { 0x82,0xca,0xa6,0xfc }, { 0x8b,0xc7,0xad,0xf2 },
    { 0xb4,0xe4,0x9c,0xd8 }, { 0xbd,0xe9,0x97,0xd6 },
    { 0xa6,0xfe,0x8a,0xc4 }, { 0xaf,0xf3,0x81,0xca },
    { 0xd8,0xb8,0xe8,0x90 }, { 0xd1,0xb5,0xe3,0x9e },
    { 0xca,0xa2,0xfe,0x8c }, { 0xc3,0xaf,0xf5,0x82 },
    { 0xfc,0x8c,0xc4,0xa8 }, { 0xf5,0x81,0xcf,0xa6 },
    { 0xee,0x96,0xd2,0xb4 }, { 0xe7,0x9b,0xd9,0xba },
    { 0x3b,0xbb,0x7b,0xdb }, { 0x32,0xb6,0x70,0xd5 },
    { 0x29,0xa1,0x6d,0xc7 }, { 0x20,0xac,0x66,0xc9 },
    { 0x1f,0x8f,0x57,0xe3 }, { 0x16,0x82,0x5c,0xed },
    { 0x0d,0x95,0x41,0xff }, { 0x04,0x98,0x4a,0xf1 },
    { 0x73,0xd3,0x23,0xab }, { 0x7a,0xde,0x28,0xa5 },
    { 0x61,0xc9,0x35,0xb7 }, { 0x68,0xc4,0x3e,0xb9 },
    { 0x57,0xe7,0x0f,0x93 }, { 0x5e,0xea,0x04,0x9d },
    { 0x45,0xfd,0x19,0x8f }, { 0x4c,0xf0,0x12,0x81 },
    { 0xab,0x6b,0xcb,0x3b }, { 0xa2,0x66,0xc0,0x35 },
    { 0xb9,0x71,0xdd,0x27 }, { 0xb0,0x7c,0xd6,0x29 },
    { 0x8f,0x5f,0xe7,0x03 }, { 0x86,0x52,0xec,0x0d },
    { 0x9d,0x45,0xf1,0x1f }, { 0x94,0x48,0xfa,0x11 },
    { 0xe3,0x03,0x93,0x4b }, { 0xea,0x0e,0x98,0x45 },
    { 0xf1,0x19,0x85,0x57 }, { 0xf8,0x14,0x8e,0x59 },
    { 0xc7,0x37,0xbf,0x73 }, { 0xce,0x3a,0xb4,0x7d },
    { 0xd5,0x2d,0xa9,0x6f }, { 0xdc,0x20,0xa2,0x61 },
    { 0x76,0x6d,0xf6,0xad }, { 0x7f,0x60,0xfd,0xa3 },
    { 0x64,0x77,0xe0,0xb1 }, { 0x6d,0x7a,0xeb,0xbf },
    { 0x52,0x59,0xda,0x95 }, { 0x5b,0x54,0xd1,0x9b },
    { 0x40,0x43,0xcc,0x89 }, { 0x49,0x4e,0xc7,0x87 },
    { 0x3e,0x05,0xae,0xdd }, { 0x37,0x08,0xa5,0xd3 },
    { 0x2c,0x1f,0xb8,0xc1 }, { 0x25,0x12,0xb3,0xcf },
    { 0x1a,0x31,0x82,0xe5 }, { 0x13,0x3c,0x89,0xeb },
    { 0x08,0x2b,0x94,0xf9 }, { 0x01,0x26,0x9f,0xf7 },
    { 0xe6,0xbd,0x46,0x4d }, { 0xef,0xb0,0x4d,0x43 },
    { 0xf4,0xa7,0x50,0x51 }, { 0xfd,0xaa,0x5b,0x5f },
    { 0xc2,0x89,0x6a,0x75 }, { 0xcb,0x84,0x61,0x7b },
    { 0xd0,0x93,0x7c,0x69 }, { 0xd9,0x9e,0x77,0x67 },
    { 0xae,0xd5,0x1e,0x3d }, { 0xa7,0xd8,0x15,0x33 },
    { 0xbc,0xcf,0x08,0x21 }, { 0xb5,0xc2,0x03,0x2f },
    { 0x8a,0xe1,0x32,0x05 }, { 0x83,0xec,0x39,0x0b },
    { 0x98,0xfb,0x24,0x19 }, { 0x91,0xf6,0x2f,0x17 },
    { 0x4d,0xd6,0x8d,0x76 }, { 0x44,0xdb,0x86,0x78 },
    { 0x5f,0xcc,0x9b,0x6a }, { 0x56,0xc1,0x90,0x64 },
    { 0x69,0xe2,0xa1,0x4e }, { 0x60,0xef,0xaa,0x40 },
    { 0x7b,0xf8,0xb7,0x52 }, { 0x72,0xf5,0xbc,0x5c },
    { 0x05,0xbe,0xd5,0x06 }, { 0x0c,0xb3,0xde,0x08 },
    { 0x17,0xa4,0xc3,0x1a }, { 0x1e,0xa9,0xc8,0x14 },
    { 0x21,0x8a,0xf9,0x3e }, { 0x28,0x87,0xf2,0x30 },
    { 0x33,0x90,0xef,0x22 }, { 0x3a,0x9d,0xe4,0x2c },
    { 0xdd,0x06,0x3d,0x96 }, { 0xd4,0x0b,0x36,0x98 },
    { 0xcf,0x1c,0x2b,0x8a }, { 0xc6,0x11,0x20,0x84 },
    { 0xf9,0x32,0x11,0xae }, { 0xf0,0x3f,0x1a,0xa0 },
    { 0xeb,0x28,0x07,0xb2 }, { 0xe2,0x25,0x0c,0xbc },
    { 0x95,0x6e,0x65,0xe6 }, { 0x9c,0x63,0x6e,0xe8 },
    { 0x87,0x74,0x73,0xfa }, { 0x8e,0x79,0x78,0xf4 },
    { 0xb1,0x5a,0x49,0xde }, { 0xb8,0x57,0x42,0xd0 },
    { 0xa3,0x40,0x5f,0xc2 }, { 0xaa,0x4d,0x54,0xcc },
    { 0xec,0xda,0xf7,0x41 }, { 0xe5,0xd7,0xfc,0x4f },
    { 0xfe,0xc0,0xe1,0x5d }, { 0xf7,0xcd,0xea,0x53 },
    { 0xc8,0xee,0xdb,0x79 }, { 0xc1,0xe3,0xd0,0x77 },
    { 0xda,0xf4,0xcd,0x65 }, { 0xd3,0xf9,0xc6,0x6b },
    { 0xa4,0xb2,0xaf,0x31 }, { 0xad,0xbf,0xa4,0x3f },
    { 0xb6,0xa8,0xb9,0x2d }, { 0xbf,0xa5,0xb2,0x23 },
    { 0x80,0x86,0x83,0x09 }, { 0x89,0x8b,0x88,0x07 },
    { 0x92,0x9c,0x95,0x15 }, { 0x9b,0x91,0x9e,0x1b },
    { 0x7c,0x0a,0x47,0xa1 }, { 0x75,0x07,0x4c,0xaf },
    { 0x6e,0x10,0x51,0xbd }, { 0x67,0x1d,0x5a,0xb3 },
    { 0x58,0x3e,0x6b,0x99 }, { 0x51,0x33,0x60,0x97 },
    { 0x4a,0x24,0x7d,0x85 }, { 0x43,0x29,0x76,0x8b },
    { 0x34,0x62,0x1f,0xd1 }, { 0x3d,0x6f,0x14,0xdf },
    { 0x26,0x78,0x09,0xcd }, { 0x2f,0x75,0x02,0xc3 },
    { 0x10,0x56,0x33,0xe9 }, { 0x19,0x5b,0x38,0xe7 },
    { 0x02,0x4c,0x25,0xf5 }, { 0x0b,0x41,0x2e,0xfb },
    { 0xd7,0x61,0x8c,0x9a }, { 0xde,0x6c,0x87,0x94 },
    { 0xc5,0x7b,0x9a,0x86 }, { 0xcc,0x76,0x91,0x88 },
    { 0xf3,0x55,0xa0,0xa2 }, { 0xfa,0x58,0xab,0xac },
    { 0xe1,0x4f,0xb6,0xbe }, { 0xe8,0x42,0xbd,0xb0 },
    { 0x9f,0x09,0xd4,0xea }, { 0x96,0x04,0xdf,0xe4 },
    { 0x8d,0x13,0xc2,0xf6 }, { 0x84,0x1e,0xc9,0xf8 },
    { 0xbb,0x3d,0xf8,0xd2 }, { 0xb2,0x30,0xf3,0xdc },
    { 0xa9,0x27,0xee,0xce }, { 0xa0,0x2a,0xe5,0xc0 },
    { 0x47,0xb1,0x3c,0x7a }, { 0x4e,0xbc,0x37,0x74 },
    { 0x55,0xab,0x2a,0x66 }, { 0x5c,0xa6,0x21,0x68 },
    { 0x63,0x85,0x10,0x42 }, { 0x6a,0x88,0x1b,0x4c },
    { 0x71,0x9f,0x06,0x5e }, { 0x78,0x92,0x0d,0x50 },
    { 0x0f,0xd9,0x64,0x0a }, { 0x06,0xd4,0x6f,0x04 },
    { 0x1d,0xc3,0x72,0x16 }, { 0x14,0xce,0x79,0x18 },
    { 0x2b,0xed,0x48,0x32 }, { 0x22,0xe0,0x43,0x3c },
    { 0x39,0xf7,0x5e,0x2e }, { 0x30,0xfa,0x55,0x20 },
    { 0x9a,0xb7,0x01,0xec }, { 0x93,0xba,0x0a,0xe2 },
    { 0x88,0xad,0x17,0xf0 }, { 0x81,0xa0,0x1c,0xfe },
    { 0xbe,0x83,0x2d,0xd4 }, { 0xb7,0x8e,0x26,0xda },
    { 0xac,0x99,0x3b,0xc8 }, { 0xa5,0x94,0x30,0xc6 },
    { 0xd2,0xdf,0x59,0x9c }, { 0xdb,0xd2,0x52,0x92 },
    { 0xc0,0xc5,0x4f,0x80 }, { 0xc9,0xc8,0x44,0x8e },
    { 0xf6,0xeb,0x75,0xa4 }, { 0xff,0xe6,0x7e,0xaa },
    { 0xe4,0xf1,0x63,0xb8 }, { 0xed,0xfc,0x68,0xb6 },
    { 0x0a,0x67,0xb1,0x0c }, { 0x03,0x6a,0xba,0x02 },
    { 0x18,0x7d,0xa7,0x10 }, { 0x11,0x70,0xac,0x1e },
    { 0x2e,0x53,0x9d,0x34 }, { 0x27,0x5e,0x96,0x3a },
    { 0x3c,0x49,0x8b,0x28 }, { 0x35,0x44,0x80,0x26 },
    { 0x42,0x0f,0xe9,0x7c }, { 0x4b,0x02,0xe2,0x72 },
    { 0x50,0x15,0xff,0x60 }, { 0x59,0x18,0xf4,0x6e },
    { 0x66,0x3b,0xc5,0x44 }, { 0x6f,0x36,0xce,0x4a },
    { 0x74,0x21,0xd3,0x58 }, { 0x7d,0x2c,0xd8,0x56 },
    { 0xa1,0x0c,0x7a,0x37 }, { 0xa8,0x01,0x71,0x39 },
    { 0xb3,0x16,0x6c,0x2b }, { 0xba,0x1b,0x67,0x25 },
    { 0x85,0x38,0x56,0x0f }, { 0x8c,0x35,0x5d,0x01 },
    { 0x97,0x22,0x40,0x13 }, { 0x9e,0x2f,0x4b,0x1d },
    { 0xe9,0x64,0x22,0x47 }, { 0xe0,0x69,0x29,0x49 },
    { 0xfb,0x7e,0x34,0x5b }, { 0xf2,0x73,0x3f,0x55 },
    { 0xcd,0x50,0x0e,0x7f }, { 0xc4,0x5d,0x05,0x71 },
    { 0xdf,0x4a,0x18,0x63 }, { 0xd6,0x47,0x13,0x6d },
    { 0x31,0xdc,0xca,0xd7 }, { 0x38,0xd1,0xc1,0xd9 },
    { 0x23,0xc6,0xdc,0xcb }, { 0x2a,0xcb,0xd7,0xc5 },
    { 0x15,0xe8,0xe6,0xef }, { 0x1c,0xe5,0xed,0xe1 },
    { 0x07,0xf2,0xf0,0xf3 }, { 0x0e,0xff,0xfb,0xfd },
    { 0x79,0xb4,0x92,0xa7 }, { 0x70,0xb9,0x99,0xa9 },
    { 0x6b,0xae,0x84,0xbb }, { 0x62,0xa3,0x8f,0xb5 },
    { 0x5d,0x80,0xbe,0x9f }, { 0x54,0x8d,0xb5,0x91 },
    { 0x4f,0x9a,0xa8,0x83 }, { 0x46,0x97,0xa3,0x8d }
  };

# 227 "rijndael.c"
static void
aesni_do_setkey (RIJNDAEL_context *ctx, const byte *key)
{
  do { } while (0);

  if (ctx->rounds < 12)
    {
      /* 128-bit key */
# 248 "rijndael.c"
      asm volatile ("movdqu (%[key]), %%xmm1\n\t" /* xmm1 := key   */
                    "movdqa %%xmm1, (%[ksch])\n\t" /* ksch[0] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x01" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm3\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm2\n\t" "pxor   %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0x10(%[ksch])\n\t" /* ksch[1] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x02" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm3\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm2\n\t" "pxor   %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0x20(%[ksch])\n\t" /* ksch[2] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x04" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm3\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm2\n\t" "pxor   %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0x30(%[ksch])\n\t" /* ksch[3] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x08" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm3\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm2\n\t" "pxor   %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0x40(%[ksch])\n\t" /* ksch[4] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x10" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm3\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm2\n\t" "pxor   %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0x50(%[ksch])\n\t" /* ksch[5] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x20" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm3\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm2\n\t" "pxor   %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0x60(%[ksch])\n\t" /* ksch[6] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x40" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm3\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm2\n\t" "pxor   %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0x70(%[ksch])\n\t" /* ksch[7] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x80" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm3\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm2\n\t" "pxor   %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0x80(%[ksch])\n\t" /* ksch[8] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x1b" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm3\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm2\n\t" "pxor   %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0x90(%[ksch])\n\t" /* ksch[9] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x36" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm3\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm1\n\t" "pslldq $4, %%xmm3\n\t" "pxor   %%xmm3, %%xmm2\n\t" "pxor   %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0xa0(%[ksch])\n\t" /* ksch[10] := xmm1  */
                    :
                    : [key] "r" (key), [ksch] "r" (ctx->u1.keyschedule)
                    : "cc", "memory" );


    }
  else if (ctx->rounds == 12)
    {
      /* 192-bit key */
# 307 "rijndael.c"
      asm volatile ("movdqu (%[key]), %%xmm1\n\t" /* xmm1 := key[0..15]   */
                    "movq 16(%[key]), %%xmm3\n\t" /* xmm3 := key[16..23]  */
                    "movdqa %%xmm1, (%[ksch])\n\t" /* ksch[0] := xmm1  */
                    "movdqa %%xmm3, %%xmm5\n\t"

                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x01" " \n\t"
                    "pshufd $0x55, %%xmm2, %%xmm2\n\t" "movdqu %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t" "pshufd $0xff, %%xmm1, %%xmm2\n\t" "movdqu %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "shufpd $0, %%xmm1, %%xmm5\n\t"
                    "movdqa %%xmm5, 0x10(%[ksch])\n\t" /* ksch[1] := xmm5  */
                    "movdqa %%xmm1, %%xmm6\n\t"
                    "shufpd $1, %%xmm3, %%xmm6\n\t"
                    "movdqa %%xmm6, 0x20(%[ksch])\n\t" /* ksch[2] := xmm6  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x02" " \n\t"
                    "pshufd $0x55, %%xmm2, %%xmm2\n\t" "movdqu %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t" "pshufd $0xff, %%xmm1, %%xmm2\n\t" "movdqu %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "movdqa %%xmm1, 0x30(%[ksch])\n\t" /* ksch[3] := xmm1  */
                    "movdqa %%xmm3, %%xmm5\n\t"

                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x04" " \n\t"
                    "pshufd $0x55, %%xmm2, %%xmm2\n\t" "movdqu %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t" "pshufd $0xff, %%xmm1, %%xmm2\n\t" "movdqu %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "shufpd $0, %%xmm1, %%xmm5\n\t"
                    "movdqa %%xmm5, 0x40(%[ksch])\n\t" /* ksch[4] := xmm5  */
                    "movdqa %%xmm1, %%xmm6\n\t"
                    "shufpd $1, %%xmm3, %%xmm6\n\t"
                    "movdqa %%xmm6, 0x50(%[ksch])\n\t" /* ksch[5] := xmm6  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x08" " \n\t"
                    "pshufd $0x55, %%xmm2, %%xmm2\n\t" "movdqu %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t" "pshufd $0xff, %%xmm1, %%xmm2\n\t" "movdqu %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "movdqa %%xmm1, 0x60(%[ksch])\n\t" /* ksch[6] := xmm1  */
                    "movdqa %%xmm3, %%xmm5\n\t"

                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x10" " \n\t"
                    "pshufd $0x55, %%xmm2, %%xmm2\n\t" "movdqu %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t" "pshufd $0xff, %%xmm1, %%xmm2\n\t" "movdqu %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "shufpd $0, %%xmm1, %%xmm5\n\t"
                    "movdqa %%xmm5, 0x70(%[ksch])\n\t" /* ksch[7] := xmm5  */
                    "movdqa %%xmm1, %%xmm6\n\t"
                    "shufpd $1, %%xmm3, %%xmm6\n\t"
                    "movdqa %%xmm6, 0x80(%[ksch])\n\t" /* ksch[8] := xmm6  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x20" " \n\t"
                    "pshufd $0x55, %%xmm2, %%xmm2\n\t" "movdqu %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t" "pshufd $0xff, %%xmm1, %%xmm2\n\t" "movdqu %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "movdqa %%xmm1, 0x90(%[ksch])\n\t" /* ksch[9] := xmm1  */
                    "movdqa %%xmm3, %%xmm5\n\t"

                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x40" " \n\t"
                    "pshufd $0x55, %%xmm2, %%xmm2\n\t" "movdqu %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t" "pshufd $0xff, %%xmm1, %%xmm2\n\t" "movdqu %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "shufpd $0, %%xmm1, %%xmm5\n\t"
                    "movdqa %%xmm5, 0xa0(%[ksch])\n\t" /* ksch[10] := xmm5  */
                    "movdqa %%xmm1, %%xmm6\n\t"
                    "shufpd $1, %%xmm3, %%xmm6\n\t"
                    "movdqa %%xmm6, 0xb0(%[ksch])\n\t" /* ksch[11] := xmm6  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x80" " \n\t"
                    "pshufd $0x55, %%xmm2, %%xmm2\n\t" "movdqu %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t" "pshufd $0xff, %%xmm1, %%xmm2\n\t" "movdqu %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "movdqa %%xmm1, 0xc0(%[ksch])\n\t" /* ksch[12] := xmm1  */
                    :
                    : [key] "r" (key), [ksch] "r" (ctx->u1.keyschedule)
                    : "cc", "memory" );


    }
  else if (ctx->rounds > 12)
    {
      /* 256-bit key */
# 392 "rijndael.c"
      asm volatile ("movdqu (%[key]), %%xmm1\n\t" /* xmm1 := key[0..15]   */
                    "movdqu 16(%[key]), %%xmm3\n\t" /* xmm3 := key[16..31]  */
                    "movdqa %%xmm1, (%[ksch])\n\t" /* ksch[0] := xmm1  */
                    "movdqa %%xmm3, 0x10(%[ksch])\n\t" /* ksch[1] := xmm3  */

                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x01" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0x20(%[ksch])\n\t" /* ksch[2] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x00" " \n\t"
                    "pshufd $0xaa, %%xmm2, %%xmm2\n\t" "movdqa %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "movdqa %%xmm3, 0x30(%[ksch])\n\t" /* ksch[3] := xmm3  */

                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x02" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0x40(%[ksch])\n\t" /* ksch[4] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x00" " \n\t"
                    "pshufd $0xaa, %%xmm2, %%xmm2\n\t" "movdqa %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "movdqa %%xmm3, 0x50(%[ksch])\n\t" /* ksch[5] := xmm3  */

                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x04" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0x60(%[ksch])\n\t" /* ksch[6] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x00" " \n\t"
                    "pshufd $0xaa, %%xmm2, %%xmm2\n\t" "movdqa %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "movdqa %%xmm3, 0x70(%[ksch])\n\t" /* ksch[7] := xmm3  */

                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x08" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0x80(%[ksch])\n\t" /* ksch[8] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x00" " \n\t"
                    "pshufd $0xaa, %%xmm2, %%xmm2\n\t" "movdqa %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "movdqa %%xmm3, 0x90(%[ksch])\n\t" /* ksch[9] := xmm3  */

                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x10" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0xa0(%[ksch])\n\t" /* ksch[10] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x00" " \n\t"
                    "pshufd $0xaa, %%xmm2, %%xmm2\n\t" "movdqa %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "movdqa %%xmm3, 0xb0(%[ksch])\n\t" /* ksch[11] := xmm3  */

                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x20" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0xc0(%[ksch])\n\t" /* ksch[12] := xmm1  */
                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd1, " "0x00" " \n\t"
                    "pshufd $0xaa, %%xmm2, %%xmm2\n\t" "movdqa %%xmm3, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm3\n\t" "pxor %%xmm2, %%xmm3\n\t"
                    "movdqa %%xmm3, 0xd0(%[ksch])\n\t" /* ksch[13] := xmm3  */

                    ".byte 0x66, 0x0f, 0x3a, 0xdf, 0xd3, " "0x40" " \n\t"
                    "pshufd $0xff, %%xmm2, %%xmm2\n\t" "movdqa %%xmm1, %%xmm4\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pslldq $4, %%xmm4\n\t" "pxor %%xmm4, %%xmm1\n\t" "pxor %%xmm2, %%xmm1\n\t"
                    "movdqa %%xmm1, 0xe0(%[ksch])\n\t" /* ksch[14] := xmm1  */

                    :
                    : [key] "r" (key), [ksch] "r" (ctx->u1.keyschedule)
                    : "cc", "memory" );




    }

  do { asm volatile ("pxor %%xmm0, %%xmm0\n\t" "pxor %%xmm1, %%xmm1\n" :: ); } while (0);
  do { asm volatile ("pxor %%xmm2, %%xmm2\n\t" "pxor %%xmm3, %%xmm3\n" "pxor %%xmm4, %%xmm4\n" "pxor %%xmm5, %%xmm5\n" "pxor %%xmm6, %%xmm6\n":: ); } while (0);
}

# 673 "rijndael.c"
static void
prepare_decryption( RIJNDAEL_context *ctx )
{
  int r;


  if (ctx->use_aesni)
    {
      /* The AES-NI decrypt instructions use the Equivalent Inverse
         Cipher, thus we can't use the the standard decrypt key
         preparation.  */
        u128_t *ekey = (u128_t *)ctx->u1.keyschedule;
        u128_t *dkey = (u128_t *)ctx->u2.keyschedule;
        int rr;

 do { } while (0);
# 699 "rijndael.c"
        dkey[0] = ekey[ctx->rounds];
        r=1;
 rr=ctx->rounds-1;
 asm volatile ("movdqa %[ekey], %%xmm1\n\t" /*"aesimc %%xmm1, %%xmm1\n\t"*/ ".byte 0x66, 0x0f, 0x38, 0xdb, 0xc9\n\t" "movdqa %%xmm1, %[dkey]" : [dkey] "=m" (dkey[r]) : [ekey] "m" (ekey[rr]) : "memory"); r++; rr--; /* round 1 */
 asm volatile ("movdqa %[ekey], %%xmm1\n\t" /*"aesimc %%xmm1, %%xmm1\n\t"*/ ".byte 0x66, 0x0f, 0x38, 0xdb, 0xc9\n\t" "movdqa %%xmm1, %[dkey]" : [dkey] "=m" (dkey[r]) : [ekey] "m" (ekey[rr]) : "memory"); r++; rr--; /* round 2 */
 asm volatile ("movdqa %[ekey], %%xmm1\n\t" /*"aesimc %%xmm1, %%xmm1\n\t"*/ ".byte 0x66, 0x0f, 0x38, 0xdb, 0xc9\n\t" "movdqa %%xmm1, %[dkey]" : [dkey] "=m" (dkey[r]) : [ekey] "m" (ekey[rr]) : "memory"); r++; rr--; /* round 3 */
 asm volatile ("movdqa %[ekey], %%xmm1\n\t" /*"aesimc %%xmm1, %%xmm1\n\t"*/ ".byte 0x66, 0x0f, 0x38, 0xdb, 0xc9\n\t" "movdqa %%xmm1, %[dkey]" : [dkey] "=m" (dkey[r]) : [ekey] "m" (ekey[rr]) : "memory"); r++; rr--; /* round 4 */
 asm volatile ("movdqa %[ekey], %%xmm1\n\t" /*"aesimc %%xmm1, %%xmm1\n\t"*/ ".byte 0x66, 0x0f, 0x38, 0xdb, 0xc9\n\t" "movdqa %%xmm1, %[dkey]" : [dkey] "=m" (dkey[r]) : [ekey] "m" (ekey[rr]) : "memory"); r++; rr--; /* round 5 */
 asm volatile ("movdqa %[ekey], %%xmm1\n\t" /*"aesimc %%xmm1, %%xmm1\n\t"*/ ".byte 0x66, 0x0f, 0x38, 0xdb, 0xc9\n\t" "movdqa %%xmm1, %[dkey]" : [dkey] "=m" (dkey[r]) : [ekey] "m" (ekey[rr]) : "memory"); r++; rr--; /* round 6 */
 asm volatile ("movdqa %[ekey], %%xmm1\n\t" /*"aesimc %%xmm1, %%xmm1\n\t"*/ ".byte 0x66, 0x0f, 0x38, 0xdb, 0xc9\n\t" "movdqa %%xmm1, %[dkey]" : [dkey] "=m" (dkey[r]) : [ekey] "m" (ekey[rr]) : "memory"); r++; rr--; /* round 7 */
 asm volatile ("movdqa %[ekey], %%xmm1\n\t" /*"aesimc %%xmm1, %%xmm1\n\t"*/ ".byte 0x66, 0x0f, 0x38, 0xdb, 0xc9\n\t" "movdqa %%xmm1, %[dkey]" : [dkey] "=m" (dkey[r]) : [ekey] "m" (ekey[rr]) : "memory"); r++; rr--; /* round 8 */
 asm volatile ("movdqa %[ekey], %%xmm1\n\t" /*"aesimc %%xmm1, %%xmm1\n\t"*/ ".byte 0x66, 0x0f, 0x38, 0xdb, 0xc9\n\t" "movdqa %%xmm1, %[dkey]" : [dkey] "=m" (dkey[r]) : [ekey] "m" (ekey[rr]) : "memory"); r++; rr--; /* round 9 */
 if (ctx->rounds > 10)
   {
     asm volatile ("movdqa %[ekey], %%xmm1\n\t" /*"aesimc %%xmm1, %%xmm1\n\t"*/ ".byte 0x66, 0x0f, 0x38, 0xdb, 0xc9\n\t" "movdqa %%xmm1, %[dkey]" : [dkey] "=m" (dkey[r]) : [ekey] "m" (ekey[rr]) : "memory"); r++; rr--; /* round 10 */
     asm volatile ("movdqa %[ekey], %%xmm1\n\t" /*"aesimc %%xmm1, %%xmm1\n\t"*/ ".byte 0x66, 0x0f, 0x38, 0xdb, 0xc9\n\t" "movdqa %%xmm1, %[dkey]" : [dkey] "=m" (dkey[r]) : [ekey] "m" (ekey[rr]) : "memory"); r++; rr--; /* round 11 */
     if (ctx->rounds > 12)
       {
         asm volatile ("movdqa %[ekey], %%xmm1\n\t" /*"aesimc %%xmm1, %%xmm1\n\t"*/ ".byte 0x66, 0x0f, 0x38, 0xdb, 0xc9\n\t" "movdqa %%xmm1, %[dkey]" : [dkey] "=m" (dkey[r]) : [ekey] "m" (ekey[rr]) : "memory"); r++; rr--; /* round 12 */
         asm volatile ("movdqa %[ekey], %%xmm1\n\t" /*"aesimc %%xmm1, %%xmm1\n\t"*/ ".byte 0x66, 0x0f, 0x38, 0xdb, 0xc9\n\t" "movdqa %%xmm1, %[dkey]" : [dkey] "=m" (dkey[r]) : [ekey] "m" (ekey[rr]) : "memory"); r++; rr--; /* round 13 */
       }
   }

        dkey[r] = ekey[0];



 do { asm volatile ("pxor %%xmm0, %%xmm0\n\t" "pxor %%xmm1, %%xmm1\n" :: ); } while (0);
    }
  else

    {
      union
      {
        PROPERLY_ALIGNED_TYPE dummy;
        byte *w;
      } w;


      for (r=0; r < 14 +1; r++ )
        {
          *((u32_a_t*)ctx->u2.keyschedule[r][0]) = *((u32_a_t*)ctx->u1.keyschedule[r][0]);
          *((u32_a_t*)ctx->u2.keyschedule[r][1]) = *((u32_a_t*)ctx->u1.keyschedule[r][1]);
          *((u32_a_t*)ctx->u2.keyschedule[r][2]) = *((u32_a_t*)ctx->u1.keyschedule[r][2]);
          *((u32_a_t*)ctx->u2.keyschedule[r][3]) = *((u32_a_t*)ctx->u1.keyschedule[r][3]);
        }

      for (r = 1; r < ctx->rounds; r++)
        {
          w.w = (ctx->u2.keyschedule)[r][0];
          *((u32_a_t*)w.w) = *((u32_a_t*)U1[w.w[0]]) ^ *((u32_a_t*)U2[w.w[1]])
            ^ *((u32_a_t*)U3[w.w[2]]) ^ *((u32_a_t*)U4[w.w[3]]);

          w.w = (ctx->u2.keyschedule)[r][1];
          *((u32_a_t*)w.w) = *((u32_a_t*)U1[w.w[0]]) ^ *((u32_a_t*)U2[w.w[1]])
            ^ *((u32_a_t*)U3[w.w[2]]) ^ *((u32_a_t*)U4[w.w[3]]);

          w.w = (ctx->u2.keyschedule)[r][2];
          *((u32_a_t*)w.w) = *((u32_a_t*)U1[w.w[0]]) ^ *((u32_a_t*)U2[w.w[1]])
        ^ *((u32_a_t*)U3[w.w[2]]) ^ *((u32_a_t*)U4[w.w[3]]);

          w.w = (ctx->u2.keyschedule)[r][3];
          *((u32_a_t*)w.w) = *((u32_a_t*)U1[w.w[0]]) ^ *((u32_a_t*)U2[w.w[1]])
            ^ *((u32_a_t*)U3[w.w[2]]) ^ *((u32_a_t*)U4[w.w[3]]);
        }


      do { volatile char *_vptr=(volatile char *)(&w); size_t _vlen=(sizeof(w)); unsigned char _vset=(0); do { u64 _vset_long = _vset; /*do nothing*/; if (_vlen < sizeof(u64)) break; _vset_long *= ((0x0101010101010101ULL)); do { volatile u64 *_vptr_long = (volatile void *)_vptr; *_vptr_long = _vset_long; _vlen -= sizeof(u64); _vptr += sizeof(u64); } while (_vlen >= sizeof(u64)); } while (0); while(_vlen) { *_vptr=(_vset); _vptr++; _vlen--; } } while(0);
    }
}

# 773 "rijndael.c"
static void
do_encrypt_aligned (const RIJNDAEL_context *ctx,
                    unsigned char *b, const unsigned char *a)
{






  int rounds = ctx->rounds;
  int r;
  union
  {
    u32 tempu32[4]; /* Force correct alignment. */
    byte temp[4][4];
  } u;

  *((u32_a_t*)u.temp[0]) = *((u32_a_t*)(a )) ^ *((u32_a_t*)(ctx->u1.keyschedule)[0][0]);
  *((u32_a_t*)u.temp[1]) = *((u32_a_t*)(a+ 4)) ^ *((u32_a_t*)(ctx->u1.keyschedule)[0][1]);
  *((u32_a_t*)u.temp[2]) = *((u32_a_t*)(a+ 8)) ^ *((u32_a_t*)(ctx->u1.keyschedule)[0][2]);
  *((u32_a_t*)u.temp[3]) = *((u32_a_t*)(a+12)) ^ *((u32_a_t*)(ctx->u1.keyschedule)[0][3]);
  *((u32_a_t*)(b )) = (*((u32_a_t*)T1[u.temp[0][0]])
                        ^ *((u32_a_t*)T2[u.temp[1][1]])
                        ^ *((u32_a_t*)T3[u.temp[2][2]])
                        ^ *((u32_a_t*)T4[u.temp[3][3]]));
  *((u32_a_t*)(b + 4)) = (*((u32_a_t*)T1[u.temp[1][0]])
                        ^ *((u32_a_t*)T2[u.temp[2][1]])
                        ^ *((u32_a_t*)T3[u.temp[3][2]])
                        ^ *((u32_a_t*)T4[u.temp[0][3]]));
  *((u32_a_t*)(b + 8)) = (*((u32_a_t*)T1[u.temp[2][0]])
                        ^ *((u32_a_t*)T2[u.temp[3][1]])
                        ^ *((u32_a_t*)T3[u.temp[0][2]])
                        ^ *((u32_a_t*)T4[u.temp[1][3]]));
  *((u32_a_t*)(b +12)) = (*((u32_a_t*)T1[u.temp[3][0]])
                        ^ *((u32_a_t*)T2[u.temp[0][1]])
                        ^ *((u32_a_t*)T3[u.temp[1][2]])
                        ^ *((u32_a_t*)T4[u.temp[2][3]]));

  for (r = 1; r < rounds-1; r++)
    {
      *((u32_a_t*)u.temp[0]) = *((u32_a_t*)(b )) ^ *((u32_a_t*)(ctx->u1.keyschedule)[r][0]);
      *((u32_a_t*)u.temp[1]) = *((u32_a_t*)(b+ 4)) ^ *((u32_a_t*)(ctx->u1.keyschedule)[r][1]);
      *((u32_a_t*)u.temp[2]) = *((u32_a_t*)(b+ 8)) ^ *((u32_a_t*)(ctx->u1.keyschedule)[r][2]);
      *((u32_a_t*)u.temp[3]) = *((u32_a_t*)(b+12)) ^ *((u32_a_t*)(ctx->u1.keyschedule)[r][3]);

      *((u32_a_t*)(b )) = (*((u32_a_t*)T1[u.temp[0][0]])
                            ^ *((u32_a_t*)T2[u.temp[1][1]])
                            ^ *((u32_a_t*)T3[u.temp[2][2]])
                            ^ *((u32_a_t*)T4[u.temp[3][3]]));
      *((u32_a_t*)(b + 4)) = (*((u32_a_t*)T1[u.temp[1][0]])
                            ^ *((u32_a_t*)T2[u.temp[2][1]])
                            ^ *((u32_a_t*)T3[u.temp[3][2]])
                            ^ *((u32_a_t*)T4[u.temp[0][3]]));
      *((u32_a_t*)(b + 8)) = (*((u32_a_t*)T1[u.temp[2][0]])
                            ^ *((u32_a_t*)T2[u.temp[3][1]])
                            ^ *((u32_a_t*)T3[u.temp[0][2]])
                            ^ *((u32_a_t*)T4[u.temp[1][3]]));
      *((u32_a_t*)(b +12)) = (*((u32_a_t*)T1[u.temp[3][0]])
                            ^ *((u32_a_t*)T2[u.temp[0][1]])
                            ^ *((u32_a_t*)T3[u.temp[1][2]])
                            ^ *((u32_a_t*)T4[u.temp[2][3]]));
    }

  /* Last round is special. */
  *((u32_a_t*)u.temp[0]) = *((u32_a_t*)(b )) ^ *((u32_a_t*)(ctx->u1.keyschedule)[rounds-1][0]);
  *((u32_a_t*)u.temp[1]) = *((u32_a_t*)(b+ 4)) ^ *((u32_a_t*)(ctx->u1.keyschedule)[rounds-1][1]);
  *((u32_a_t*)u.temp[2]) = *((u32_a_t*)(b+ 8)) ^ *((u32_a_t*)(ctx->u1.keyschedule)[rounds-1][2]);
  *((u32_a_t*)u.temp[3]) = *((u32_a_t*)(b+12)) ^ *((u32_a_t*)(ctx->u1.keyschedule)[rounds-1][3]);
  b[ 0] = T1[u.temp[0][0]][1];
  b[ 1] = T1[u.temp[1][1]][1];
  b[ 2] = T1[u.temp[2][2]][1];
  b[ 3] = T1[u.temp[3][3]][1];
  b[ 4] = T1[u.temp[1][0]][1];
  b[ 5] = T1[u.temp[2][1]][1];
  b[ 6] = T1[u.temp[3][2]][1];
  b[ 7] = T1[u.temp[0][3]][1];
  b[ 8] = T1[u.temp[2][0]][1];
  b[ 9] = T1[u.temp[3][1]][1];
  b[10] = T1[u.temp[0][2]][1];
  b[11] = T1[u.temp[1][3]][1];
  b[12] = T1[u.temp[3][0]][1];
  b[13] = T1[u.temp[0][1]][1];
  b[14] = T1[u.temp[1][2]][1];
  b[15] = T1[u.temp[2][3]][1];
  *((u32_a_t*)(b )) ^= *((u32_a_t*)(ctx->u1.keyschedule)[rounds][0]);
  *((u32_a_t*)(b+ 4)) ^= *((u32_a_t*)(ctx->u1.keyschedule)[rounds][1]);
  *((u32_a_t*)(b+ 8)) ^= *((u32_a_t*)(ctx->u1.keyschedule)[rounds][2]);
  *((u32_a_t*)(b+12)) ^= *((u32_a_t*)(ctx->u1.keyschedule)[rounds][3]);


}

# 867 "rijndael.c"
static void
do_encrypt (const RIJNDAEL_context *ctx,
            unsigned char *bx, const unsigned char *ax)
{

  /* BX and AX are not necessary correctly aligned.  Thus we might
     need to copy them here.  We try to align to a 16 bytes.  */
  if (((size_t)ax & 0x0f) || ((size_t)bx & 0x0f))
    {
      union
      {
        u32 dummy[4];
        byte a[16] ;
      } a;
      union
      {
        u32 dummy[4];
        byte b[16] ;
      } b;

      buf_cpy (a.a, ax, 16);
      do_encrypt_aligned (ctx, b.b, a.a);
      buf_cpy (bx, b.b, 16);
    }
  else

    {
      do_encrypt_aligned (ctx, bx, ax);
    }
}

# 902 "rijndael.c"
static void
do_padlock (const RIJNDAEL_context *ctx, int decrypt_flag,
            unsigned char *bx, const unsigned char *ax)
{
  /* BX and AX are not necessary correctly aligned.  Thus we need to
     copy them here. */
  unsigned char a[16] ;
  unsigned char b[16] ;
  unsigned int cword[4] ;
  int blocks;

  /* The control word fields are:
      127:12   11:10 9     8     7     6     5     4     3:0
      RESERVED KSIZE CRYPT INTER KEYGN CIPHR ALIGN DGEST ROUND  */
  cword[0] = (ctx->rounds & 15); /* (The mask is just a safeguard.)  */
  cword[1] = 0;
  cword[2] = 0;
  cword[3] = 0;
  if (decrypt_flag)
    cword[0] |= 0x00000200;

  memcpy (a, ax, 16);

  blocks = 1; /* Init counter for just one block.  */
# 936 "rijndael.c"
  asm volatile
    ("pushfl\n\t" /* Force key reload.  */
     "popfl\n\t"
     "xchg %3, %%ebx\n\t" /* Load key.  */
     ".byte 0xf3, 0x0f, 0xa7, 0xc8\n\t" /* REP XCRYPT ECB. */
     "xchg %3, %%ebx\n" /* Restore GOT register.  */
     : /* No output */
     : "S" (a), "D" (b), "d" (cword), "r" (ctx->u1.padlock_key), "c" (blocks)
     : "cc", "memory"
     );


  memcpy (bx, b, 16);

}

# 968 "rijndael.c"
static inline void
do_aesni_enc (const RIJNDAEL_context *ctx, unsigned char *b,
              const unsigned char *a)
{


  /* Note: For now we relax the alignment requirement for A and B: It
     does not make much difference because in many case we would need
     to memcpy them to an extra buffer; using the movdqu is much faster
     that memcpy and movdqa.  For CFB we know that the IV is properly
     aligned but that is a special case.  We should better implement
     CFB direct in asm.  */
  asm volatile ("movdqu %[src], %%xmm0\n\t" /* xmm0 := *a     */
                "movdqa (%[key]), %%xmm1\n\t" /* xmm1 := key[0] */
                "pxor   %%xmm1, %%xmm0\n\t" /* xmm0 ^= key[0] */
                "movdqa 0x10(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x20(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x30(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x40(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x50(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x60(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x70(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x80(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x90(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xa0(%[key]), %%xmm1\n\t"
                "cmpl $10, %[rounds]\n\t"
                "jz .Lenclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xb0(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xc0(%[key]), %%xmm1\n\t"
                "cmpl $12, %[rounds]\n\t"
                "jz .Lenclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xd0(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xe0(%[key]), %%xmm1\n"

                ".Lenclast%=:\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdd, 0xc1\n\t"
                "movdqu %%xmm0, %[dst]\n"
                : [dst] "=m" (*b)
                : [src] "m" (*a),
                  [key] "r" (ctx->u1.keyschedule),
                  [rounds] "r" (ctx->rounds)
                : "cc", "memory");


}

# 1028 "rijndael.c"
static inline void
do_aesni_dec (const RIJNDAEL_context *ctx, unsigned char *b,
              const unsigned char *a)
{


  asm volatile ("movdqu %[src], %%xmm0\n\t" /* xmm0 := *a     */
                "movdqa (%[key]), %%xmm1\n\t"
                "pxor   %%xmm1, %%xmm0\n\t" /* xmm0 ^= key[0] */
                "movdqa 0x10(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc1\n\t"
                "movdqa 0x20(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc1\n\t"
                "movdqa 0x30(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc1\n\t"
                "movdqa 0x40(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc1\n\t"
                "movdqa 0x50(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc1\n\t"
                "movdqa 0x60(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc1\n\t"
                "movdqa 0x70(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc1\n\t"
                "movdqa 0x80(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc1\n\t"
                "movdqa 0x90(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc1\n\t"
                "movdqa 0xa0(%[key]), %%xmm1\n\t"
                "cmpl $10, %[rounds]\n\t"
                "jz .Ldeclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc1\n\t"
                "movdqa 0xb0(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc1\n\t"
                "movdqa 0xc0(%[key]), %%xmm1\n\t"
                "cmpl $12, %[rounds]\n\t"
                "jz .Ldeclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc1\n\t"
                "movdqa 0xd0(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc1\n\t"
                "movdqa 0xe0(%[key]), %%xmm1\n"

                ".Ldeclast%=:\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdf, 0xc1\n\t"
                "movdqu %%xmm0, %[dst]\n"
                : [dst] "=m" (*b)
                : [src] "m" (*a),
                  [key] "r" (ctx->u2.keyschedule),
                  [rounds] "r" (ctx->rounds)
                : "cc", "memory");


}

# 1084 "rijndael.c"
static void
do_aesni_enc_vec4 (const RIJNDAEL_context *ctx)
{
# 1095 "rijndael.c"
  asm volatile ("movdqa (%[key]), %%xmm0\n\t"
                "pxor   %%xmm0, %%xmm1\n\t" /* xmm1 ^= key[0] */
                "pxor   %%xmm0, %%xmm2\n\t" /* xmm2 ^= key[0] */
                "pxor   %%xmm0, %%xmm3\n\t" /* xmm3 ^= key[0] */
                "pxor   %%xmm0, %%xmm4\n\t" /* xmm4 ^= key[0] */
                "movdqa 0x10(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe0\n\t"
                "movdqa 0x20(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe0\n\t"
                "movdqa 0x30(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe0\n\t"
                "movdqa 0x40(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe0\n\t"
                "movdqa 0x50(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe0\n\t"
                "movdqa 0x60(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe0\n\t"
                "movdqa 0x70(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe0\n\t"
                "movdqa 0x80(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe0\n\t"
                "movdqa 0x90(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe0\n\t"
                "movdqa 0xa0(%[key]), %%xmm0\n\t"
                "cmpl $10, %[rounds]\n\t"
                "jz .Ldeclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe0\n\t"
                "movdqa 0xb0(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe0\n\t"
                "movdqa 0xc0(%[key]), %%xmm0\n\t"
                "cmpl $12, %[rounds]\n\t"
                "jz .Ldeclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe0\n\t"
                "movdqa 0xd0(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe0\n\t"
                "movdqa 0xe0(%[key]), %%xmm0\n"

                ".Ldeclast%=:\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdd, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdd, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdd, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdd, 0xe0\n\t"
                : /* no output */
                : [key] "r" (ctx->u1.keyschedule),
                  [rounds] "r" (ctx->rounds)
                : "cc", "memory");
# 1188 "rijndael.c"
}

# 1193 "rijndael.c"
static void
do_aesni_dec_vec4 (const RIJNDAEL_context *ctx)
{
# 1204 "rijndael.c"
  asm volatile ("movdqa (%[key]), %%xmm0\n\t"
                "pxor   %%xmm0, %%xmm1\n\t" /* xmm1 ^= key[0] */
                "pxor   %%xmm0, %%xmm2\n\t" /* xmm2 ^= key[0] */
                "pxor   %%xmm0, %%xmm3\n\t" /* xmm3 ^= key[0] */
                "pxor   %%xmm0, %%xmm4\n\t" /* xmm4 ^= key[0] */
                "movdqa 0x10(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xe0\n\t"
                "movdqa 0x20(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xe0\n\t"
                "movdqa 0x30(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xe0\n\t"
                "movdqa 0x40(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xe0\n\t"
                "movdqa 0x50(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xe0\n\t"
                "movdqa 0x60(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xe0\n\t"
                "movdqa 0x70(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xe0\n\t"
                "movdqa 0x80(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xe0\n\t"
                "movdqa 0x90(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xe0\n\t"
                "movdqa 0xa0(%[key]), %%xmm0\n\t"
                "cmpl $10, %[rounds]\n\t"
                "jz .Ldeclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xe0\n\t"
                "movdqa 0xb0(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xe0\n\t"
                "movdqa 0xc0(%[key]), %%xmm0\n\t"
                "cmpl $12, %[rounds]\n\t"
                "jz .Ldeclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xe0\n\t"
                "movdqa 0xd0(%[key]), %%xmm0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xde, 0xe0\n\t"
                "movdqa 0xe0(%[key]), %%xmm0\n"

                ".Ldeclast%=:\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdf, 0xc8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdf, 0xd0\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdf, 0xd8\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdf, 0xe0\n\t"
                : /* no output */
                : [key] "r" (ctx->u2.keyschedule),
                  [rounds] "r" (ctx->rounds)
                : "cc", "memory");
# 1297 "rijndael.c"
}

# 1304 "rijndael.c"
static void
do_aesni_cfb (const RIJNDAEL_context *ctx, int decrypt_flag,
              unsigned char *iv, unsigned char *b, const unsigned char *a)
{


  asm volatile ("movdqa %[iv], %%xmm0\n\t" /* xmm0 := IV     */
                "movdqa (%[key]), %%xmm1\n\t" /* xmm1 := key[0] */
                "pxor   %%xmm1, %%xmm0\n\t" /* xmm0 ^= key[0] */
                "movdqa 0x10(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x20(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x30(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x40(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x50(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x60(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x70(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x80(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x90(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xa0(%[key]), %%xmm1\n\t"
                "cmpl $10, %[rounds]\n\t"
                "jz .Lenclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xb0(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xc0(%[key]), %%xmm1\n\t"
                "cmpl $12, %[rounds]\n\t"
                "jz .Lenclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xd0(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xe0(%[key]), %%xmm1\n"

                ".Lenclast%=:\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdd, 0xc1\n\t"
                "movdqu %[src], %%xmm1\n\t" /* Save input.  */
                "pxor %%xmm1, %%xmm0\n\t" /* xmm0 = input ^ IV  */

                "cmpl $1, %[decrypt]\n\t"
                "jz .Ldecrypt_%=\n\t"
                "movdqa %%xmm0, %[iv]\n\t" /* [encrypt] Store IV.  */
                "jmp .Lleave_%=\n"
                ".Ldecrypt_%=:\n\t"
                "movdqa %%xmm1, %[iv]\n" /* [decrypt] Store IV.  */
                ".Lleave_%=:\n\t"
                "movdqu %%xmm0, %[dst]\n" /* Store output.   */
                : [iv] "+m" (*iv), [dst] "=m" (*b)
                : [src] "m" (*a),
                  [key] "r" (ctx->u1.keyschedule),
                  [rounds] "g" (ctx->rounds),
                  [decrypt] "m" (decrypt_flag)
                : "cc", "memory");


}

# 1371 "rijndael.c"
static void
do_aesni_ctr (const RIJNDAEL_context *ctx,
              unsigned char *ctr, unsigned char *b, const unsigned char *a)
{



  asm volatile ("movdqa %%xmm5, %%xmm0\n\t" /* xmm0 := CTR (xmm5)  */
                "pcmpeqd %%xmm1, %%xmm1\n\t"
                "psrldq $8, %%xmm1\n\t" /* xmm1 = -1 */

                "pshufb %%xmm6, %%xmm5\n\t"
                "psubq  %%xmm1, %%xmm5\n\t" /* xmm5++ (big endian) */

                /* detect if 64-bit carry handling is needed */
                "cmpl   $0xffffffff, 8(%[ctr])\n\t"
                "jne    .Lno_carry%=\n\t"
                "cmpl   $0xffffffff, 12(%[ctr])\n\t"
                "jne    .Lno_carry%=\n\t"

                "pslldq $8, %%xmm1\n\t" /* move lower 64-bit to high */
                "psubq   %%xmm1, %%xmm5\n\t" /* add carry to upper 64bits */

                ".Lno_carry%=:\n\t"

                "pshufb %%xmm6, %%xmm5\n\t"
                "movdqa %%xmm5, (%[ctr])\n\t" /* Update CTR (mem).       */

                "pxor (%[key]), %%xmm0\n\t" /* xmm1 ^= key[0]    */
                "movdqa 0x10(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x20(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x30(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x40(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x50(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x60(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x70(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x80(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0x90(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xa0(%[key]), %%xmm1\n\t"
                "cmpl $10, %[rounds]\n\t"
                "jz .Lenclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xb0(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xc0(%[key]), %%xmm1\n\t"
                "cmpl $12, %[rounds]\n\t"
                "jz .Lenclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xd0(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                "movdqa 0xe0(%[key]), %%xmm1\n"

                ".Lenclast%=:\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdd, 0xc1\n\t"
                "movdqu %[src], %%xmm1\n\t" /* xmm1 := input   */
                "pxor %%xmm1, %%xmm0\n\t" /* EncCTR ^= input  */
                "movdqu %%xmm0, %[dst]" /* Store EncCTR.    */

                : [dst] "=m" (*b)
                : [src] "m" (*a),
                  [ctr] "r" (ctr),
                  [key] "r" (ctx->u1.keyschedule),
                  [rounds] "g" (ctx->rounds)
                : "cc", "memory");


}

# 1450 "rijndael.c"
static void
do_aesni_ctr_4 (const RIJNDAEL_context *ctx,
                unsigned char *ctr, unsigned char *b, const unsigned char *a)
{
# 1463 "rijndael.c"
  /* Register usage:
      esi   keyschedule
      xmm0  CTR-0
      xmm1  temp / round key
      xmm2  CTR-1
      xmm3  CTR-2
      xmm4  CTR-3
      xmm5  copy of *ctr
      xmm6  endian swapping mask
   */

  asm volatile ("movdqa %%xmm5, %%xmm0\n\t" /* xmm0, xmm2 := CTR (xmm5) */
                "movdqa %%xmm0, %%xmm2\n\t"
                "pcmpeqd %%xmm1, %%xmm1\n\t"
                "psrldq $8, %%xmm1\n\t" /* xmm1 = -1 */

                "pshufb %%xmm6, %%xmm2\n\t" /* xmm2 := le(xmm2) */
                "psubq  %%xmm1, %%xmm2\n\t" /* xmm2++           */
                "movdqa %%xmm2, %%xmm3\n\t" /* xmm3 := xmm2     */
                "psubq  %%xmm1, %%xmm3\n\t" /* xmm3++           */
                "movdqa %%xmm3, %%xmm4\n\t" /* xmm4 := xmm3     */
                "psubq  %%xmm1, %%xmm4\n\t" /* xmm4++           */
                "movdqa %%xmm4, %%xmm5\n\t" /* xmm5 := xmm4     */
                "psubq  %%xmm1, %%xmm5\n\t" /* xmm5++           */

                /* detect if 64-bit carry handling is needed */
                "cmpl   $0xffffffff, 8(%[ctr])\n\t"
                "jne    .Lno_carry%=\n\t"
                "movl   12(%[ctr]), %%esi\n\t"
                "bswapl %%esi\n\t"
                "cmpl   $0xfffffffc, %%esi\n\t"
                "jb     .Lno_carry%=\n\t" /* no carry */

                "pslldq $8, %%xmm1\n\t" /* move lower 64-bit to high */
                "je     .Lcarry_xmm5%=\n\t" /* esi == 0xfffffffc */
                "cmpl   $0xfffffffe, %%esi\n\t"
                "jb     .Lcarry_xmm4%=\n\t" /* esi == 0xfffffffd */
                "je     .Lcarry_xmm3%=\n\t" /* esi == 0xfffffffe */
                /* esi == 0xffffffff */

                "psubq   %%xmm1, %%xmm2\n\t"
                ".Lcarry_xmm3%=:\n\t"
                "psubq   %%xmm1, %%xmm3\n\t"
                ".Lcarry_xmm4%=:\n\t"
                "psubq   %%xmm1, %%xmm4\n\t"
                ".Lcarry_xmm5%=:\n\t"
                "psubq   %%xmm1, %%xmm5\n\t"

                ".Lno_carry%=:\n\t"
                "movdqa (%[key]), %%xmm1\n\t" /* xmm1 := key[0]    */
                "movl %[rounds], %%esi\n\t"

                "pshufb %%xmm6, %%xmm2\n\t" /* xmm2 := be(xmm2) */
                "pshufb %%xmm6, %%xmm3\n\t" /* xmm3 := be(xmm3) */
                "pshufb %%xmm6, %%xmm4\n\t" /* xmm4 := be(xmm4) */
                "pshufb %%xmm6, %%xmm5\n\t" /* xmm5 := be(xmm5) */
                "movdqa %%xmm5, (%[ctr])\n\t" /* Update CTR (mem).  */

                "pxor   %%xmm1, %%xmm0\n\t" /* xmm0 ^= key[0]    */
                "pxor   %%xmm1, %%xmm2\n\t" /* xmm2 ^= key[0]    */
                "pxor   %%xmm1, %%xmm3\n\t" /* xmm3 ^= key[0]    */
                "pxor   %%xmm1, %%xmm4\n\t" /* xmm4 ^= key[0]    */
                "movdqa 0x10(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe1\n\t"
                "movdqa 0x20(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe1\n\t"
                "movdqa 0x30(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe1\n\t"
                "movdqa 0x40(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe1\n\t"
                "movdqa 0x50(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe1\n\t"
                "movdqa 0x60(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe1\n\t"
                "movdqa 0x70(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe1\n\t"
                "movdqa 0x80(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe1\n\t"
                "movdqa 0x90(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe1\n\t"
                "movdqa 0xa0(%[key]), %%xmm1\n\t"
                "cmpl $10, %%esi\n\t"
                "jz .Lenclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe1\n\t"
                "movdqa 0xb0(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe1\n\t"
                "movdqa 0xc0(%[key]), %%xmm1\n\t"
                "cmpl $12, %%esi\n\t"
                "jz .Lenclast%=\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe1\n\t"
                "movdqa 0xd0(%[key]), %%xmm1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdc, 0xe1\n\t"
                "movdqa 0xe0(%[key]), %%xmm1\n"

                ".Lenclast%=:\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdd, 0xc1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdd, 0xd1\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdd, 0xd9\n\t"
                ".byte 0x66, 0x0f, 0x38, 0xdd, 0xe1\n\t"

                "movdqu (%[src]), %%xmm1\n\t" /* Get block 1.      */
                "pxor %%xmm1, %%xmm0\n\t" /* EncCTR-1 ^= input */
                "movdqu %%xmm0, (%[dst])\n\t" /* Store block 1     */

                "movdqu 16(%[src]), %%xmm1\n\t" /* Get block 2.      */
                "pxor %%xmm1, %%xmm2\n\t" /* EncCTR-2 ^= input */
                "movdqu %%xmm2, 16(%[dst])\n\t" /* Store block 2.    */

                "movdqu 32(%[src]), %%xmm1\n\t" /* Get block 3.      */
                "pxor %%xmm1, %%xmm3\n\t" /* EncCTR-3 ^= input */
                "movdqu %%xmm3, 32(%[dst])\n\t" /* Store block 3.    */

                "movdqu 48(%[src]), %%xmm1\n\t" /* Get block 4.      */
                "pxor %%xmm1, %%xmm4\n\t" /* EncCTR-4 ^= input */
                "movdqu %%xmm4, 48(%[dst])" /* Store block 4.   */

                :
                : [ctr] "r" (ctr),
                  [src] "r" (a),
                  [dst] "r" (b),
                  [key] "r" (ctx->u1.keyschedule),
                  [rounds] "g" (ctx->rounds)
                : "%esi", "cc", "memory");
# 1633 "rijndael.c"
}

# 1638 "rijndael.c"
static unsigned int
rijndael_encrypt (void *context, byte *b, const byte *a)
{
  RIJNDAEL_context *ctx = context;
  unsigned int burn_stack;

  if (0)
    ;

  else if (ctx->use_padlock)
    {
      do_padlock (ctx, 0, b, a);
      burn_stack = (48 + 15 /* possible padding for alignment */);
    }


  else if (ctx->use_aesni)
    {
      do { } while (0);
      do_aesni_enc (ctx, b, a);
      do { asm volatile ("pxor %%xmm0, %%xmm0\n\t" "pxor %%xmm1, %%xmm1\n" :: ); } while (0);
      burn_stack = 0;
    }

  else
    {
      do_encrypt (ctx, b, a);
      burn_stack = (56 + 2*sizeof(int));
    }

  return burn_stack;
}

# 1676 "rijndael.c"
void
_gcry_aes_cfb_enc (void *context, unsigned char *iv,
                   void *outbuf_arg, const void *inbuf_arg,
                   size_t nblocks)
{
  RIJNDAEL_context *ctx = context;
  unsigned char *outbuf = outbuf_arg;
  const unsigned char *inbuf = inbuf_arg;
  unsigned int burn_depth = 48 + 2*sizeof(int);

  if (0)
    ;

  else if (ctx->use_padlock)
    {
      /* Fixme: Let Padlock do the CFBing.  */
      for ( ;nblocks; nblocks-- )
        {
          /* Encrypt the IV. */
          do_padlock (ctx, 0, iv, iv);
          /* XOR the input with the IV and store input into IV.  */
          buf_xor_2dst(outbuf, iv, inbuf, (128/8));
          outbuf += (128/8);
          inbuf += (128/8);
        }
    }


  else if (ctx->use_aesni)
    {
      do { } while (0);
      for ( ;nblocks; nblocks-- )
        {
          do_aesni_cfb (ctx, 0, iv, outbuf, inbuf);
          outbuf += (128/8);
          inbuf += (128/8);
        }
      do { asm volatile ("pxor %%xmm0, %%xmm0\n\t" "pxor %%xmm1, %%xmm1\n" :: ); } while (0);

      burn_depth = 0; /* No stack usage. */
    }

  else
    {
      for ( ;nblocks; nblocks-- )
        {
          /* Encrypt the IV. */
          do_encrypt_aligned (ctx, iv, iv);
          /* XOR the input with the IV and store input into IV.  */
          buf_xor_2dst(outbuf, iv, inbuf, (128/8));
          outbuf += (128/8);
          inbuf += (128/8);
        }
    }

  if (burn_depth)
    do { __gcry_burn_stack (burn_depth); asm volatile ("":::"memory"); } while(0);
}

# 1740 "rijndael.c"
void
_gcry_aes_cbc_enc (void *context, unsigned char *iv,
                   void *outbuf_arg, const void *inbuf_arg,
                   size_t nblocks, int cbc_mac)
{
  RIJNDAEL_context *ctx = context;
  unsigned char *outbuf = outbuf_arg;
  const unsigned char *inbuf = inbuf_arg;
  unsigned char *last_iv;
  unsigned int burn_depth = 48 + 2*sizeof(int);

  int use_aesni = ctx->use_aesni;



  if (use_aesni)
    do { } while (0);


  last_iv = iv;

  for ( ;nblocks; nblocks-- )
    {
      if (0)
        ;

      else if (use_aesni)
        {
          /* ~35% speed up on Sandy-Bridge when doing xoring and copying with
             SSE registers.  */
          asm volatile ("movdqu %[iv], %%xmm0\n\t"
                        "movdqu %[inbuf], %%xmm1\n\t"
                        "pxor %%xmm0, %%xmm1\n\t"
                        "movdqu %%xmm1, %[outbuf]\n\t"
                        : /* No output */
                        : [iv] "m" (*last_iv),
                          [inbuf] "m" (*inbuf),
                          [outbuf] "m" (*outbuf)
                        : "memory" );

          do_aesni_enc (ctx, outbuf, outbuf);
        }

      else
        {
          buf_xor(outbuf, inbuf, last_iv, (128/8));

          if (0)
            ;

          else if (ctx->use_padlock)
            do_padlock (ctx, 0, outbuf, outbuf);

          else
            do_encrypt (ctx, outbuf, outbuf );
        }

      last_iv = outbuf;
      inbuf += (128/8);
      if (!cbc_mac)
        outbuf += (128/8);
    }

  if (last_iv != iv)
    {
      if (0)
        ;

      else if (use_aesni)
        asm volatile ("movdqu %[last], %%xmm0\n\t"
                      "movdqu %%xmm0, %[iv]\n\t"
                      : /* No output */
                      : [last] "m" (*last_iv),
                        [iv] "m" (*iv)
                      : "memory" );

      else
        buf_cpy (iv, last_iv, (128/8));
    }


   if (use_aesni)
     {
       do { asm volatile ("pxor %%xmm0, %%xmm0\n\t" "pxor %%xmm1, %%xmm1\n" :: ); } while (0);
       burn_depth = 0; /* No stack usage. */
     }


  if (burn_depth)
    do { __gcry_burn_stack (burn_depth); asm volatile ("":::"memory"); } while(0);
}

# 1838 "rijndael.c"
void
_gcry_aes_ctr_enc (void *context, unsigned char *ctr,
                   void *outbuf_arg, const void *inbuf_arg,
                   size_t nblocks)
{
  RIJNDAEL_context *ctx = context;
  unsigned char *outbuf = outbuf_arg;
  const unsigned char *inbuf = inbuf_arg;
  unsigned int burn_depth = 48 + 2*sizeof(int);
  int i;

  if (0)
    ;

  else if (ctx->use_aesni)
    {
      static const unsigned char be_mask[16] =
        { 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };

      do { } while (0);

      asm volatile ("movdqa %[mask], %%xmm6\n\t" /* Preload mask */
                    "movdqa %[ctr], %%xmm5\n\t" /* Preload CTR */
                    : /* No output */
                    : [mask] "m" (*be_mask),
                      [ctr] "m" (*ctr)
                    : "memory");

      for ( ;nblocks > 3 ; nblocks -= 4 )
        {
          do_aesni_ctr_4 (ctx, ctr, outbuf, inbuf);
          outbuf += 4*(128/8);
          inbuf += 4*(128/8);
        }
      for ( ;nblocks; nblocks-- )
        {
          do_aesni_ctr (ctx, ctr, outbuf, inbuf);
          outbuf += (128/8);
          inbuf += (128/8);
        }
      do { asm volatile ("pxor %%xmm0, %%xmm0\n\t" "pxor %%xmm1, %%xmm1\n" :: ); } while (0);
      do { asm volatile ("pxor %%xmm2, %%xmm2\n\t" "pxor %%xmm3, %%xmm3\n" "pxor %%xmm4, %%xmm4\n" "pxor %%xmm5, %%xmm5\n" "pxor %%xmm6, %%xmm6\n":: ); } while (0);

      burn_depth = 0; /* No stack usage. */
    }

  else
    {
      union { unsigned char x1[16]; u32 x32[4]; } tmp;

      for ( ;nblocks; nblocks-- )
        {
          /* Encrypt the counter. */
          do_encrypt_aligned (ctx, tmp.x1, ctr);
          /* XOR the input with the encrypted counter and store in output.  */
          buf_xor(outbuf, tmp.x1, inbuf, (128/8));
          outbuf += (128/8);
          inbuf += (128/8);
          /* Increment the counter.  */
          for (i = (128/8); i > 0; i--)
            {
              ctr[i-1]++;
              if (ctr[i-1])
                break;
            }
        }
    }

  if (burn_depth)
    do { __gcry_burn_stack (burn_depth); asm volatile ("":::"memory"); } while(0);
}

# 1915 "rijndael.c"
static void
do_decrypt_aligned (RIJNDAEL_context *ctx,
                    unsigned char *b, const unsigned char *a)
{






  int rounds = ctx->rounds;
  int r;
  union
  {
    u32 tempu32[4]; /* Force correct alignment. */
    byte temp[4][4];
  } u;


  *((u32_a_t*)u.temp[0]) = *((u32_a_t*)(a )) ^ *((u32_a_t*)(ctx->u2.keyschedule)[rounds][0]);
  *((u32_a_t*)u.temp[1]) = *((u32_a_t*)(a+ 4)) ^ *((u32_a_t*)(ctx->u2.keyschedule)[rounds][1]);
  *((u32_a_t*)u.temp[2]) = *((u32_a_t*)(a+ 8)) ^ *((u32_a_t*)(ctx->u2.keyschedule)[rounds][2]);
  *((u32_a_t*)u.temp[3]) = *((u32_a_t*)(a+12)) ^ *((u32_a_t*)(ctx->u2.keyschedule)[rounds][3]);

  *((u32_a_t*)(b )) = (*((u32_a_t*)T5[u.temp[0][0]])
                        ^ *((u32_a_t*)T6[u.temp[3][1]])
                        ^ *((u32_a_t*)T7[u.temp[2][2]])
                        ^ *((u32_a_t*)T8[u.temp[1][3]]));
  *((u32_a_t*)(b+ 4)) = (*((u32_a_t*)T5[u.temp[1][0]])
                        ^ *((u32_a_t*)T6[u.temp[0][1]])
                        ^ *((u32_a_t*)T7[u.temp[3][2]])
                        ^ *((u32_a_t*)T8[u.temp[2][3]]));
  *((u32_a_t*)(b+ 8)) = (*((u32_a_t*)T5[u.temp[2][0]])
                        ^ *((u32_a_t*)T6[u.temp[1][1]])
                        ^ *((u32_a_t*)T7[u.temp[0][2]])
                        ^ *((u32_a_t*)T8[u.temp[3][3]]));
  *((u32_a_t*)(b+12)) = (*((u32_a_t*)T5[u.temp[3][0]])
                        ^ *((u32_a_t*)T6[u.temp[2][1]])
                        ^ *((u32_a_t*)T7[u.temp[1][2]])
                        ^ *((u32_a_t*)T8[u.temp[0][3]]));

  for (r = rounds-1; r > 1; r--)
    {
      *((u32_a_t*)u.temp[0]) = *((u32_a_t*)(b )) ^ *((u32_a_t*)(ctx->u2.keyschedule)[r][0]);
      *((u32_a_t*)u.temp[1]) = *((u32_a_t*)(b+ 4)) ^ *((u32_a_t*)(ctx->u2.keyschedule)[r][1]);
      *((u32_a_t*)u.temp[2]) = *((u32_a_t*)(b+ 8)) ^ *((u32_a_t*)(ctx->u2.keyschedule)[r][2]);
      *((u32_a_t*)u.temp[3]) = *((u32_a_t*)(b+12)) ^ *((u32_a_t*)(ctx->u2.keyschedule)[r][3]);
      *((u32_a_t*)(b )) = (*((u32_a_t*)T5[u.temp[0][0]])
                            ^ *((u32_a_t*)T6[u.temp[3][1]])
                            ^ *((u32_a_t*)T7[u.temp[2][2]])
                            ^ *((u32_a_t*)T8[u.temp[1][3]]));
      *((u32_a_t*)(b+ 4)) = (*((u32_a_t*)T5[u.temp[1][0]])
                            ^ *((u32_a_t*)T6[u.temp[0][1]])
                            ^ *((u32_a_t*)T7[u.temp[3][2]])
                            ^ *((u32_a_t*)T8[u.temp[2][3]]));
      *((u32_a_t*)(b+ 8)) = (*((u32_a_t*)T5[u.temp[2][0]])
                            ^ *((u32_a_t*)T6[u.temp[1][1]])
                            ^ *((u32_a_t*)T7[u.temp[0][2]])
                            ^ *((u32_a_t*)T8[u.temp[3][3]]));
      *((u32_a_t*)(b+12)) = (*((u32_a_t*)T5[u.temp[3][0]])
                            ^ *((u32_a_t*)T6[u.temp[2][1]])
                            ^ *((u32_a_t*)T7[u.temp[1][2]])
                            ^ *((u32_a_t*)T8[u.temp[0][3]]));
    }

  /* Last round is special. */
  *((u32_a_t*)u.temp[0]) = *((u32_a_t*)(b )) ^ *((u32_a_t*)(ctx->u2.keyschedule)[1][0]);
  *((u32_a_t*)u.temp[1]) = *((u32_a_t*)(b+ 4)) ^ *((u32_a_t*)(ctx->u2.keyschedule)[1][1]);
  *((u32_a_t*)u.temp[2]) = *((u32_a_t*)(b+ 8)) ^ *((u32_a_t*)(ctx->u2.keyschedule)[1][2]);
  *((u32_a_t*)u.temp[3]) = *((u32_a_t*)(b+12)) ^ *((u32_a_t*)(ctx->u2.keyschedule)[1][3]);
  b[ 0] = S5[u.temp[0][0]];
  b[ 1] = S5[u.temp[3][1]];
  b[ 2] = S5[u.temp[2][2]];
  b[ 3] = S5[u.temp[1][3]];
  b[ 4] = S5[u.temp[1][0]];
  b[ 5] = S5[u.temp[0][1]];
  b[ 6] = S5[u.temp[3][2]];
  b[ 7] = S5[u.temp[2][3]];
  b[ 8] = S5[u.temp[2][0]];
  b[ 9] = S5[u.temp[1][1]];
  b[10] = S5[u.temp[0][2]];
  b[11] = S5[u.temp[3][3]];
  b[12] = S5[u.temp[3][0]];
  b[13] = S5[u.temp[2][1]];
  b[14] = S5[u.temp[1][2]];
  b[15] = S5[u.temp[0][3]];
  *((u32_a_t*)(b )) ^= *((u32_a_t*)(ctx->u2.keyschedule)[0][0]);
  *((u32_a_t*)(b+ 4)) ^= *((u32_a_t*)(ctx->u2.keyschedule)[0][1]);
  *((u32_a_t*)(b+ 8)) ^= *((u32_a_t*)(ctx->u2.keyschedule)[0][2]);
  *((u32_a_t*)(b+12)) ^= *((u32_a_t*)(ctx->u2.keyschedule)[0][3]);


}

# 2011 "rijndael.c"
static void
do_decrypt (RIJNDAEL_context *ctx, byte *bx, const byte *ax)
{

  /* BX and AX are not necessary correctly aligned.  Thus we might
     need to copy them here.  We try to align to a 16 bytes. */
  if (((size_t)ax & 0x0f) || ((size_t)bx & 0x0f))
    {
      union
      {
        u32 dummy[4];
        byte a[16] ;
      } a;
      union
      {
        u32 dummy[4];
        byte b[16] ;
      } b;

      buf_cpy (a.a, ax, 16);
      do_decrypt_aligned (ctx, b.b, a.a);
      buf_cpy (bx, b.b, 16);
    }
  else

    {
      do_decrypt_aligned (ctx, bx, ax);
    }
}

# 2042 "rijndael.c"
static inline void
check_decryption_preparation (RIJNDAEL_context *ctx)
{
  if (0)
    ;

  else if (ctx->use_padlock)
    { /* Padlock does not need decryption subkeys. */ }

  else if ( !ctx->decryption_prepared )
    {
      prepare_decryption ( ctx );
      ctx->decryption_prepared = 1;
    }
}

# 2059 "rijndael.c"
static unsigned int
rijndael_decrypt (void *context, byte *b, const byte *a)
{
  RIJNDAEL_context *ctx = context;
  unsigned int burn_stack;

  check_decryption_preparation (ctx);

  if (0)
    ;

  else if (ctx->use_padlock)
    {
      do_padlock (ctx, 1, b, a);
      burn_stack = (48 + 2*sizeof(int) /* FIXME */);
    }


  else if (ctx->use_aesni)
    {
      do { } while (0);
      do_aesni_dec (ctx, b, a);
      do { asm volatile ("pxor %%xmm0, %%xmm0\n\t" "pxor %%xmm1, %%xmm1\n" :: ); } while (0);
      burn_stack = 0;
    }

  else
    {
      do_decrypt (ctx, b, a);
      burn_stack = (56+2*sizeof(int));
    }

  return burn_stack;
}

# 2099 "rijndael.c"
void
_gcry_aes_cfb_dec (void *context, unsigned char *iv,
                   void *outbuf_arg, const void *inbuf_arg,
                   size_t nblocks)
{
  RIJNDAEL_context *ctx = context;
  unsigned char *outbuf = outbuf_arg;
  const unsigned char *inbuf = inbuf_arg;
  unsigned int burn_depth = 48 + 2*sizeof(int);

  if (0)
    ;

  else if (ctx->use_padlock)
    {
      /* Fixme:  Let Padlock do the CFBing.  */
      for ( ;nblocks; nblocks-- )
        {
          do_padlock (ctx, 0, iv, iv);
          buf_xor_n_copy(outbuf, iv, inbuf, (128/8));
          outbuf += (128/8);
          inbuf += (128/8);
        }
    }


  else if (ctx->use_aesni)
    {
      do { } while (0);

      /* CFB decryption can be parallelized */
      for ( ;nblocks >= 4; nblocks -= 4)
        {
          asm volatile
            ("movdqu (%[iv]),        %%xmm1\n\t" /* load input blocks */
             "movdqu 0*16(%[inbuf]), %%xmm2\n\t"
             "movdqu 1*16(%[inbuf]), %%xmm3\n\t"
             "movdqu 2*16(%[inbuf]), %%xmm4\n\t"

             "movdqu 3*16(%[inbuf]), %%xmm0\n\t" /* update IV */
             "movdqu %%xmm0,         (%[iv])\n\t"
             : /* No output */
             : [inbuf] "r" (inbuf), [iv] "r" (iv)
             : "memory");

          do_aesni_enc_vec4 (ctx);

          asm volatile
            ("movdqu 0*16(%[inbuf]), %%xmm5\n\t"
             "pxor %%xmm5, %%xmm1\n\t"
             "movdqu %%xmm1, 0*16(%[outbuf])\n\t"

             "movdqu 1*16(%[inbuf]), %%xmm5\n\t"
             "pxor %%xmm5, %%xmm2\n\t"
             "movdqu %%xmm2, 1*16(%[outbuf])\n\t"

             "movdqu 2*16(%[inbuf]), %%xmm5\n\t"
             "pxor %%xmm5, %%xmm3\n\t"
             "movdqu %%xmm3, 2*16(%[outbuf])\n\t"

             "movdqu 3*16(%[inbuf]), %%xmm5\n\t"
             "pxor %%xmm5, %%xmm4\n\t"
             "movdqu %%xmm4, 3*16(%[outbuf])\n\t"

             : /* No output */
             : [inbuf] "r" (inbuf),
               [outbuf] "r" (outbuf)
             : "memory");

          outbuf += 4*(128/8);
          inbuf += 4*(128/8);
        }

      for ( ;nblocks; nblocks-- )
        {
          do_aesni_cfb (ctx, 1, iv, outbuf, inbuf);
          outbuf += (128/8);
          inbuf += (128/8);
        }
      do { asm volatile ("pxor %%xmm0, %%xmm0\n\t" "pxor %%xmm1, %%xmm1\n" :: ); } while (0);
      do { asm volatile ("pxor %%xmm2, %%xmm2\n\t" "pxor %%xmm3, %%xmm3\n" "pxor %%xmm4, %%xmm4\n" "pxor %%xmm5, %%xmm5\n" "pxor %%xmm6, %%xmm6\n":: ); } while (0);

      burn_depth = 0; /* No stack usage. */
    }

  else
    {
      for ( ;nblocks; nblocks-- )
        {
          do_encrypt_aligned (ctx, iv, iv);
          buf_xor_n_copy(outbuf, iv, inbuf, (128/8));
          outbuf += (128/8);
          inbuf += (128/8);
        }
    }

  if (burn_depth)
    do { __gcry_burn_stack (burn_depth); asm volatile ("":::"memory"); } while(0);
}

# 2204 "rijndael.c"
void
_gcry_aes_cbc_dec (void *context, unsigned char *iv,
                   void *outbuf_arg, const void *inbuf_arg,
                   size_t nblocks)
{
  RIJNDAEL_context *ctx = context;
  unsigned char *outbuf = outbuf_arg;
  const unsigned char *inbuf = inbuf_arg;
  unsigned int burn_depth = 48 + 2*sizeof(int) + 4*sizeof (char*);

  check_decryption_preparation (ctx);

  if (0)
    ;

  else if (ctx->use_aesni)
    {
      do { } while (0);

      asm volatile
        ("movdqu %[iv], %%xmm5\n\t" /* use xmm5 as fast IV storage */
         : /* No output */
         : [iv] "m" (*iv)
         : "memory");

      for ( ;nblocks > 3 ; nblocks -= 4 )
        {
          asm volatile
            ("movdqu 0*16(%[inbuf]), %%xmm1\n\t" /* load input blocks */
             "movdqu 1*16(%[inbuf]), %%xmm2\n\t"
             "movdqu 2*16(%[inbuf]), %%xmm3\n\t"
             "movdqu 3*16(%[inbuf]), %%xmm4\n\t"
             : /* No output */
             : [inbuf] "r" (inbuf)
             : "memory");

          do_aesni_dec_vec4 (ctx);

          asm volatile
            ("pxor %%xmm5, %%xmm1\n\t" /* xor IV with output */
             "movdqu 0*16(%[inbuf]), %%xmm5\n\t" /* load new IV */
             "movdqu %%xmm1, 0*16(%[outbuf])\n\t"

             "pxor %%xmm5, %%xmm2\n\t" /* xor IV with output */
             "movdqu 1*16(%[inbuf]), %%xmm5\n\t" /* load new IV */
             "movdqu %%xmm2, 1*16(%[outbuf])\n\t"

             "pxor %%xmm5, %%xmm3\n\t" /* xor IV with output */
             "movdqu 2*16(%[inbuf]), %%xmm5\n\t" /* load new IV */
             "movdqu %%xmm3, 2*16(%[outbuf])\n\t"

             "pxor %%xmm5, %%xmm4\n\t" /* xor IV with output */
             "movdqu 3*16(%[inbuf]), %%xmm5\n\t" /* load new IV */
             "movdqu %%xmm4, 3*16(%[outbuf])\n\t"

             : /* No output */
             : [inbuf] "r" (inbuf),
               [outbuf] "r" (outbuf)
             : "memory");

          outbuf += 4*(128/8);
          inbuf += 4*(128/8);
        }

      for ( ;nblocks; nblocks-- )
        {
          asm volatile
            ("movdqu %[inbuf], %%xmm2\n\t" /* use xmm2 as savebuf */
             : /* No output */
             : [inbuf] "m" (*inbuf)
             : "memory");

          /* uses only xmm0 and xmm1 */
          do_aesni_dec (ctx, outbuf, inbuf);

          asm volatile
            ("movdqu %[outbuf], %%xmm0\n\t"
             "pxor %%xmm5, %%xmm0\n\t" /* xor IV with output */
             "movdqu %%xmm0, %[outbuf]\n\t"
             "movdqu %%xmm2, %%xmm5\n\t" /* store savebuf as new IV */
             : /* No output */
             : [outbuf] "m" (*outbuf)
             : "memory");

          outbuf += (128/8);
          inbuf += (128/8);
        }

      asm volatile
        ("movdqu %%xmm5, %[iv]\n\t" /* store IV */
         : /* No output */
         : [iv] "m" (*iv)
         : "memory");

      do { asm volatile ("pxor %%xmm0, %%xmm0\n\t" "pxor %%xmm1, %%xmm1\n" :: ); } while (0);
      do { asm volatile ("pxor %%xmm2, %%xmm2\n\t" "pxor %%xmm3, %%xmm3\n" "pxor %%xmm4, %%xmm4\n" "pxor %%xmm5, %%xmm5\n" "pxor %%xmm6, %%xmm6\n":: ); } while (0);

      burn_depth = 0; /* No stack usage. */
    }

  else
    {
      unsigned char savebuf[(128/8)];

      for ( ;nblocks; nblocks-- )
        {
          /* INBUF is needed later and it may be identical to OUTBUF, so store
             the intermediate result to SAVEBUF.  */

          if (0)
            ;

          else if (ctx->use_padlock)
            do_padlock (ctx, 1, savebuf, inbuf);

          else
            do_decrypt (ctx, savebuf, inbuf);

          buf_xor_n_copy_2(outbuf, savebuf, iv, inbuf, (128/8));
          inbuf += (128/8);
          outbuf += (128/8);
        }

      do { volatile char *_vptr=(volatile char *)(savebuf); size_t _vlen=(sizeof(savebuf)); unsigned char _vset=(0); do { u64 _vset_long = _vset; /*do nothing*/; if (_vlen < sizeof(u64)) break; _vset_long *= ((0x0101010101010101ULL)); do { volatile u64 *_vptr_long = (volatile void *)_vptr; *_vptr_long = _vset_long; _vlen -= sizeof(u64); _vptr += sizeof(u64); } while (_vlen >= sizeof(u64)); } while (0); while(_vlen) { *_vptr=(_vset); _vptr++; _vlen--; } } while(0);
    }

  if (burn_depth)
    do { __gcry_burn_stack (burn_depth); asm volatile ("":::"memory"); } while(0);
}

# 35 "mpi-internal.h"
typedef unsigned int mpi_limb_t;

# 236 "../src/gcrypt.h"
typedef struct gcry_mpi *gcry_mpi_t;

# 65 "../src/mpi.h"
struct gcry_mpi
{
  int alloced; /* Array size (# of allocated limbs). */
  int nlimbs; /* Number of valid limbs. */
  int sign; /* Indicates a negative number and is also used
		          for opaque MPIs to store the length.  */
  unsigned int flags; /* Bit 0: Array to be allocated in secure memory space.*/
                      /* Bit 2: The limb is a pointer to some m_alloced data.*/
                      /* Bit 4: Immutable MPI - the MPI may not be modified.  */
                      /* Bit 5: Constant MPI - the MPI will not be freed.  */
  mpi_limb_t *d; /* Array with the limbs */
};

# 265 "mpi-internal.h"
typedef unsigned int USItype;

# 112 "mpi-scan.c"
unsigned
_gcry_mpi_trailing_zeros( gcry_mpi_t a )
{
    unsigned n, count = 0;

    for(n=0; n < a->nlimbs; n++ ) {
 if( a->d[n] ) {
     unsigned nn;
     mpi_limb_t alimb = a->d[n];

     __asm__ ("bsfl %1,%0" : "=r" (nn) : "rm" ((USItype)(alimb)) : "cc");
     count += nn;
     break;
 }
 count += (8*(4));
    }
    return count;

}

# 27 "rand-internal.h"
enum random_origins
  {
    RANDOM_ORIGIN_INIT = 0, /* Used only for initialization. */
    RANDOM_ORIGIN_EXTERNAL = 1, /* Added from an external source.  */
    RANDOM_ORIGIN_FASTPOLL = 2, /* Fast random poll function.  */
    RANDOM_ORIGIN_SLOWPOLL = 3, /* Slow poll function.  */
    RANDOM_ORIGIN_EXTRAPOLL = 4 /* Used to mark an extra pool seed
                                    due to a GCRY_VERY_STRONG_RANDOM
                                    random request.  */
  };

# 50 "rndhw.c"
static volatile int rng_failed;

# 54 "rndhw.c"
static size_t
poll_padlock (void (*add)(const void*, size_t, enum random_origins),
              enum random_origins origin, int fast)
{
  volatile char buffer[64+8] ;
  volatile char *p;
  unsigned int nbytes, status;

  /* Peter Gutmann's cryptlib tests again whether the RNG is enabled
     but we don't do so.  We would have to do this also for our AES
     implementaion and that is definitely too time consuming.  There
     would be a race condition anyway.  Thus we assume that the OS
     does not change the Padlock initialization while a user process
     is running.  */
  p = buffer;
  nbytes = 0;
  while (nbytes < 64)
    {
# 82 "rndhw.c"
      asm volatile
        ("movl %1, %%edi\n\t" /* Set buffer.  */
         "xorl %%edx, %%edx\n\t" /* Request up to 8 bytes.  */
         ".byte 0x0f, 0xa7, 0xc0\n\t" /* XSTORE RNG. */
         : "=a" (status)
         : "g" (p)
         : "%edx", "%edi", "cc"
         );

      if ((status & (1<<6)) /* RNG still enabled.  */
          && !(status & (1<<13)) /* von Neumann corrector is enabled.  */
          && !(status & (1<<14)) /* String filter is disabled.  */
          && !(status & 0x1c00) /* BIAS voltage at default.  */
          && (!(status & 0x1f) || (status & 0x1f) == 8) /* Sanity check.  */
          )
        {
          nbytes += (status & 0x1f);
          if (fast)
            break; /* Don't get into the loop with the fast flag set.  */
          p += (status & 0x1f);
        }
      else
        {
          /* If there was an error we need to break the loop and
             record that there is something wrong with the padlock
             RNG.  */
          rng_failed = 1;
          break;
        }
    }

  if (nbytes)
    {
      (*add) ((void*)buffer, nbytes, origin);
      do { volatile char *_vptr=(volatile char *)(buffer); size_t _vlen=(nbytes); unsigned char _vset=(0); do { u64 _vset_long = _vset; /*do nothing*/; if (_vlen < sizeof(u64)) break; _vset_long *= ((0x0101010101010101ULL)); do { volatile u64 *_vptr_long = (volatile void *)_vptr; *_vptr_long = _vset_long; _vlen -= sizeof(u64); _vptr += sizeof(u64); } while (_vlen >= sizeof(u64)); } while (0); while(_vlen) { *_vptr=(_vset); _vptr++; _vlen--; } } while(0);
    }
  return nbytes;
}

# 131 "rndhw.c"
static inline int
rdrand_long (unsigned long *v)
{
  int ok;
  asm volatile ("1: " ".byte 0x0f,0xc7,0xf0" "\n\t"
                "jc 2f\n\t"
                "decl %0\n\t"
                "jnz 1b\n\t"
                "2:"
                : "=r" (ok), "=a" (*v)
                : "0" (10)
                : "cc");
  return ok;
}

# 63 "conftest.c"
void a(void) {
              __asm__("rorxl $23, %%eax, %%edx\n\t":::"memory");
            }

# 55 "mpi-bit.c"
void
_gcry_mpi_normalize( gcry_mpi_t a )
{
    if( ((a) && ((a)->flags&4)) )
 return;

    for( ; a->nlimbs && !a->d[a->nlimbs-1]; a->nlimbs-- )
 ;
}

# 70 "mpi-bit.c"
unsigned int
_gcry_mpi_get_nbits (gcry_mpi_t a)
{
    unsigned n;

    if( ((a) && ((a)->flags&4)) ) {
 return a->sign; /* which holds the number of bits */
    }

    _gcry_mpi_normalize( a );
    if( a->nlimbs ) {
 mpi_limb_t alimb = a->d[a->nlimbs-1];
 if( alimb )
     do { USItype __cbtmp; __asm__ ("bsrl %1,%0" : "=r" (__cbtmp) : "rm" ((USItype)(alimb)) : "cc"); (n) = __cbtmp ^ 31; } while (0);
 else
     n = (8*(4));
 n = (8*(4)) - n + (a->nlimbs-1) * (8*(4));
    }
    else
 n = 0;
    return n;
}

# 135 "../src/g10lib.h"
void _gcry_assert_failed (const char *expr, const char *file, int line,
                          const char *func);

# 142 "../src/g10lib.h"
void _gcry_divide_by_zero (void);

# 105 "../src/mpi.h"
void _gcry_mpi_resize( gcry_mpi_t a, unsigned nlimbs );

# 125 "../src/mpi.h"
gcry_mpi_t _gcry_mpi_set_cond (gcry_mpi_t w, const gcry_mpi_t u,
                               unsigned long swap);

# 71 "mpi-internal.h"
typedef mpi_limb_t *mpi_ptr_t;

# 72 "mpi-internal.h"
typedef int mpi_size_t;

# 174 "mpi-internal.h"
mpi_ptr_t _gcry_mpi_alloc_limb_space( unsigned nlimbs, int sec );

# 175 "mpi-internal.h"
void _gcry_mpi_free_limb_space( mpi_ptr_t a, unsigned int nlimbs );

# 197 "mpi-internal.h"
mpi_limb_t _gcry_mpih_sub_n( mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr,
     mpi_ptr_t s2_ptr, mpi_size_t size);

# 207 "mpi-internal.h"
struct karatsuba_ctx {
    struct karatsuba_ctx *next;
    mpi_ptr_t tspace;
    unsigned int tspace_nlimbs;
    mpi_size_t tspace_size;
    mpi_ptr_t tp;
    unsigned int tp_nlimbs;
    mpi_size_t tp_size;
};

# 217 "mpi-internal.h"
void _gcry_mpih_release_karatsuba_ctx( struct karatsuba_ctx *ctx );

# 225 "mpi-internal.h"
mpi_limb_t _gcry_mpih_mul( mpi_ptr_t prodp, mpi_ptr_t up, mpi_size_t usize,
      mpi_ptr_t vp, mpi_size_t vsize);

# 231 "mpi-internal.h"
void _gcry_mpih_mul_karatsuba_case( mpi_ptr_t prodp,
     mpi_ptr_t up, mpi_size_t usize,
     mpi_ptr_t vp, mpi_size_t vsize,
     struct karatsuba_ctx *ctx );

# 244 "mpi-internal.h"
mpi_limb_t _gcry_mpih_divrem( mpi_ptr_t qp, mpi_size_t qextra_limbs,
      mpi_ptr_t np, mpi_size_t nsize,
      mpi_ptr_t dp, mpi_size_t dsize);

# 252 "mpi-internal.h"
mpi_limb_t _gcry_mpih_lshift( mpi_ptr_t wp, mpi_ptr_t up, mpi_size_t usize,
          unsigned cnt);

# 254 "mpi-internal.h"
mpi_limb_t _gcry_mpih_rshift( mpi_ptr_t wp, mpi_ptr_t up, mpi_size_t usize,
          unsigned cnt);

# 88 "mpi-inline.h"
extern __inline__ mpi_limb_t
_gcry_mpih_sub_1(mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr,
       mpi_size_t s1_size, mpi_limb_t s2_limb )
{
    mpi_limb_t x;

    x = *s1_ptr++;
    s2_limb = x - s2_limb;
    *res_ptr++ = s2_limb;
    if( s2_limb > x ) {
 while( --s1_size ) {
     x = *s1_ptr++;
     *res_ptr++ = x - 1;
     if( x )
  goto leave;
 }
 return 1;
    }

  leave:
    if( res_ptr != s1_ptr ) {
 mpi_size_t i;
 for( i=0; i < s1_size-1; i++ )
     res_ptr[i] = s1_ptr[i];
    }
    return 0;
}

# 118 "mpi-inline.h"
extern __inline__ mpi_limb_t
_gcry_mpih_sub( mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr, mpi_size_t s1_size,
    mpi_ptr_t s2_ptr, mpi_size_t s2_size)
{
    mpi_limb_t cy = 0;

    if( s2_size )
 cy = _gcry_mpih_sub_n(res_ptr, s1_ptr, s2_ptr, s2_size);

    if( s1_size - s2_size )
 cy = _gcry_mpih_sub_1(res_ptr + s2_size, s1_ptr + s2_size,
          s1_size - s2_size, cy);
    return cy;
}

# 363 "mpi-pow.c"
static void
mul_mod (mpi_ptr_t xp, mpi_size_t *xsize_p,
         mpi_ptr_t rp, mpi_size_t rsize,
         mpi_ptr_t sp, mpi_size_t ssize,
         mpi_ptr_t mp, mpi_size_t msize,
         struct karatsuba_ctx *karactx_p)
{
  if( ssize < 16 )
    _gcry_mpih_mul ( xp, rp, rsize, sp, ssize );
  else
    _gcry_mpih_mul_karatsuba_case (xp, rp, rsize, sp, ssize, karactx_p);

   if (rsize + ssize > msize)
    {
      _gcry_mpih_divrem (xp + msize, 0, xp, rsize + ssize, mp, msize);
      *xsize_p = msize;
    }
   else
     *xsize_p = rsize + ssize;
}

# 397 "mpi-pow.c"
void
_gcry_mpi_powm (gcry_mpi_t res,
                gcry_mpi_t base, gcry_mpi_t expo, gcry_mpi_t mod)
{
  /* Pointer to the limbs of the arguments, their size and signs. */
  mpi_ptr_t rp, ep, mp, bp;
  mpi_size_t esize, msize, bsize, rsize;
  int msign, bsign, rsign;
  /* Flags telling the secure allocation status of the arguments.  */
  int esec, msec, bsec;
  /* Size of the result including space for temporary values.  */
  mpi_size_t size;
  /* Helper.  */
  int mod_shift_cnt;
  int negative_result;
  mpi_ptr_t mp_marker = ((void *)0);
  mpi_ptr_t bp_marker = ((void *)0);
  mpi_ptr_t ep_marker = ((void *)0);
  mpi_ptr_t xp_marker = ((void *)0);
  unsigned int mp_nlimbs = 0;
  unsigned int bp_nlimbs = 0;
  unsigned int ep_nlimbs = 0;
  unsigned int xp_nlimbs = 0;
  mpi_ptr_t precomp[((1 << (5 - 1)))]; /* Pre-computed array: BASE^1, ^3, ^5, ... */
  mpi_size_t precomp_size[((1 << (5 - 1)))];
  mpi_size_t W;
  mpi_ptr_t base_u;
  mpi_size_t base_u_size;
  mpi_size_t max_u_size;

  esize = expo->nlimbs;
  msize = mod->nlimbs;
  size = 2 * msize;
  msign = mod->sign;

  if (esize * (8*(4)) > 512)
    W = 5;
  else if (esize * (8*(4)) > 256)
    W = 4;
  else if (esize * (8*(4)) > 128)
    W = 3;
  else if (esize * (8*(4)) > 64)
    W = 2;
  else
    W = 1;

  esec = ((expo) && ((expo)->flags&1));
  msec = ((mod) && ((mod)->flags&1));
  bsec = ((base) && ((base)->flags&1));

  rp = res->d;
  ep = expo->d;

  if (!msize)
    _gcry_divide_by_zero();

  if (!esize)
    {
      /* Exponent is zero, result is 1 mod MOD, i.e., 1 or 0 depending
         on if MOD equals 1.  */
      res->nlimbs = (msize == 1 && mod->d[0] == 1) ? 0 : 1;
      if (res->nlimbs)
        {
          do { if( (res)->alloced < (1) ) _gcry_mpi_resize(((res)),((1))); } while(0);
          rp = res->d;
          rp[0] = 1;
        }
      res->sign = 0;
      goto leave;
    }

  /* Normalize MOD (i.e. make its most significant bit set) as
     required by mpn_divrem.  This will make the intermediate values
     in the calculation slightly larger, but the correct result is
     obtained after a final reduction using the original MOD value. */
  mp_nlimbs = msec? msize:0;
  mp = mp_marker = _gcry_mpi_alloc_limb_space((msize),(msec));
  do { USItype __cbtmp; __asm__ ("bsrl %1,%0" : "=r" (__cbtmp) : "rm" ((USItype)(mod->d[msize-1])) : "cc"); (mod_shift_cnt) = __cbtmp ^ 31; } while (0);
  if (mod_shift_cnt)
    _gcry_mpih_lshift (mp, mod->d, msize, mod_shift_cnt);
  else
    do { mpi_size_t _i; for( _i = 0; _i < (msize); _i++ ) (mp)[_i] = (mod->d)[_i]; } while(0);

  bsize = base->nlimbs;
  bsign = base->sign;
  if (bsize > msize)
    {
      /* The base is larger than the module.  Reduce it.

         Allocate (BSIZE + 1) with space for remainder and quotient.
         (The quotient is (bsize - msize + 1) limbs.)  */
      bp_nlimbs = bsec ? (bsize + 1):0;
      bp = bp_marker = _gcry_mpi_alloc_limb_space((bsize + 1),(bsec));
      do { mpi_size_t _i; for( _i = 0; _i < (bsize); _i++ ) (bp)[_i] = (base->d)[_i]; } while(0);
      /* We don't care about the quotient, store it above the
       * remainder, at BP + MSIZE.  */
      _gcry_mpih_divrem( bp + msize, 0, bp, bsize, mp, msize );
      bsize = msize;
      /* Canonicalize the base, since we are going to multiply with it
         quite a few times.  */
      do { while( (bsize) > 0 ) { if( (bp)[(bsize)-1] ) break; (bsize)--; } } while(0);
    }
  else
    bp = base->d;

  if (!bsize)
    {
      res->nlimbs = 0;
      res->sign = 0;
      goto leave;
    }


  /* Make BASE, EXPO and MOD not overlap with RES.  */
  if ( rp == bp )
    {
      /* RES and BASE are identical.  Allocate temp. space for BASE.  */
      ((!bp_marker)? (void)0 : _gcry_assert_failed ("!bp_marker", "mpi-pow.c", 514, __FUNCTION__));
      bp_nlimbs = bsec? bsize:0;
      bp = bp_marker = _gcry_mpi_alloc_limb_space((bsize),(bsec));
      do { mpi_size_t _i; for( _i = 0; _i < (bsize); _i++ ) (bp)[_i] = (rp)[_i]; } while(0);
    }
  if ( rp == ep )
    {
      /* RES and EXPO are identical.  Allocate temp. space for EXPO.  */
      ep_nlimbs = esec? esize:0;
      ep = ep_marker = _gcry_mpi_alloc_limb_space((esize),(esec));
      do { mpi_size_t _i; for( _i = 0; _i < (esize); _i++ ) (ep)[_i] = (rp)[_i]; } while(0);
    }
  if ( rp == mp )
    {
      /* RES and MOD are identical.  Allocate temporary space for MOD.*/
      ((!mp_marker)? (void)0 : _gcry_assert_failed ("!mp_marker", "mpi-pow.c", 529, __FUNCTION__));
      mp_nlimbs = msec?msize:0;
      mp = mp_marker = _gcry_mpi_alloc_limb_space((msize),(msec));
      do { mpi_size_t _i; for( _i = 0; _i < (msize); _i++ ) (mp)[_i] = (rp)[_i]; } while(0);
    }

  /* Copy base to the result.  */
  if (res->alloced < size)
    {
      _gcry_mpi_resize((res),(size));
      rp = res->d;
    }

  /* Main processing.  */
  {
    mpi_size_t i, j, k;
    mpi_ptr_t xp;
    mpi_size_t xsize;
    int c;
    mpi_limb_t e;
    mpi_limb_t carry_limb;
    struct karatsuba_ctx karactx;
    mpi_ptr_t tp;

    xp_nlimbs = msec? (2 * (msize + 1)):0;
    xp = xp_marker = _gcry_mpi_alloc_limb_space((2 * (msize + 1)),(msec));

    memset( &karactx, 0, sizeof karactx );
    negative_result = (ep[0] & 1) && bsign;

    /* Precompute PRECOMP[], BASE^(2 * i + 1), BASE^1, ^3, ^5, ... */
    if (W > 1) /* X := BASE^2 */
      mul_mod (xp, &xsize, bp, bsize, bp, bsize, mp, msize, &karactx);
    base_u = precomp[0] = _gcry_mpi_alloc_limb_space((bsize),(esec));
    base_u_size = max_u_size = precomp_size[0] = bsize;
    do { mpi_size_t _i; for( _i = 0; _i < (bsize); _i++ ) (precomp[0])[_i] = (bp)[_i]; } while(0);
    for (i = 1; i < (1 << (W - 1)); i++)
      { /* PRECOMP[i] = BASE^(2 * i + 1) */
        if (xsize >= base_u_size)
          mul_mod (rp, &rsize, xp, xsize, base_u, base_u_size,
                   mp, msize, &karactx);
        else
          mul_mod (rp, &rsize, base_u, base_u_size, xp, xsize,
                   mp, msize, &karactx);
        base_u = precomp[i] = _gcry_mpi_alloc_limb_space((rsize),(esec));
        base_u_size = precomp_size[i] = rsize;
        if (max_u_size < base_u_size)
          max_u_size = base_u_size;
        do { mpi_size_t _i; for( _i = 0; _i < (rsize); _i++ ) (precomp[i])[_i] = (rp)[_i]; } while(0);
      }

    if (msize > max_u_size)
      max_u_size = msize;
    base_u = _gcry_mpi_alloc_limb_space((max_u_size),(esec));
    do { int _i; for( _i = 0; _i < (max_u_size); _i++ ) (base_u)[_i] = 0; } while (0);

    i = esize - 1;

    /* Main loop.

       Make the result be pointed to alternately by XP and RP.  This
       helps us avoid block copying, which would otherwise be
       necessary with the overlap restrictions of
       _gcry_mpih_divmod. With 50% probability the result after this
       loop will be in the area originally pointed by RP (==RES->d),
       and with 50% probability in the area originally pointed to by XP. */
    rsign = 0;
    if (W == 1)
      {
        rsize = bsize;
      }
    else
      {
        rsize = msize;
        do { int _i; for( _i = 0; _i < (rsize); _i++ ) (rp)[_i] = 0; } while (0);
      }
    do { mpi_size_t _i; for( _i = 0; _i < (bsize); _i++ ) (rp)[_i] = (bp)[_i]; } while(0);

    e = ep[i];
    do { USItype __cbtmp; __asm__ ("bsrl %1,%0" : "=r" (__cbtmp) : "rm" ((USItype)(e)) : "cc"); (c) = __cbtmp ^ 31; } while (0);
    e = (e << c) << 1;
    c = (8*(4)) - 1 - c;

    j = 0;

    for (;;)
      if (e == 0)
        {
          j += c;
          if ( --i < 0 )
            break;

          e = ep[i];
          c = (8*(4));
        }
      else
        {
          int c0;
          mpi_limb_t e0;
          struct gcry_mpi w, u;
          w.sign = u.sign = 0;
          w.flags = u.flags = 0;
          w.d = base_u;

          do { USItype __cbtmp; __asm__ ("bsrl %1,%0" : "=r" (__cbtmp) : "rm" ((USItype)(e)) : "cc"); (c0) = __cbtmp ^ 31; } while (0);
          e = (e << c0);
          c -= c0;
          j += c0;

          e0 = (e >> ((8*(4)) - W));
          if (c >= W)
            c0 = 0;
          else
            {
              if ( --i < 0 )
                {
                  e0 = (e >> ((8*(4)) - c));
                  j += c - W;
                  goto last_step;
                }
              else
                {
                  c0 = c;
                  e = ep[i];
                  c = (8*(4));
                  e0 |= (e >> ((8*(4)) - (W - c0)));
                }
            }

          e = e << (W - c0);
          c -= (W - c0);

        last_step:
          __asm__ ("bsfl %1,%0" : "=r" (c0) : "rm" ((USItype)(e0)) : "cc");
          e0 = (e0 >> c0) >> 1;

          for (j += W - c0; j >= 0; j--)
            {

              /*
               *  base_u <= precomp[e0]
               *  base_u_size <= precomp_size[e0]
               */
              base_u_size = 0;
              for (k = 0; k < (1<< (W - 1)); k++)
                {
                  w.alloced = w.nlimbs = precomp_size[k];
                  u.alloced = u.nlimbs = precomp_size[k];
                  u.d = precomp[k];

                  _gcry_mpi_set_cond ((&w),(&u),(k == e0));
                  base_u_size |= ( precomp_size[k] & (0UL - (k == e0)) );
                }

              w.alloced = w.nlimbs = rsize;
              u.alloced = u.nlimbs = rsize;
              u.d = rp;
              _gcry_mpi_set_cond ((&w),(&u),(j != 0));
              base_u_size ^= ((base_u_size ^ rsize) & (0UL - (j != 0)));

              mul_mod (xp, &xsize, rp, rsize, base_u, base_u_size,
                       mp, msize, &karactx);
              tp = rp; rp = xp; xp = tp;
              rsize = xsize;
            }

          j = c0;
          if ( i < 0 )
            break;
        }

    while (j--)
      {
        mul_mod (xp, &xsize, rp, rsize, rp, rsize, mp, msize, &karactx);
        tp = rp; rp = xp; xp = tp;
        rsize = xsize;
      }

    /* We shifted MOD, the modulo reduction argument, left
       MOD_SHIFT_CNT steps.  Adjust the result by reducing it with the
       original MOD.

       Also make sure the result is put in RES->d (where it already
       might be, see above).  */
    if ( mod_shift_cnt )
      {
        carry_limb = _gcry_mpih_lshift( res->d, rp, rsize, mod_shift_cnt);
        rp = res->d;
        if ( carry_limb )
          {
            rp[rsize] = carry_limb;
            rsize++;
          }
      }
    else if (res->d != rp)
      {
        do { mpi_size_t _i; for( _i = 0; _i < (rsize); _i++ ) (res->d)[_i] = (rp)[_i]; } while(0);
        rp = res->d;
      }

    if ( rsize >= msize )
      {
        _gcry_mpih_divrem(rp + msize, 0, rp, rsize, mp, msize);
        rsize = msize;
      }

    /* Remove any leading zero words from the result.  */
    if ( mod_shift_cnt )
      _gcry_mpih_rshift( rp, rp, rsize, mod_shift_cnt);
    do { while( (rsize) > 0 ) { if( (rp)[(rsize)-1] ) break; (rsize)--; } } while(0);

    _gcry_mpih_release_karatsuba_ctx (&karactx );
    for (i = 0; i < (1 << (W - 1)); i++)
      _gcry_mpi_free_limb_space( precomp[i], esec ? precomp_size[i] : 0 );
    _gcry_mpi_free_limb_space (base_u, esec ? max_u_size : 0);
  }

  /* Fixup for negative results.  */
  if ( negative_result && rsize )
    {
      if ( mod_shift_cnt )
        _gcry_mpih_rshift( mp, mp, msize, mod_shift_cnt);
      _gcry_mpih_sub( rp, mp, msize, rp, rsize);
      rsize = msize;
      rsign = msign;
      do { while( (rsize) > 0 ) { if( (rp)[(rsize)-1] ) break; (rsize)--; } } while(0);
    }
  ((res->d == rp)? (void)0 : _gcry_assert_failed ("res->d == rp", "mpi-pow.c", 756, __FUNCTION__));
  res->nlimbs = rsize;
  res->sign = rsign;

 leave:
  if (mp_marker)
    _gcry_mpi_free_limb_space( mp_marker, mp_nlimbs );
  if (bp_marker)
    _gcry_mpi_free_limb_space( bp_marker, bp_nlimbs );
  if (ep_marker)
    _gcry_mpi_free_limb_space( ep_marker, ep_nlimbs );
  if (xp_marker)
    _gcry_mpi_free_limb_space( xp_marker, xp_nlimbs );
}

/*@ rustina_out_of_scope */
# 42 "hwf-x86.c"
static int
is_cpuid_available(void)
{
  int has_cpuid = 0;

  /* Detect the CPUID feature by testing some undefined behaviour (16
     vs 32 bit pushf/popf). */
  asm volatile
    ("pushf\n\t" /* Copy flags to EAX.  */
     "popl %%eax\n\t"
     "movl %%eax, %%ecx\n\t" /* Save flags into ECX.  */
     "xorl $0x200000, %%eax\n\t" /* Toggle ID bit and copy it to the flags.  */
     "pushl %%eax\n\t"
     "popf\n\t"
     "pushf\n\t" /* Copy changed flags again to EAX.  */
     "popl %%eax\n\t"
     "pushl %%ecx\n\t" /* Restore flags from ECX.  */
     "popf\n\t"
     "xorl %%eax, %%ecx\n\t" /* Compare flags against saved flags.  */
     "jz .Lno_cpuid%=\n\t" /* Toggling did not work, thus no CPUID.  */
     "movl $1, %0\n" /* Worked. true -> HAS_CPUID.  */
     ".Lno_cpuid%=:\n\t"
     : "+r" (has_cpuid)
     :
     : "%eax", "%ecx", "cc"
     );

  return has_cpuid;
}

# 72 "hwf-x86.c"
static void
get_cpuid(unsigned int in, unsigned int *eax, unsigned int *ebx,
          unsigned int *ecx, unsigned int *edx)
{
  unsigned int regs[4];

  asm volatile
    ("pushl %%ebx\n\t" /* Save GOT register.  */
     "movl %1, %%ebx\n\t"
     "cpuid\n\t"
     "movl %%ebx, %1\n\t"
     "popl %%ebx\n\t" /* Restore GOT register. */
     : "=a" (regs[0]), "=r" (regs[1]), "=c" (regs[2]), "=d" (regs[3])
     : "0" (in), "1" (0), "2" (0), "3" (0)
     : "cc"
     );

  if (eax)
    *eax = regs[0];
  if (ebx)
    *ebx = regs[1];
  if (ecx)
    *ecx = regs[2];
  if (edx)
    *edx = regs[3];
}

# 100 "hwf-x86.c"
static unsigned int
get_xgetbv(void)
{
  unsigned int t_eax;

  asm volatile
    ("xgetbv\n\t"
     : "=a" (t_eax)
     : "c" (0)
    );

  return t_eax;
}

# 45 "mpih-div.c"
mpi_limb_t
_gcry_mpih_mod_1(mpi_ptr_t dividend_ptr, mpi_size_t dividend_size,
          mpi_limb_t divisor_limb)
{
    mpi_size_t i;
    mpi_limb_t n1, n0, r;
    mpi_limb_t dummy ;

    /* Botch: Should this be handled at all?  Rely on callers?	*/
    if( !dividend_size )
 return 0;

    /* If multiplication is much faster than division, and the
     * dividend is large, pre-invert the divisor, and use
     * only multiplications in the inner loop.
     *
     * This test should be read:
     *	 Does it ever help to use udiv_qrnnd_preinv?
     *	   && Does what we save compensate for the inversion overhead?
     */
    if( 40 > (2 * 40 + 6)
 && (40 - (2 * 40 + 6)) * dividend_size > 40 ) {
 int normalization_steps;

 do { USItype __cbtmp; __asm__ ("bsrl %1,%0" : "=r" (__cbtmp) : "rm" ((USItype)(divisor_limb)) : "cc"); (normalization_steps) = __cbtmp ^ 31; } while (0);
 if( normalization_steps ) {
     mpi_limb_t divisor_limb_inverted;

     divisor_limb <<= normalization_steps;

     /* Compute (2**2N - 2**N * DIVISOR_LIMB) / DIVISOR_LIMB.  The
	     * result is a (N+1)-bit approximation to 1/DIVISOR_LIMB, with the
	     * most significant bit (with weight 2**N) implicit.
	     *
	     * Special case for DIVISOR_LIMB == 100...000.
	     */
     if( !(divisor_limb << 1) )
  divisor_limb_inverted = ~(mpi_limb_t)0;
     else
  __asm__ ("divl %4" : "=a" ((divisor_limb_inverted)), "=d" ((dummy)) : "0" ((USItype)(0)), "1" ((USItype)(-divisor_limb)), "rm" ((USItype)(divisor_limb)) : "cc")
                                     ;

     n1 = dividend_ptr[dividend_size - 1];
     r = n1 >> ((8*(4)) - normalization_steps);

     /* Possible optimization:
	     * if (r == 0
	     * && divisor_limb > ((n1 << normalization_steps)
	     *		       | (dividend_ptr[dividend_size - 2] >> ...)))
	     * ...one division less...
	     */
     for( i = dividend_size - 2; i >= 0; i--) {
  n0 = dividend_ptr[i];
  do { mpi_limb_t _ql ; mpi_limb_t _q, _r; mpi_limb_t _xh, _xl; __asm__ ("mull %3" : "=a" ((_ql)), "=d" ((_q)) : "%0" ((USItype)((r))), "rm" ((USItype)((divisor_limb_inverted))) : "cc"); _q += (r); /* DI is 2**BITS_PER_MPI_LIMB too small */ __asm__ ("mull %3" : "=a" ((_xl)), "=d" ((_xh)) : "%0" ((USItype)(_q)), "rm" ((USItype)((divisor_limb))) : "cc"); __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)((r))), "g" ((USItype)(_xh)), "1" ((USItype)((((n1 << normalization_steps) | (n0 >> ((8*(4)) - normalization_steps)))))), "g" ((USItype)(_xl)) : "cc"); if( _xh ) { __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)(_xh)), "g" ((USItype)(0)), "1" ((USItype)(_r)), "g" ((USItype)((divisor_limb))) : "cc"); _q++; if( _xh) { __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)(_xh)), "g" ((USItype)(0)), "1" ((USItype)(_r)), "g" ((USItype)((divisor_limb))) : "cc"); _q++; } } if( _r >= (divisor_limb) ) { _r -= (divisor_limb); _q++; } (r) = _r; (dummy) = _q; } while (0)


                                         ;
  n1 = n0;
     }
     do { mpi_limb_t _ql ; mpi_limb_t _q, _r; mpi_limb_t _xh, _xl; __asm__ ("mull %3" : "=a" ((_ql)), "=d" ((_q)) : "%0" ((USItype)((r))), "rm" ((USItype)((divisor_limb_inverted))) : "cc"); _q += (r); /* DI is 2**BITS_PER_MPI_LIMB too small */ __asm__ ("mull %3" : "=a" ((_xl)), "=d" ((_xh)) : "%0" ((USItype)(_q)), "rm" ((USItype)((divisor_limb))) : "cc"); __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)((r))), "g" ((USItype)(_xh)), "1" ((USItype)((n1 << normalization_steps))), "g" ((USItype)(_xl)) : "cc"); if( _xh ) { __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)(_xh)), "g" ((USItype)(0)), "1" ((USItype)(_r)), "g" ((USItype)((divisor_limb))) : "cc"); _q++; if( _xh) { __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)(_xh)), "g" ((USItype)(0)), "1" ((USItype)(_r)), "g" ((USItype)((divisor_limb))) : "cc"); _q++; } } if( _r >= (divisor_limb) ) { _r -= (divisor_limb); _q++; } (r) = _r; (dummy) = _q; } while (0)

                                             ;
     return r >> normalization_steps;
 }
 else {
     mpi_limb_t divisor_limb_inverted;

     /* Compute (2**2N - 2**N * DIVISOR_LIMB) / DIVISOR_LIMB.  The
	     * result is a (N+1)-bit approximation to 1/DIVISOR_LIMB, with the
	     * most significant bit (with weight 2**N) implicit.
	     *
	     * Special case for DIVISOR_LIMB == 100...000.
	     */
     if( !(divisor_limb << 1) )
  divisor_limb_inverted = ~(mpi_limb_t)0;
     else
  __asm__ ("divl %4" : "=a" ((divisor_limb_inverted)), "=d" ((dummy)) : "0" ((USItype)(0)), "1" ((USItype)(-divisor_limb)), "rm" ((USItype)(divisor_limb)) : "cc")
                                      ;

     i = dividend_size - 1;
     r = dividend_ptr[i];

     if( r >= divisor_limb )
  r = 0;
     else
  i--;

     for( ; i >= 0; i--) {
  n0 = dividend_ptr[i];
  do { mpi_limb_t _ql ; mpi_limb_t _q, _r; mpi_limb_t _xh, _xl; __asm__ ("mull %3" : "=a" ((_ql)), "=d" ((_q)) : "%0" ((USItype)((r))), "rm" ((USItype)((divisor_limb_inverted))) : "cc"); _q += (r); /* DI is 2**BITS_PER_MPI_LIMB too small */ __asm__ ("mull %3" : "=a" ((_xl)), "=d" ((_xh)) : "%0" ((USItype)(_q)), "rm" ((USItype)((divisor_limb))) : "cc"); __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)((r))), "g" ((USItype)(_xh)), "1" ((USItype)((n0))), "g" ((USItype)(_xl)) : "cc"); if( _xh ) { __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)(_xh)), "g" ((USItype)(0)), "1" ((USItype)(_r)), "g" ((USItype)((divisor_limb))) : "cc"); _q++; if( _xh) { __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)(_xh)), "g" ((USItype)(0)), "1" ((USItype)(_r)), "g" ((USItype)((divisor_limb))) : "cc"); _q++; } } if( _r >= (divisor_limb) ) { _r -= (divisor_limb); _q++; } (r) = _r; (dummy) = _q; } while (0)
                                              ;
     }
     return r;
 }
    }
    else {
 if( 0 ) {
     int normalization_steps;

     do { USItype __cbtmp; __asm__ ("bsrl %1,%0" : "=r" (__cbtmp) : "rm" ((USItype)(divisor_limb)) : "cc"); (normalization_steps) = __cbtmp ^ 31; } while (0);
     if( normalization_steps ) {
  divisor_limb <<= normalization_steps;

  n1 = dividend_ptr[dividend_size - 1];
  r = n1 >> ((8*(4)) - normalization_steps);

  /* Possible optimization:
		 * if (r == 0
		 * && divisor_limb > ((n1 << normalization_steps)
		 *		   | (dividend_ptr[dividend_size - 2] >> ...)))
		 * ...one division less...
		 */
  for(i = dividend_size - 2; i >= 0; i--) {
      n0 = dividend_ptr[i];
      __asm__ ("divl %4" : "=a" ((dummy)), "=d" ((r)) : "0" ((USItype)(((n1 << normalization_steps) | (n0 >> ((8*(4)) - normalization_steps))))), "1" ((USItype)(r)), "rm" ((USItype)(divisor_limb)) : "cc")


                 ;
      n1 = n0;
  }
  __asm__ ("divl %4" : "=a" ((dummy)), "=d" ((r)) : "0" ((USItype)(n1 << normalization_steps)), "1" ((USItype)(r)), "rm" ((USItype)(divisor_limb)) : "cc")

                    ;
  return r >> normalization_steps;
     }
 }
 /* No normalization needed, either because udiv_qrnnd doesn't require
	 * it, or because DIVISOR_LIMB is already normalized.  */
 i = dividend_size - 1;
 r = dividend_ptr[i];

 if(r >= divisor_limb)
     r = 0;
 else
     i--;

 for(; i >= 0; i--) {
     n0 = dividend_ptr[i];
     __asm__ ("divl %4" : "=a" ((dummy)), "=d" ((r)) : "0" ((USItype)(n0)), "1" ((USItype)(r)), "rm" ((USItype)(divisor_limb)) : "cc");
 }
 return r;
    }
}

# 392 "mpih-div.c"
mpi_limb_t
_gcry_mpih_divmod_1( mpi_ptr_t quot_ptr,
                        mpi_ptr_t dividend_ptr, mpi_size_t dividend_size,
                        mpi_limb_t divisor_limb)
{
    mpi_size_t i;
    mpi_limb_t n1, n0, r;
    mpi_limb_t dummy ;

    if( !dividend_size )
 return 0;

    /* If multiplication is much faster than division, and the
     * dividend is large, pre-invert the divisor, and use
     * only multiplications in the inner loop.
     *
     * This test should be read:
     * Does it ever help to use udiv_qrnnd_preinv?
     * && Does what we save compensate for the inversion overhead?
     */
    if( 40 > (2 * 40 + 6)
 && (40 - (2 * 40 + 6)) * dividend_size > 40 ) {
 int normalization_steps;

 do { USItype __cbtmp; __asm__ ("bsrl %1,%0" : "=r" (__cbtmp) : "rm" ((USItype)(divisor_limb)) : "cc"); (normalization_steps) = __cbtmp ^ 31; } while (0);
 if( normalization_steps ) {
     mpi_limb_t divisor_limb_inverted;

     divisor_limb <<= normalization_steps;

     /* Compute (2**2N - 2**N * DIVISOR_LIMB) / DIVISOR_LIMB.  The
	     * result is a (N+1)-bit approximation to 1/DIVISOR_LIMB, with the
	     * most significant bit (with weight 2**N) implicit.
	     */
     /* Special case for DIVISOR_LIMB == 100...000.  */
     if( !(divisor_limb << 1) )
  divisor_limb_inverted = ~(mpi_limb_t)0;
     else
  __asm__ ("divl %4" : "=a" ((divisor_limb_inverted)), "=d" ((dummy)) : "0" ((USItype)(0)), "1" ((USItype)(-divisor_limb)), "rm" ((USItype)(divisor_limb)) : "cc")
                                     ;

     n1 = dividend_ptr[dividend_size - 1];
     r = n1 >> ((8*(4)) - normalization_steps);

     /* Possible optimization:
	     * if (r == 0
	     * && divisor_limb > ((n1 << normalization_steps)
	     *		       | (dividend_ptr[dividend_size - 2] >> ...)))
	     * ...one division less...
	     */
     for( i = dividend_size - 2; i >= 0; i--) {
  n0 = dividend_ptr[i];
  do { mpi_limb_t _ql ; mpi_limb_t _q, _r; mpi_limb_t _xh, _xl; __asm__ ("mull %3" : "=a" ((_ql)), "=d" ((_q)) : "%0" ((USItype)((r))), "rm" ((USItype)((divisor_limb_inverted))) : "cc"); _q += (r); /* DI is 2**BITS_PER_MPI_LIMB too small */ __asm__ ("mull %3" : "=a" ((_xl)), "=d" ((_xh)) : "%0" ((USItype)(_q)), "rm" ((USItype)((divisor_limb))) : "cc"); __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)((r))), "g" ((USItype)(_xh)), "1" ((USItype)((((n1 << normalization_steps) | (n0 >> ((8*(4)) - normalization_steps)))))), "g" ((USItype)(_xl)) : "cc"); if( _xh ) { __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)(_xh)), "g" ((USItype)(0)), "1" ((USItype)(_r)), "g" ((USItype)((divisor_limb))) : "cc"); _q++; if( _xh) { __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)(_xh)), "g" ((USItype)(0)), "1" ((USItype)(_r)), "g" ((USItype)((divisor_limb))) : "cc"); _q++; } } if( _r >= (divisor_limb) ) { _r -= (divisor_limb); _q++; } (r) = _r; (quot_ptr[i + 1]) = _q; } while (0)


                                             ;
  n1 = n0;
     }
     do { mpi_limb_t _ql ; mpi_limb_t _q, _r; mpi_limb_t _xh, _xl; __asm__ ("mull %3" : "=a" ((_ql)), "=d" ((_q)) : "%0" ((USItype)((r))), "rm" ((USItype)((divisor_limb_inverted))) : "cc"); _q += (r); /* DI is 2**BITS_PER_MPI_LIMB too small */ __asm__ ("mull %3" : "=a" ((_xl)), "=d" ((_xh)) : "%0" ((USItype)(_q)), "rm" ((USItype)((divisor_limb))) : "cc"); __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)((r))), "g" ((USItype)(_xh)), "1" ((USItype)((n1 << normalization_steps))), "g" ((USItype)(_xl)) : "cc"); if( _xh ) { __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)(_xh)), "g" ((USItype)(0)), "1" ((USItype)(_r)), "g" ((USItype)((divisor_limb))) : "cc"); _q++; if( _xh) { __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)(_xh)), "g" ((USItype)(0)), "1" ((USItype)(_r)), "g" ((USItype)((divisor_limb))) : "cc"); _q++; } } if( _r >= (divisor_limb) ) { _r -= (divisor_limb); _q++; } (r) = _r; (quot_ptr[0]) = _q; } while (0)

                                              ;
     return r >> normalization_steps;
 }
 else {
     mpi_limb_t divisor_limb_inverted;

     /* Compute (2**2N - 2**N * DIVISOR_LIMB) / DIVISOR_LIMB.  The
	     * result is a (N+1)-bit approximation to 1/DIVISOR_LIMB, with the
	     * most significant bit (with weight 2**N) implicit.
	     */
     /* Special case for DIVISOR_LIMB == 100...000.  */
     if( !(divisor_limb << 1) )
  divisor_limb_inverted = ~(mpi_limb_t) 0;
     else
  __asm__ ("divl %4" : "=a" ((divisor_limb_inverted)), "=d" ((dummy)) : "0" ((USItype)(0)), "1" ((USItype)(-divisor_limb)), "rm" ((USItype)(divisor_limb)) : "cc")
                                     ;

     i = dividend_size - 1;
     r = dividend_ptr[i];

     if( r >= divisor_limb )
  r = 0;
     else
  quot_ptr[i--] = 0;

     for( ; i >= 0; i-- ) {
  n0 = dividend_ptr[i];
  do { mpi_limb_t _ql ; mpi_limb_t _q, _r; mpi_limb_t _xh, _xl; __asm__ ("mull %3" : "=a" ((_ql)), "=d" ((_q)) : "%0" ((USItype)((r))), "rm" ((USItype)((divisor_limb_inverted))) : "cc"); _q += (r); /* DI is 2**BITS_PER_MPI_LIMB too small */ __asm__ ("mull %3" : "=a" ((_xl)), "=d" ((_xh)) : "%0" ((USItype)(_q)), "rm" ((USItype)((divisor_limb))) : "cc"); __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)((r))), "g" ((USItype)(_xh)), "1" ((USItype)((n0))), "g" ((USItype)(_xl)) : "cc"); if( _xh ) { __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)(_xh)), "g" ((USItype)(0)), "1" ((USItype)(_r)), "g" ((USItype)((divisor_limb))) : "cc"); _q++; if( _xh) { __asm__ ("subl %5,%1\n" "sbbl %3,%0" : "=r" ((_xh)), "=&r" ((_r)) : "0" ((USItype)(_xh)), "g" ((USItype)(0)), "1" ((USItype)(_r)), "g" ((USItype)((divisor_limb))) : "cc"); _q++; } } if( _r >= (divisor_limb) ) { _r -= (divisor_limb); _q++; } (r) = _r; (quot_ptr[i]) = _q; } while (0)
                                               ;
     }
     return r;
 }
    }
    else {
 if(0) {
     int normalization_steps;

     do { USItype __cbtmp; __asm__ ("bsrl %1,%0" : "=r" (__cbtmp) : "rm" ((USItype)(divisor_limb)) : "cc"); (normalization_steps) = __cbtmp ^ 31; } while (0);
     if( normalization_steps ) {
  divisor_limb <<= normalization_steps;

  n1 = dividend_ptr[dividend_size - 1];
  r = n1 >> ((8*(4)) - normalization_steps);

  /* Possible optimization:
		 * if (r == 0
		 * && divisor_limb > ((n1 << normalization_steps)
		 *		   | (dividend_ptr[dividend_size - 2] >> ...)))
		 * ...one division less...
		 */
  for( i = dividend_size - 2; i >= 0; i--) {
      n0 = dividend_ptr[i];
      __asm__ ("divl %4" : "=a" ((quot_ptr[i + 1])), "=d" ((r)) : "0" ((USItype)(((n1 << normalization_steps) | (n0 >> ((8*(4)) - normalization_steps))))), "1" ((USItype)(r)), "rm" ((USItype)(divisor_limb)) : "cc")


                 ;
      n1 = n0;
  }
  __asm__ ("divl %4" : "=a" ((quot_ptr[0])), "=d" ((r)) : "0" ((USItype)(n1 << normalization_steps)), "1" ((USItype)(r)), "rm" ((USItype)(divisor_limb)) : "cc")

                    ;
  return r >> normalization_steps;
     }
 }
 /* No normalization needed, either because udiv_qrnnd doesn't require
	 * it, or because DIVISOR_LIMB is already normalized.  */
 i = dividend_size - 1;
 r = dividend_ptr[i];

 if(r >= divisor_limb)
     r = 0;
 else
     quot_ptr[i--] = 0;

 for(; i >= 0; i--) {
     n0 = dividend_ptr[i];
     __asm__ ("divl %4" : "=a" ((quot_ptr[i])), "=d" ((r)) : "0" ((USItype)(n0)), "1" ((USItype)(r)), "rm" ((USItype)(divisor_limb)) : "cc");
 }
 return r;
    }
}

# 128 "mpi-div.c"
void
_gcry_mpi_tdiv_qr( gcry_mpi_t quot, gcry_mpi_t rem, gcry_mpi_t num, gcry_mpi_t den)
{
    mpi_ptr_t np, dp;
    mpi_ptr_t qp, rp;
    mpi_size_t nsize = num->nlimbs;
    mpi_size_t dsize = den->nlimbs;
    mpi_size_t qsize, rsize;
    mpi_size_t sign_remainder = num->sign;
    mpi_size_t sign_quotient = num->sign ^ den->sign;
    unsigned normalization_steps;
    mpi_limb_t q_limb;
    mpi_ptr_t marker[5];
    unsigned int marker_nlimbs[5];
    int markidx=0;

    /* Ensure space is enough for quotient and remainder.
     * We need space for an extra limb in the remainder, because it's
     * up-shifted (normalized) below.  */
    rsize = nsize + 1;
    _gcry_mpi_resize((rem),(rsize));

    qsize = rsize - dsize; /* qsize cannot be bigger than this.	*/
    if( qsize <= 0 ) {
 if( num != rem ) {
     rem->nlimbs = num->nlimbs;
     rem->sign = num->sign;
     do { mpi_size_t _i; for( _i = 0; _i < (nsize); _i++ ) (rem->d)[_i] = (num->d)[_i]; } while(0);
 }
 if( quot ) {
     /* This needs to follow the assignment to rem, in case the
	     * numerator and quotient are the same.  */
     quot->nlimbs = 0;
     quot->sign = 0;
 }
 return;
    }

    if( quot )
 _gcry_mpi_resize((quot),(qsize));

    /* Read pointers here, when reallocation is finished.  */
    np = num->d;
    dp = den->d;
    rp = rem->d;

    /* Optimize division by a single-limb divisor.  */
    if( dsize == 1 ) {
 mpi_limb_t rlimb;
 if( quot ) {
     qp = quot->d;
     rlimb = _gcry_mpih_divmod_1( qp, np, nsize, dp[0] );
     qsize -= qp[qsize - 1] == 0;
     quot->nlimbs = qsize;
     quot->sign = sign_quotient;
 }
 else
     rlimb = _gcry_mpih_mod_1( np, nsize, dp[0] );
 rp[0] = rlimb;
 rsize = rlimb != 0?1:0;
 rem->nlimbs = rsize;
 rem->sign = sign_remainder;
 return;
    }


    if( quot ) {
 qp = quot->d;
 /* Make sure QP and NP point to different objects.  Otherwise the
	 * numerator would be gradually overwritten by the quotient limbs.  */
 if(qp == np) { /* Copy NP object to temporary space.  */
            marker_nlimbs[markidx] = nsize;
     np = marker[markidx++] = _gcry_mpi_alloc_limb_space((nsize),(((quot) && ((quot)->flags&1))))
                             ;
     do { mpi_size_t _i; for( _i = 0; _i < (nsize); _i++ ) (np)[_i] = (qp)[_i]; } while(0);
 }
    }
    else /* Put quotient at top of remainder. */
 qp = rp + dsize;

    do { USItype __cbtmp; __asm__ ("bsrl %1,%0" : "=r" (__cbtmp) : "rm" ((USItype)(dp[dsize - 1])) : "cc"); (normalization_steps) = __cbtmp ^ 31; } while (0);

    /* Normalize the denominator, i.e. make its most significant bit set by
     * shifting it NORMALIZATION_STEPS bits to the left.  Also shift the
     * numerator the same number of steps (to keep the quotient the same!).
     */
    if( normalization_steps ) {
 mpi_ptr_t tp;
 mpi_limb_t nlimb;

 /* Shift up the denominator setting the most significant bit of
	 * the most significant word.  Use temporary storage not to clobber
	 * the original contents of the denominator.  */
        marker_nlimbs[markidx] = dsize;
 tp = marker[markidx++] = _gcry_mpi_alloc_limb_space((dsize),(((den) && ((den)->flags&1))));
 _gcry_mpih_lshift( tp, dp, dsize, normalization_steps );
 dp = tp;

 /* Shift up the numerator, possibly introducing a new most
	 * significant word.  Move the shifted numerator in the remainder
	 * meanwhile.  */
 nlimb = _gcry_mpih_lshift(rp, np, nsize, normalization_steps);
 if( nlimb ) {
     rp[nsize] = nlimb;
     rsize = nsize + 1;
 }
 else
     rsize = nsize;
    }
    else {
 /* The denominator is already normalized, as required.	Copy it to
	 * temporary space if it overlaps with the quotient or remainder.  */
 if( dp == rp || (quot && (dp == qp))) {
     mpi_ptr_t tp;

            marker_nlimbs[markidx] = dsize;
     tp = marker[markidx++] = _gcry_mpi_alloc_limb_space((dsize),(((den) && ((den)->flags&1))))
                                                                             ;
     do { mpi_size_t _i; for( _i = 0; _i < (dsize); _i++ ) (tp)[_i] = (dp)[_i]; } while(0);
     dp = tp;
 }

 /* Move the numerator to the remainder.  */
 if( rp != np )
     do { mpi_size_t _i; for( _i = 0; _i < (nsize); _i++ ) (rp)[_i] = (np)[_i]; } while(0);

 rsize = nsize;
    }

    q_limb = _gcry_mpih_divrem( qp, 0, rp, rsize, dp, dsize );

    if( quot ) {
 qsize = rsize - dsize;
 if(q_limb) {
     qp[qsize] = q_limb;
     qsize += 1;
 }

 quot->nlimbs = qsize;
 quot->sign = sign_quotient;
    }

    rsize = dsize;
    do { while( (rsize) > 0 ) { if( (rp)[(rsize)-1] ) break; (rsize)--; } } while(0);

    if( normalization_steps && rsize ) {
 _gcry_mpih_rshift(rp, rp, rsize, normalization_steps);
 rsize -= rp[rsize - 1] == 0?1:0;
    }

    rem->nlimbs = rsize;
    rem->sign = sign_remainder;
    while( markidx )
      {
        markidx--;
 _gcry_mpi_free_limb_space (marker[markidx], marker_nlimbs[markidx]);
      }
}
